<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="../css/strict.xsl"?>
<PAGE xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../css/schema.xsd" xml:lang="en">
<TITLE>OCaml</TITLE>
<PATH>notes/ocaml.xml</PATH>
<DATE><YEAR>2023</YEAR><MONTH>5</MONTH><DAY>27</DAY></DATE>
<CONTENT>
<BLIST>
  <ITEM><BLIST><TITLE>Comments</TITLE>
    <ITEM>Comments are written between <CODEROUTINE>(*</CODEROUTINE> and <CODEROUTINE>*)</CODEROUTINE>.</ITEM>
    <ITEM>Comments can be nested.</ITEM>
  </BLIST></ITEM>
  <ITEM><BLIST><TITLE>Variables</TITLE>
    <ITEM>define and initialise a variable
      <CODESAMPLE><PROMPT/>let x = 50;;</CODESAMPLE>
    </ITEM>
  </BLIST></ITEM>
  <ITEM><BLIST><TITLE>Function</TITLE>
    <ITEM>define a function
      <CODESAMPLE><PROMPT/>let max a b = if a &lt; b then b else a;;</CODESAMPLE>
      or
      <CODESAMPLE>let max = fun a b -&gt; if a &lt; b then b else a;;</CODESAMPLE>
    </ITEM>
    <ITEM>define a recursive function
      <CODESAMPLE><PROMPT/>let rec range a b = if a &gt; b then [] else a :: range (a + 1) b;;</CODESAMPLE>
    </ITEM>
    <ITEM>define mutually recursive functions
      <CODESAMPLE><PROMPT/>let rec even n =<BR/>
        match n with<BR/>
        | 0 -&gt; true<BR/>
        | x -&gt; odd (x - 1)<BR/>
        and odd n =<BR/>
        match n with<BR/>
        | 0 -&gt; false<BR/>
        | x -&gt; even (x - 1);;</CODESAMPLE>
    </ITEM>
    <ITEM>The application operator <CODEROUTINE>@@</CODEROUTINE> applies the function defined on the left side to the argument defined on the right side
      <CODESAMPLE><PROMPT/>succ @@ 4 + 5;;<BR/>
        - : int = 10</CODESAMPLE>
    </ITEM>
    <ITEM>The reverse application operator (a.k.a pipeline operator) <CODEROUTINE>|&gt;</CODEROUTINE> applies the function defined on the right side to the argument defined on the left side
      <CODESAMPLE><PROMPT/>4 + 5 |&gt; succ;;<BR/>
        - : int = 10</CODESAMPLE>
    </ITEM>
  </BLIST></ITEM>
  <ITEM>conditional expressions use <CODEFILENAME>if … then … else …</CODEFILENAME>
    <CODESAMPLE><PROMPT/>let rec gcd a b = if b = 0 then a else gcd b (a mod b);;</CODESAMPLE>
  </ITEM>
  <ITEM><BLIST><TITLE>Pattern matching</TITLE>
    <ITEM><CODEROUTINE>_</CODEROUTINE> matches anything.</ITEM>
    <ITEM>Patterns can be combined
      <CODESAMPLE><PROMPT/>let isvowel c =<BR/>
        <TAB/>match c with<BR/>
        <TAB/>'a' | 'e' | 'i' | 'o' | 'u' -&gt; true<BR/>
      <TAB/>| _ -&gt; false</CODESAMPLE></ITEM>
  </BLIST></ITEM>
  <ITEM><BLIST><TITLE>Data types</TITLE>
    <ITEM><BLIST><TITLE>The Basic types are</TITLE>
      <ITEM>int: 63-bit signed int on 64-bit processors, or 31-bit signed int on 32-bit processors</ITEM>
      <ITEM>float: IEEE double-precision floating point</ITEM>
      <ITEM>bool: Boolean, written either <CODEROUTINE>true</CODEROUTINE> or <CODEROUTINE>false</CODEROUTINE></ITEM>
      <ITEM>char: 8-bit character</ITEM>
      <ITEM>string: sequence of 8 bit chars</ITEM>
    </BLIST></ITEM>
    <ITEM><CODEROUTINE>Int</CODEROUTINE> module
      <DEFINITIONTABLE>
        <ROW>
          <TERM><CODEROUTINE>val zero : int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>zero</CODEROUTINE> is the integer <CODEROUTINE>0</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val one : int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>one</CODEROUTINE> is the integer <CODEROUTINE>1</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val minus_one : int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>minus_one</CODEROUTINE> is the integer <CODEROUTINE>-1</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val neg : int -&gt; int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>neg x</CODEROUTINE> is <CODEROUTINE>~-x</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val add : int -&gt; int -&gt; int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>add x y</CODEROUTINE> is the addition <CODEROUTINE>x + y</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val sub : int -&gt; int -&gt; int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>sub x y</CODEROUTINE> is the subtraction <CODEROUTINE>x - y</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val mul : int -&gt; int -&gt; int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>mul x y</CODEROUTINE> is the multiplication <CODEROUTINE>x * y</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val div : int -&gt; int -&gt; int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>div x y</CODEROUTINE> is the division <CODEROUTINE>x / y</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val rem : int -&gt; int -&gt; int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>rem x y</CODEROUTINE> is the remainder <CODEROUTINE>x mod y</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val succ : int -&gt; int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>succ x</CODEROUTINE> is <CODEROUTINE>add x 1</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val pred : int -&gt; int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>pred x</CODEROUTINE> is <CODEROUTINE>sub x 1</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val abs : int -&gt; int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>abs x</CODEROUTINE> is the absolute value of x. That is <CODEROUTINE>x</CODEROUTINE> if <CODEROUTINE>x</CODEROUTINE> is positive and <CODEROUTINE>neg x</CODEROUTINE>if <CODEROUTINE>x</CODEROUTINE> is negative.<BR/>
            Warning. This may be negative if the argument is <CODEROUTINE>Int.min_int</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val max_int : int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>max_int</CODEROUTINE> is the greatest representable integer, <CODEROUTINE>2{^[Sys.int_size - 1]} - 1</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val min_int : int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>min_int</CODEROUTINE> is the smallest representable integer, <CODEROUTINE>-2{^[Sys.int_size - 1]}</CODEROUTINE>.</DESC>
        </ROW>
      </DEFINITIONTABLE>
    </ITEM>
    <ITEM><BLIST><TITLE>Strings</TITLE>
      <ITEM>Use <CODEROUTINE>^</CODEROUTINE> two concatenate two strings.</ITEM>
      <ITEM><CODEROUTINE>\</CODEROUTINE> is to be used to escape <CODEROUTINE>"</CODEROUTINE> and <CODEROUTINE>\</CODEROUTINE>.</ITEM>
      <ITEM>Quoted strings
        <CODESAMPLE><PROMPT/>{|This is a quoted string, here, neither \ nor " are special characters|};<BR/>
          <PROMPT/>{delimiter|the end of this|}quoted string is here|delimiter}</CODESAMPLE>
      </ITEM>
      <ITEM><CODEROUTINE>String</CODEROUTINE> module
        <DEFINITIONTABLE>
          <ROW>
            <TERM><CODEROUTINE>val empty : string</CODEROUTINE></TERM>
            <DESC>Return an empty String.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val length : string -&gt; int</CODEROUTINE></TERM>
            <DESC>Return the length of the string.</DESC>
          </ROW>
        </DEFINITIONTABLE>
      </ITEM>
    </BLIST></ITEM>
    <ITEM><BLIST><TITLE>Options</TITLE>
      <ITEM>create an option containing <CODEROUTINE>42</CODEROUTINE>
        <CODESAMPLE>Some 42</CODESAMPLE>
      </ITEM>
      <ITEM>create an empty option
        <CODESAMPLE>None</CODESAMPLE>
      </ITEM>
      <ITEM>pattern matching on an option
        <CODESAMPLE><PROMPT/>let extract o =<BR/>
          match o with<BR/>
          | Some i -&gt; string_of_int i<BR/>
          | None -&gt; "";;</CODESAMPLE>
      </ITEM>
      <ITEM>get the value if not <CODEROUTINE>None</CODEROUTINE>, otherwise a default value
        <CODESAMPLE><PROMPT/>Option.value (Some 77) ~default:(-1);; </CODESAMPLE>
      </ITEM>
      <ITEM><CODEROUTINE>Option</CODEROUTINE> module
        <DEFINITIONTABLE>
          <ROW>
            <TERM><CODEROUTINE>val is_none : 'a option -&gt; bool</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>is_none o</CODEROUTINE> is true if and only if <CODEROUTINE>o</CODEROUTINE> is <CODEROUTINE>None</CODEROUTINE>.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val is_some : 'a option -&gt; bool</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>is_some o</CODEROUTINE> is true if and only if <CODEROUTINE>o</CODEROUTINE> is <CODEROUTINE>Some o</CODEROUTINE>.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val get : 'a option -&gt; 'a</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>get o</CODEROUTINE> is <CODEROUTINE>v</CODEROUTINE> if <CODEROUTINE>o</CODEROUTINE> is <CODEROUTINE>Some v</CODEROUTINE> and raise otherwise.<BR/>
              Raises <CODEROUTINE>Invalid_argument</CODEROUTINE> if <CODEROUTINE>o</CODEROUTINE> is <CODEROUTINE>None</CODEROUTINE>.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val value : 'a option -&gt; default:'a -&gt; 'a</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>value o ~default</CODEROUTINE> is <CODEROUTINE>v</CODEROUTINE> if <CODEROUTINE>o</CODEROUTINE> is <CODEROUTINE>Some v</CODEROUTINE> and <CODEROUTINE>default</CODEROUTINE> otherwise.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val map : ('a -&gt; 'b) -&gt; 'a option -&gt; 'b option</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>map f o</CODEROUTINE> is <CODEROUTINE>None</CODEROUTINE> if <CODEROUTINE>o</CODEROUTINE> is <CODEROUTINE>None</CODEROUTINE> and <CODEROUTINE>Some (f v)</CODEROUTINE> if <CODEROUTINE>o</CODEROUTINE> is <CODEROUTINE>Some v</CODEROUTINE>.</DESC>
          </ROW>
        </DEFINITIONTABLE>
      </ITEM>
    </BLIST></ITEM>
    <ITEM><BLIST><TITLE>Lazy</TITLE>
      <ITEM>create a lazy expression
        <CODESAMPLE><PROMPT/>let a = lazy ( expr );;</CODESAMPLE>
      </ITEM>
      <ITEM>force the evaluation of the expression, the result is memoized
        <CODESAMPLE><PROMPT/>let b = force a;;</CODESAMPLE>
      </ITEM>
    </BLIST></ITEM>
    <ITEM><BLIST><TITLE>Lists</TITLE>
      <ITEM>An ordered collection of any number of elements sharing the same type.</ITEM>
      <ITEM>Syntax
        <CODESAMPLE><PROMPT/>[];;<BR/>
          <PROMPT/>[1];;<BR/>
          <PROMPT/>[1; 2];;<BR/>
          <PROMPT/>[1; 2; 3];;</CODESAMPLE>
      </ITEM>
      <ITEM>head and tail of a list
        <CODESAMPLE><PROMPT/>List.hd [1; 2; 3];;<BR/>
          - : int = 1<BR/>
          <PROMPT/>List.tl [1; 2; 3];;<BR/>
          - : int list = [2; 3]</CODESAMPLE>
      </ITEM>
      <ITEM>The cons operator <CODEROUTINE>::</CODEROUTINE> adds one element to the front of a list.
        <CODESAMPLE><PROMPT/>1 :: [2; 3];;</CODESAMPLE>
      </ITEM>
      <ITEM>The append  operator <CODEROUTINE>@</CODEROUTINE>  combines two lists.
        <CODESAMPLE><PROMPT/>[1] @ [2; 3];;</CODESAMPLE>
      </ITEM>
      <ITEM><CODEROUTINE>List</CODEROUTINE> module
        <DEFINITIONTABLE>
          <ROW>
            <TERM><CODEROUTINE>val cons : 'a -&gt; 'a list -&gt; 'a list</CODEROUTINE></TERM>
            <DESC>Add one element to the front of a list. <CODEROUTINE>cons x xs</CODEROUTINE> is the same as <CODEROUTINE>x :: xs</CODEROUTINE></DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val hd : 'a list -&gt; 'a</CODEROUTINE></TERM>
            <DESC>Return the first element of the given list.<BR/>
              Raises <CODEROUTINE>Failure</CODEROUTINE> if the list is empty.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val tl : 'a list -&gt; 'a list</CODEROUTINE></TERM>
            <DESC>Return the given list without its first element.<BR/>
              Raises <CODEROUTINE>Failure</CODEROUTINE> if the list is empty.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val length : 'a list -&gt; int</CODEROUTINE></TERM>
            <DESC>Return the length of the list.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val compare_lengths : 'a list -&gt; 'b list -&gt; int</CODEROUTINE></TERM>
            <DESC>Compare the lengths of two lists, the computation stops after reaching the end of the shortest list.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val compare_length_with : 'a list -&gt; int -&gt; int</CODEROUTINE></TERM>
            <DESC>Compare the length of a list to an integer, the computation stops after at most <CODEROUTINE>len</CODEROUTINE> iterations on the list.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val nth : 'a list -&gt; int -&gt; 'a</CODEROUTINE></TERM>
            <DESC>Return the n-th element of the given list.<BR/>
              Raises <CODEROUTINE>Failure</CODEROUTINE> if the list is too short;
              <CODEROUTINE>Invalid_argument</CODEROUTINE> if <CODEROUTINE>n</CODEROUTINE> is negative.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val nth_opt : 'a list -&gt; int -&gt; 'a option</CODEROUTINE></TERM>
            <DESC>Return the n-th element of the given list. Return <CODEROUTINE>None</CODEROUTINE> if the list is too short.<BR/>
              Raises <CODEROUTINE>Invalid_argument</CODEROUTINE> if <CODEROUTINE>n</CODEROUTINE> is negative.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list</CODEROUTINE></TERM>
            <DESC>Apply function <CODEROUTINE>f</CODEROUTINE> to <CODEROUTINE>a1, …, an</CODEROUTINE>, and builds the list <CODEROUTINE>[f a1; …; f an]</CODEROUTINE>. Not tail-recursive.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val iter : ('a -&gt; unit) -&gt; 'a list -&gt; unit</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>iter f [a1; …; an]</CODEROUTINE> applies function <CODEROUTINE>f</CODEROUTINE> in turn to <CODEROUTINE>[a1; …; an]</CODEROUTINE>. It is equivalent to <CODEROUTINE>f a1; f a2; …; f an.</CODEROUTINE></DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val map2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c list</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>map2 f [a1; …; an] [b1; …; bn]</CODEROUTINE> is <CODEROUTINE>[f a1 b1; …; f an bn]</CODEROUTINE>. Not tail-recursive.<BR/>
              Raises <CODEROUTINE>Invalid_argument</CODEROUTINE> if the two lists are determined to have different lengths.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val iter2 : ('a -&gt; 'b -&gt; unit) -&gt; 'a list -&gt; 'b list -&gt; unit</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>iter2 f [a1; …; an] [b1; …; bn]</CODEROUTINE> calls in turn <CODEROUTINE>f a1 b1; …; f an bn</CODEROUTINE>.<BR/>
              Raises <CODEROUTINE>Invalid_argument</CODEROUTINE> if the two lists are determined to have different lengths.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val mem : 'a -&gt; 'a list -&gt; bool</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>mem a list</CODEROUTINE> is true if and only if <CODEROUTINE>a</CODEROUTINE> is equal to an element of <CODEROUTINE>list</CODEROUTINE>.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val memq : 'a -&gt; 'a list -&gt; bool</CODEROUTINE></TERM>
            <DESC>Same as <CODEROUTINE>List.mem</CODEROUTINE>, but uses physical equality instead of structural equality to compare list elements.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val for_all : ('a -&gt; bool) -&gt; 'a list -&gt; bool</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>for_all f [a1; …; an]</CODEROUTINE> checks if all elements of the list satisfy the predicate <CODEROUTINE>f</CODEROUTINE>. That is, it returns <CODEROUTINE>(f a1) &gt;&gt; (f a2) &gt;&gt; … &gt;&gt; (f an)</CODEROUTINE> for a non-empty list and <CODEROUTINE>true</CODEROUTINE> if the list is empty</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val exists : ('a -&gt; bool) -&gt; 'a list -&gt; bool</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>exists f [a1; …; an]</CODEROUTINE> checks if at least one element of the list satisfies the predicate <CODEROUTINE>f</CODEROUTINE>. That is, it returns <CODEROUTINE>(f a1) || (f a2) || … || (f an)</CODEROUTINE> for a non-empty list and <CODEROUTINE>false</CODEROUTINE> if the list is empty</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val for_all2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a list -&gt; 'b list -&gt; bool</CODEROUTINE></TERM>
            <DESC>Same as <CODEROUTINE>List.for_all</CODEROUTINE>, but for a two-argument predicate.<BR/>
              Raises <CODEROUTINE>Invalid_argument</CODEROUTINE> if the two lists are determined to have different lengths.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val exists2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a list -&gt; 'b list -&gt; bool</CODEROUTINE></TERM>
            <DESC>Same as <CODEROUTINE>List.exists</CODEROUTINE>, but for a two-argument predicate.<BR/>
              Raises <CODEROUTINE>Invalid_argument</CODEROUTINE> if the two lists are determined to have different lengths.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val find : ('a -&gt; bool) -&gt; 'a list -&gt; 'a</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>find f l</CODEROUTINE> returns the first element of the list <CODEROUTINE>l</CODEROUTINE> that satisfies the predicate <CODEROUTINE>f</CODEROUTINE>.<BR/>
              Raises <CODEROUTINE>Not_found</CODEROUTINE> if there is no value that satisfies <CODEROUTINE>f</CODEROUTINE>in the list <CODEROUTINE>l</CODEROUTINE>.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val find_opt : ('a -&gt; bool) -&gt; 'a list -&gt; 'a option</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>find_opt f l</CODEROUTINE> returns the first element of the list <CODEROUTINE>l</CODEROUTINE> that satisfies the predicate <CODEROUTINE>f</CODEROUTINE>. Returns <CODEROUTINE>None</CODEROUTINE> if there is no value that satisfies <CODEROUTINE>f</CODEROUTINE> in the list <CODEROUTINE>l</CODEROUTINE>.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val filter : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list</CODEROUTINE><BR/>
              <CODEROUTINE>val find_all : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>filter f l</CODEROUTINE> returns all the elements of the list <CODEROUTINE>l</CODEROUTINE> that satisfy the predicate <CODEROUTINE>f</CODEROUTINE>. The order of the elements in the input list is preserved.<BR/>
              <CODEROUTINE>find_all</CODEROUTINE> is another name for <CODEROUTINE>filter</CODEROUTINE>.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val partition : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list * 'a list</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>partition f l</CODEROUTINE> returns a pair of lists <CODEROUTINE>(l1, l2)</CODEROUTINE>, where <CODEROUTINE>l1</CODEROUTINE> is the list of all the elements of <CODEROUTINE>l</CODEROUTINE> that satisfy the predicate <CODEROUTINE>f</CODEROUTINE>, and <CODEROUTINE>l2</CODEROUTINE> is the list of all the elements of <CODEROUTINE>l</CODEROUTINE> that do not satisfy <CODEROUTINE>f</CODEROUTINE>. The order of the elements in the input list is preserved.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val assoc : 'a -&gt; ('a * 'b) list -&gt; 'b</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>assoc a l</CODEROUTINE> returns the value associated with key <CODEROUTINE>a</CODEROUTINE> in the list of pairs <CODEROUTINE>l</CODEROUTINE>. That is, <CODEROUTINE>assoc a [ …; (a,b); …] = b</CODEROUTINE> if <CODEROUTINE>(a,b)</CODEROUTINE> is the leftmost binding of <CODEROUTINE>a</CODEROUTINE> in list <CODEROUTINE>l</CODEROUTINE>.<BR/>
              Raises <CODEROUTINE>Not_found</CODEROUTINE> if there is no value associated with <CODEROUTINE>a</CODEROUTINE> in the list <CODEROUTINE>l</CODEROUTINE>.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val assoc_opt : 'a -&gt; ('a * 'b) list -&gt; 'b option</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>assoc_opt a l</CODEROUTINE> returns the value associated with key <CODEROUTINE>a</CODEROUTINE> in the list of pairs <CODEROUTINE>l</CODEROUTINE>. That is, <CODEROUTINE>assoc a [ …; (a,b); …] = Some b</CODEROUTINE> if <CODEROUTINE>(a,b)</CODEROUTINE> is the leftmost binding of <CODEROUTINE>a</CODEROUTINE> in list <CODEROUTINE>l</CODEROUTINE>.Returns <CODEROUTINE>None</CODEROUTINE> if there is no value associated with <CODEROUTINE>a</CODEROUTINE> in the list <CODEROUTINE>l</CODEROUTINE>.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val split : ('a * 'b) list -&gt; 'a list * 'b list</CODEROUTINE></TERM>
            <DESC>Transform a list of pairs into a pair of lists: <CODEROUTINE>split [(a1,b1); …; (an,bn)]</CODEROUTINE> is <CODEROUTINE>([a1; …; an], [b1; …; bn])</CODEROUTINE>. Not tail-recursive.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val combine : 'a list -&gt; 'b list -&gt; ('a * 'b) list</CODEROUTINE></TERM>
            <DESC>Transform a pair of lists into a list of pairs: <CODEROUTINE>combine [a1; …; an] [b1; …; bn]</CODEROUTINE> is <CODEROUTINE>[(a1,b1); …; (an,bn)]</CODEROUTINE>. Not tail-recursive.<BR/>
              Raises <CODEROUTINE>Invalid_argument</CODEROUTINE> if the two lists have different lengths.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val sort : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list</CODEROUTINE></TERM>
            <DESC>Sort a list in increasing order according to a comparison function.</DESC>
          </ROW>
        </DEFINITIONTABLE>
      </ITEM>
    </BLIST></ITEM>
    <ITEM><BLIST><TITLE>Tuples</TITLE>
      <ITEM>A fixed number of elements together.</ITEM>
      <ITEM>Syntax
        <CODESAMPLE><PROMPT/>(true, 0.0, 0.45, 0.73, "french blue");;</CODESAMPLE>
      </ITEM>
    </BLIST></ITEM>
    <ITEM><BLIST><TITLE>Records</TITLE>
      <ITEM>A fixed number of labelled elements.</ITEM>
      <ITEM>Syntax
        <CODESAMPLE><PROMPT/>type colour = {websafe : bool; r : float; g : float; b : float; name : string};;<BR/>
          <PROMPT/>let b = {websafe = true; r = 0.0; g = 0.45; b = 0.73; name = "french blue"};;</CODESAMPLE>
      </ITEM>
      <ITEM>Records may be mutable
        <CODESAMPLE><PROMPT/>type person =  {first_name : string; surname : string; mutable age : int};;<BR/>
          <PROMPT/>let birthday p = p.age &lt;- p.age + 1;;</CODESAMPLE>
      </ITEM>
    </BLIST></ITEM>
    <ITEM><BLIST><TITLE>Fixed-length array</TITLE>
      <ITEM>A mutable compound data type contain elements of the same type.<BR/>
        Its elements may be accessed in constant time.</ITEM>
      <ITEM>Syntax
        <CODESAMPLE><PROMPT/>let arr = [|1; 2; 3|];;<BR/>
          <PROMPT/>arr.(0) &lt;- 0;;</CODESAMPLE>
      </ITEM>
    </BLIST></ITEM>
  </BLIST></ITEM>
  <ITEM><BLIST><TITLE>Installation</TITLE>
    <ITEM><BLIST><TITLE>Using Docker</TITLE>
      <ITEM>a simple installation process:
        <CODESAMPLE>docker run  --name ocaml -it ocaml/opam:ubuntu-22.04-ocaml-4.13 bash</CODESAMPLE>
        in the container
        <CODESAMPLE>opam install utop<BR/>
        exit</CODESAMPLE>
    </ITEM>
    <ITEM>then use this container with
      <CODESAMPLE>docker start ocaml<BR/>
      docker exec -it ocaml bash</CODESAMPLE>
      in the container
      <CODESAMPLE>eval $(opam env)<BR/>
      utop</CODESAMPLE>
      …</ITEM>
    <ITEM>at the end, exit from utop
      <CODESAMPLE>exit 0;;</CODESAMPLE>
      exit from the container
      <CODESAMPLE>exit</CODESAMPLE>
      stop the container
      <CODESAMPLE>docker stop ocaml </CODESAMPLE>
      </ITEM>
    </BLIST></ITEM>
  </BLIST></ITEM>
</BLIST>
</CONTENT>
<X><T>links</T><A>../links/ml.html#ocaml</A><L>en</L><F>HTML</F></X>
</PAGE>