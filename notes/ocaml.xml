<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="../css/strict.xsl"?>
<PAGE xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../css/schema.xsd" xml:lang="en">
<TITLE>OCaml</TITLE>
<PATH>notes/ocaml.xml</PATH>
<DATE><YEAR>2023</YEAR><MONTH>8</MONTH><DAY>7</DAY></DATE>
<CONTENT>
<BLIST>
  <ITEM><BLIST><TITLE>Comments</TITLE>
    <ITEM>Comments are written between <CODEROUTINE>(*</CODEROUTINE> and <CODEROUTINE>*)</CODEROUTINE>.</ITEM>
    <ITEM>Comments can be nested.</ITEM>
  </BLIST></ITEM>
  <ITEM><BLIST><TITLE>Variables</TITLE>
    <ITEM>define and initialise a variable
      <CODESAMPLE><PROMPT/>let x = 50;;</CODESAMPLE>
    </ITEM>
    <ITEM>it is possible to add type annotations
      <CODESAMPLE><PROMPT/>let (x: int) = 50;;</CODESAMPLE>
    </ITEM>
  </BLIST></ITEM>
  <ITEM><BLIST><TITLE>References</TITLE>
    <ITEM>declare a reference
      <CODESAMPLE><PROMPT/>let x = ref 0;;</CODESAMPLE>
    </ITEM>
    <ITEM>get the value of a reference
      <CODESAMPLE><PROMPT/>let y = !x;;</CODESAMPLE>
    </ITEM>
    <ITEM>modify the value of a reference
      <CODESAMPLE><PROMPT/>x := 1;;</CODESAMPLE>
    </ITEM>
    <ITEM>aliasing a reference
      <CODESAMPLE><PROMPT/>let z = x;;</CODESAMPLE>
    </ITEM>
  </BLIST></ITEM>
  <ITEM><BLIST><TITLE>Equality</TITLE>
    <ITEM><CODEROUTINE>e1 == e2</CODEROUTINE> tests for physical equality of <CODEROUTINE>e1</CODEROUTINE> and <CODEROUTINE>e2</CODEROUTINE>. On mutable types such as references, arrays, byte sequences, records with mutable fields and objects with mutable instance variables, <CODEROUTINE>e1 == e2</CODEROUTINE> is true if and only if physical modification of <CODEROUTINE>e1</CODEROUTINE> also affects <CODEROUTINE>e2</CODEROUTINE>. On non-mutable types, the behavior of <CODEROUTINE>( == )</CODEROUTINE> is implementation-dependent; however, it is guaranteed that <CODEROUTINE>e1 == e2</CODEROUTINE> implies <CODEROUTINE>compare e1 e2 = 0</CODEROUTINE>.</ITEM>
    <ITEM><CODEROUTINE>e1 = e2</CODEROUTINE> tests for structural equality of <CODEROUTINE>e1</CODEROUTINE> and <CODEROUTINE>e2</CODEROUTINE>. Mutable structures (e.g. references and arrays) are equal if and only if their current contents are structurally equal, even if the two mutable objects are not the same physical object. Equality between functional values raises <CODEROUTINE>Invalid_argument</CODEROUTINE>. Equality between cyclic data structures may not terminate.</ITEM>
  </BLIST></ITEM>
  <ITEM><BLIST><TITLE>Function</TITLE>
    <ITEM>define a function
      <CODESAMPLE><PROMPT/>let max a b = if a &lt; b then b else a;;</CODESAMPLE>
      or
      <CODESAMPLE><PROMPT/>let max = fun a b -&gt; if a &lt; b then b else a;;</CODESAMPLE>
    </ITEM>
    <ITEM>define a recursive function
      <CODESAMPLE><PROMPT/>let rec range a b = if a &gt; b then [] else a :: range (a + 1) b;;</CODESAMPLE>
    </ITEM>
    <ITEM>with type annotations
      <CODESAMPLE><PROMPT/>let rec pow (x : int) (y : int) : int = if y = 0 then 1 else x * pow x (y - 1);;</CODESAMPLE>
      use <CODEROUTINE>unit</CODEROUTINE> if no value is returned
      <CODESAMPLE><PROMPT/>let print_flat_tree (n: node): unit = print_endline (string_of_list (list_of_tree n))</CODESAMPLE>
    </ITEM>
    <ITEM>to make a function tail recursive
      <NLIST>
        <ITEM>Change the function into a helper function. Add an extra argument: the accumulator, often named <CODEROUTINE>acc</CODEROUTINE>.</ITEM>
        <ITEM>Write a new “main” version of the function that calls the helper. It passes the original base case’s return value as the initial value of the accumulator.</ITEM>
        <ITEM>Change the helper function to return the accumulator in the base case.</ITEM>
        <ITEM>Change the helper function’s recursive case. It now needs to do the extra work on the accumulator argument, before the recursive call.</ITEM>
      </NLIST>
      <CODESAMPLE><PROMPT/> let factorial n =<BR/>
        <TAB/>let rec fact_aux n acc =<BR/>
        <TAB/><TAB/>if n = 0 then acc else fact_aux (n - 1) (n * acc) in <BR/>
        <TAB/><TAB/><TAB/>fact_aux n 1 ;;<BR/>
        val factorial : int -&gt; int = &lt;fun&gt;</CODESAMPLE>
    </ITEM>
    <ITEM>parameters can be labelled
      <CODESAMPLE><PROMPT/>let f ~name1:arg1 ~name2:arg2 = arg1 + arg2;;<BR/>
        <PROMPT/>f ~name2:3 ~name1:4;;</CODESAMPLE>
    </ITEM>
    <ITEM>labels can be used and no variable names are to be given
      <CODESAMPLE><PROMPT/>let f ~name1 ~name2 = name1 + name2;;</CODESAMPLE>
    </ITEM>
    <ITEM>the syntax to write both a labeled argument and an explicit type annotation
      <CODESAMPLE><PROMPT/>let f ~name1:(arg1 : int) ~name2:(arg2 : int) = arg1 + arg2;;</CODESAMPLE>
    </ITEM>
    <ITEM>it is possible to make some arguments optional, a default value is provided
      <CODESAMPLE><PROMPT/>let f ?name:(arg1=8) arg2 = arg1 + arg2;;</CODESAMPLE>
    </ITEM>
    <ITEM>anonymous function, also called lambda expressions
      <CODESAMPLE><PROMPT/>let inc = fun x -&gt; x + 1;;</CODESAMPLE>
    </ITEM>
    <ITEM>define mutually recursive functions
      <CODESAMPLE><PROMPT/>let rec even n =<BR/>
        match n with<BR/>
        <TAB/>| 0 -&gt; true<BR/>
        <TAB/>| x -&gt; odd (x - 1)<BR/>
        and odd n =<BR/>
        <TAB/>match n with<BR/>
        <TAB/>| 0 -&gt; false<BR/>
        <TAB/>| x -&gt; even (x - 1);;</CODESAMPLE>
    </ITEM>
    <ITEM>The application operator <CODEROUTINE>@@</CODEROUTINE> applies the function defined on the left side to the argument defined on the right side
      <CODESAMPLE><PROMPT/>succ @@ 4 + 5;;<BR/>
        - : int = 10</CODESAMPLE>
    </ITEM>
    <ITEM>The reverse application operator (a.k.a pipeline operator) <CODEROUTINE>|&gt;</CODEROUTINE> applies the function defined on the right side to the argument defined on the left side
      <CODESAMPLE><PROMPT/>4 + 5 |&gt; succ;;<BR/>
        - : int = 10</CODESAMPLE>
    </ITEM>
  </BLIST></ITEM>
  <ITEM><BLIST><TITLE>Operator</TITLE>
  <ITEM><CODEROUTINE>=</CODEROUTINE>, <CODEROUTINE>&lt;</CODEROUTINE>, and  <CODEROUTINE>&gt;</CODEROUTINE> are polymorphic.</ITEM>
    <ITEM>An operator between parentheses is a function
      <CODESAMPLE><PROMPT/>( + ) ;;<BR/>
        - : int -&gt; int -&gt; int = &lt;fun&gt;<BR/>
        <PROMPT/>( + ) 2 3 ;;<BR/>
        - : int = 5</CODESAMPLE></ITEM>
    <ITEM>defining an infix operator
    <CODESAMPLE><PROMPT/> let ( ** ) f g x = x |&gt; g |&gt; f ;;<BR/>
      val ( ** ) : ('a -&gt; 'b) -&gt; ('c -&gt; 'a) -&gt; 'c -&gt; 'b = &lt;fun&gt;<BR/>
      <PROMPT/> let g x = x *. x ;;<BR/>
      val g : float -&gt; float = &lt;fun&gt;<BR/>
      <PROMPT/> let f x = -. x ;;<BR/>
      val f : float -&gt; float = &lt;fun&gt;<BR/>
      <PROMPT/> let _ = (f**g) 1.1 ;;<BR/>
      - : float = -1.21000000000000019</CODESAMPLE></ITEM>
    <ITEM>defining a prefix operator
    <CODESAMPLE><PROMPT/> let ( !// ) f x = 1. /. ( f x ) ;;<BR/>
      val ( !// ) : ('a -&gt; float) -&gt; 'a -&gt; float = &lt;fun&gt;<BR/>
      <PROMPT/> let f x = x *. x ;;<BR/>
      val f : float -&gt; float = &lt;fun&gt;<BR/>
      <PROMPT/> let _ = (!// f) 2. ;;<BR/>
      - : float = 0.25</CODESAMPLE></ITEM>
  </BLIST></ITEM>
  <ITEM>conditional expressions use <CODEFILENAME>if … then … else …</CODEFILENAME>
    <CODESAMPLE><PROMPT/>let rec gcd a b = if b = 0 then a else gcd b (a mod b);;</CODESAMPLE>
  </ITEM>
  <ITEM><BLIST><TITLE>Pattern matching</TITLE>
    <ITEM><CODEROUTINE>_</CODEROUTINE> matches anything.</ITEM>
    <ITEM>Patterns can be combined
      <CODESAMPLE><PROMPT/>let isvowel c =<BR/>
        <TAB/>match c with<BR/>
        <TAB/><TAB/>'a' | 'e' | 'i' | 'o' | 'u' -&gt; true<BR/>
        <TAB/><TAB/>| _ -&gt; false</CODESAMPLE>
    </ITEM>
    <ITEM>Pattern matching on records
      <CODESAMPLE>type node = Node of { left : node; value : int; right : node } | Nil</CODESAMPLE>
      If we do not care about the value
      <CODESAMPLE>match nd with<BR/>
        <TAB/>| Nil -&gt; …<BR/>
        <TAB/>| Node _ -&gt; …</CODESAMPLE>
      If we want to get the whole record
      <CODESAMPLE>match nd with<BR/>
        <TAB/>| Nil -&gt; …<BR/>
        <TAB/>| Node n -&gt; …</CODESAMPLE>
      If we want to get the whole record fields
      <CODESAMPLE>match nd with<BR/>
        <TAB/>| Nil -&gt; …<BR/>
        <TAB/>| Node { left = l; value = v; right = r } -&gt; …</CODESAMPLE>
      or with syntactic sugar
      <CODESAMPLE>match nd with<BR/>
        <TAB/>| Nil -&gt; …<BR/>
        <TAB/>| Node { left; value; right } -&gt; …</CODESAMPLE>
      It we want both the whole record and its fields
      <CODESAMPLE>match nd with<BR/>
        <TAB/>| Nil -&gt; …<BR/>
        <TAB/>| Node { left = l; value = v; right = r } as n -&gt; …</CODESAMPLE>
    </ITEM>
    <ITEM><CODEROUTINE>function</CODEROUTINE> keyword automatically has pattern matching
      <CODESAMPLE><PROMPT/>let foo = function<BR/>
        <TAB/>0 -&gt; "zero"<BR/>
        <TAB/>| 1 -&gt; "one"<BR/>
        <TAB/>| 2 -&gt; "couple"<BR/>
        <TAB/>| 3 -&gt; "few"<BR/>
        <TAB/>| _ -&gt; "many";;</CODESAMPLE>
    </ITEM>
  </BLIST></ITEM>
  <ITEM><BLIST><TITLE>Data types</TITLE>
    <ITEM><BLIST><TITLE>The Basic types are</TITLE>
      <ITEM>int: 63-bit signed int on 64-bit processors, or 31-bit signed int on 32-bit processors</ITEM>
      <ITEM>float: IEEE double-precision floating point</ITEM>
      <ITEM>bool: Boolean, written either <CODEROUTINE>true</CODEROUTINE> or <CODEROUTINE>false</CODEROUTINE></ITEM>
      <ITEM>char: 8-bit character</ITEM>
      <ITEM>string: sequence of 8 bit chars</ITEM>
    </BLIST></ITEM>
    <ITEM><CODEROUTINE>Int</CODEROUTINE> module
      <DEFINITIONTABLE>
        <ROW>
          <TERM><CODEROUTINE>val zero : int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>zero</CODEROUTINE> is the integer <CODEROUTINE>0</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val one : int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>one</CODEROUTINE> is the integer <CODEROUTINE>1</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val minus_one : int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>minus_one</CODEROUTINE> is the integer <CODEROUTINE>-1</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val neg : int -&gt; int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>neg x</CODEROUTINE> is <CODEROUTINE>~-x</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val add : int -&gt; int -&gt; int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>add x y</CODEROUTINE> is the addition <CODEROUTINE>x + y</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val sub : int -&gt; int -&gt; int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>sub x y</CODEROUTINE> is the subtraction <CODEROUTINE>x - y</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val mul : int -&gt; int -&gt; int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>mul x y</CODEROUTINE> is the multiplication <CODEROUTINE>x * y</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val div : int -&gt; int -&gt; int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>div x y</CODEROUTINE> is the division <CODEROUTINE>x / y</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val rem : int -&gt; int -&gt; int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>rem x y</CODEROUTINE> is the remainder <CODEROUTINE>x mod y</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val succ : int -&gt; int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>succ x</CODEROUTINE> is <CODEROUTINE>add x 1</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val pred : int -&gt; int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>pred x</CODEROUTINE> is <CODEROUTINE>sub x 1</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val abs : int -&gt; int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>abs x</CODEROUTINE> is the absolute value of x. That is <CODEROUTINE>x</CODEROUTINE> if <CODEROUTINE>x</CODEROUTINE> is positive and <CODEROUTINE>neg x</CODEROUTINE>if <CODEROUTINE>x</CODEROUTINE> is negative.<BR/>
            Warning. This may be negative if the argument is <CODEROUTINE>Int.min_int</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val max_int : int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>max_int</CODEROUTINE> is the greatest representable integer, <CODEROUTINE>2{^[Sys.int_size - 1]} - 1</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val min_int : int</CODEROUTINE><BR/></TERM>
          <DESC><CODEROUTINE>min_int</CODEROUTINE> is the smallest representable integer, <CODEROUTINE>-2{^[Sys.int_size - 1]}</CODEROUTINE>.</DESC>
        </ROW>
      </DEFINITIONTABLE>
    </ITEM>
    <ITEM><BLIST><TITLE>Strings</TITLE>
      <ITEM>Use <CODEROUTINE>^</CODEROUTINE> to concatenate two strings.</ITEM>
      <ITEM><CODEROUTINE>\</CODEROUTINE> is to be used to escape <CODEROUTINE>"</CODEROUTINE> and <CODEROUTINE>\</CODEROUTINE>.</ITEM>
      <ITEM>Quoted strings
        <CODESAMPLE><PROMPT/>{|This is a quoted string, here, neither \ nor " are special characters|};<BR/>
          <PROMPT/>{delimiter|the end of this|}quoted string is here|delimiter}</CODESAMPLE>
      </ITEM>
      <ITEM><CODEROUTINE>String</CODEROUTINE> module
        <DEFINITIONTABLE>
          <ROW>
            <TERM><CODEROUTINE>val empty : string</CODEROUTINE></TERM>
            <DESC>Return an empty string.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val length : string -&gt; int</CODEROUTINE></TERM>
            <DESC>Return the length of the string.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val split_on_char : char -&gt; string -&gt; string list</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>split_on_char sep s</CODEROUTINE> is the list of all (possibly empty) substrings of <CODEROUTINE>s</CODEROUTINE> that are delimited by the character <CODEROUTINE>sep</CODEROUTINE>.</DESC>
          </ROW>
        </DEFINITIONTABLE>
      </ITEM>
    </BLIST></ITEM>
    <ITEM><BLIST><TITLE>Options</TITLE>
      <ITEM>create an option containing <CODEROUTINE>42</CODEROUTINE>
        <CODESAMPLE>Some 42</CODESAMPLE>
      </ITEM>
      <ITEM>create an empty option
        <CODESAMPLE>None</CODESAMPLE>
      </ITEM>
      <ITEM>pattern matching on an option
        <CODESAMPLE><PROMPT/>let extract o =<BR/>
          match o with<BR/>
          <TAB/>| Some i -&gt; string_of_int i<BR/>
          <TAB/>| None -&gt; "";;</CODESAMPLE>
      </ITEM>
      <ITEM>get the value if not <CODEROUTINE>None</CODEROUTINE>, otherwise a default value
        <CODESAMPLE><PROMPT/>Option.value (Some 77) ~default:(-1);; </CODESAMPLE>
      </ITEM>
      <ITEM><CODEROUTINE>Option</CODEROUTINE> module
        <DEFINITIONTABLE>
          <ROW>
            <TERM><CODEROUTINE>val is_none : 'a option -&gt; bool</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>is_none o</CODEROUTINE> is true if and only if <CODEROUTINE>o</CODEROUTINE> is <CODEROUTINE>None</CODEROUTINE>.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val is_some : 'a option -&gt; bool</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>is_some o</CODEROUTINE> is true if and only if <CODEROUTINE>o</CODEROUTINE> is <CODEROUTINE>Some o</CODEROUTINE>.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val get : 'a option -&gt; 'a</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>get o</CODEROUTINE> is <CODEROUTINE>v</CODEROUTINE> if <CODEROUTINE>o</CODEROUTINE> is <CODEROUTINE>Some v</CODEROUTINE> and raise otherwise.<BR/>
              Raises <CODEROUTINE>Invalid_argument</CODEROUTINE> if <CODEROUTINE>o</CODEROUTINE> is <CODEROUTINE>None</CODEROUTINE>.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val value : 'a option -&gt; default:'a -&gt; 'a</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>value o ~default</CODEROUTINE> is <CODEROUTINE>v</CODEROUTINE> if <CODEROUTINE>o</CODEROUTINE> is <CODEROUTINE>Some v</CODEROUTINE> and <CODEROUTINE>default</CODEROUTINE> otherwise.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val map : ('a -&gt; 'b) -&gt; 'a option -&gt; 'b option</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>map f o</CODEROUTINE> is <CODEROUTINE>None</CODEROUTINE> if <CODEROUTINE>o</CODEROUTINE> is <CODEROUTINE>None</CODEROUTINE> and <CODEROUTINE>Some (f v)</CODEROUTINE> if <CODEROUTINE>o</CODEROUTINE> is <CODEROUTINE>Some v</CODEROUTINE>.</DESC>
          </ROW>
        </DEFINITIONTABLE>
      </ITEM>
    </BLIST></ITEM>
    <ITEM><BLIST><TITLE>Lazy</TITLE>
      <ITEM>create a lazy expression
        <CODESAMPLE><PROMPT/>let a = lazy ( expr );;</CODESAMPLE>
      </ITEM>
      <ITEM>force the evaluation of the expression, the result is memoized
        <CODESAMPLE><PROMPT/>let b = force a;;</CODESAMPLE>
      </ITEM>
    </BLIST></ITEM>
    <ITEM><BLIST><TITLE>Lists</TITLE>
      <ITEM>An ordered collection of any number of elements sharing the same type.</ITEM>
      <ITEM>Syntax
        <CODESAMPLE><PROMPT/>[];;<BR/>
          <PROMPT/>[1];;<BR/>
          <PROMPT/>[1; 2];;<BR/>
          <PROMPT/>[1; 2; 3];;</CODESAMPLE>
      </ITEM>
      <ITEM>head and tail of a list
        <CODESAMPLE><PROMPT/>List.hd [1; 2; 3];;<BR/>
          - : int = 1<BR/>
          <PROMPT/>List.tl [1; 2; 3];;<BR/>
          - : int list = [2; 3]</CODESAMPLE>
      </ITEM>
      <ITEM>The cons operator <CODEROUTINE>::</CODEROUTINE> adds one element to the front of a list.
        <CODESAMPLE><PROMPT/>1 :: [2; 3];;</CODESAMPLE>
      </ITEM>
      <ITEM>The append  operator <CODEROUTINE>@</CODEROUTINE>  combines two lists.
        <CODESAMPLE><PROMPT/>[1] @ [2; 3];;</CODESAMPLE>
      </ITEM>
      <ITEM><CODEROUTINE>List</CODEROUTINE> module
        <DEFINITIONTABLE>
          <ROW>
            <TERM><CODEROUTINE>val cons : 'a -&gt; 'a list -&gt; 'a list</CODEROUTINE></TERM>
            <DESC>Add one element to the front of a list. <CODEROUTINE>cons x xs</CODEROUTINE> is the same as <CODEROUTINE>x :: xs</CODEROUTINE>.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val hd : 'a list -&gt; 'a</CODEROUTINE></TERM>
            <DESC>Return the first element of the given list.<BR/>
              Raises <CODEROUTINE>Failure</CODEROUTINE> if the list is empty.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val tl : 'a list -&gt; 'a list</CODEROUTINE></TERM>
            <DESC>Return the given list without its first element.<BR/>
              Raises <CODEROUTINE>Failure</CODEROUTINE> if the list is empty.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val length : 'a list -&gt; int</CODEROUTINE></TERM>
            <DESC>Return the length of the list.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val compare_lengths : 'a list -&gt; 'b list -&gt; int</CODEROUTINE></TERM>
            <DESC>Compare the lengths of two lists, the computation stops after reaching the end of the shortest list.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val compare_length_with : 'a list -&gt; int -&gt; int</CODEROUTINE></TERM>
            <DESC>Compare the length of a list to an integer, the computation stops after at most <CODEROUTINE>len</CODEROUTINE> iterations on the list.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val nth : 'a list -&gt; int -&gt; 'a</CODEROUTINE></TERM>
            <DESC>Return the n-th element of the given list.<BR/>
              Raises <CODEROUTINE>Failure</CODEROUTINE> if the list is too short;
              <CODEROUTINE>Invalid_argument</CODEROUTINE> if <CODEROUTINE>n</CODEROUTINE> is negative.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val nth_opt : 'a list -&gt; int -&gt; 'a option</CODEROUTINE></TERM>
            <DESC>Return the n-th element of the given list. Return <CODEROUTINE>None</CODEROUTINE> if the list is too short.<BR/>
              Raises <CODEROUTINE>Invalid_argument</CODEROUTINE> if <CODEROUTINE>n</CODEROUTINE> is negative.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val append : 'a list -&gt; 'a list -&gt; 'a list</CODEROUTINE></TERM>
            <DESC>Concatenate two lists. Same function as the infix operator <CODEROUTINE>@</CODEROUTINE>. Not tail-recursive (length of the first argument). The <CODEROUTINE>@</CODEROUTINE> operator is not tail-recursive either.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val concat : 'a list list -&gt; 'a list</CODEROUTINE><BR/>
              <CODEROUTINE>val flatten : 'a list list -&gt; 'a list</CODEROUTINE></TERM>
            <DESC>Concatenate a list of lists. The elements of the argument are all concatenated together (in the same order) to give the result. Not tail-recursive (length of the argument + length of the longest sub-list).</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list</CODEROUTINE></TERM>
            <DESC>Apply function <CODEROUTINE>f</CODEROUTINE> to <CODEROUTINE>a1, …, an</CODEROUTINE>, and builds the list <CODEROUTINE>[f a1; …; f an]</CODEROUTINE>. Not tail-recursive.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val iter : ('a -&gt; unit) -&gt; 'a list -&gt; unit</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>iter f [a1; …; an]</CODEROUTINE> applies function <CODEROUTINE>f</CODEROUTINE> in turn to <CODEROUTINE>[a1; …; an]</CODEROUTINE>. It is equivalent to <CODEROUTINE>f a1; f a2; …; f an</CODEROUTINE>.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val map2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c list</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>map2 f [a1; …; an] [b1; …; bn]</CODEROUTINE> is <CODEROUTINE>[f a1 b1; …; f an bn]</CODEROUTINE>. Not tail-recursive.<BR/>
              Raises <CODEROUTINE>Invalid_argument</CODEROUTINE> if the two lists are determined to have different lengths.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val iter2 : ('a -&gt; 'b -&gt; unit) -&gt; 'a list -&gt; 'b list -&gt; unit</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>iter2 f [a1; …; an] [b1; …; bn]</CODEROUTINE> calls in turn <CODEROUTINE>f a1 b1; …; f an bn</CODEROUTINE>.<BR/>
              Raises <CODEROUTINE>Invalid_argument</CODEROUTINE> if the two lists are determined to have different lengths.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val fold_right : ('a -&gt; 'b -&gt; 'b) -&gt; 'a list -&gt; 'b -&gt; 'b</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>fold_right f [a1; …; an] init</CODEROUTINE> is <CODEROUTINE>f a1 (f a2 (… (f an init) …))</CODEROUTINE>. Not tail-recursive.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val fold_left : ('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'a</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>fold_left f init [b1; …; bn]</CODEROUTINE> is <CODEROUTINE>f (… (f (f init b1) b2) …) bn</CODEROUTINE>.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val fold_left_map : ('a -&gt; 'b -&gt; 'a * 'c) -&gt; 'a -&gt; 'b list -&gt; 'a * 'c list</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>fold_left_map</CODEROUTINE> is a combination of <CODEROUTINE>fold_left</CODEROUTINE> and map that threads an accumulator through calls to <CODEROUTINE>f</CODEROUTINE>.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val concat_map : ('a -&gt; 'b list) -&gt; 'a list -&gt; 'b list</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>concat_map f l</CODEROUTINE> gives the same result as <CODEROUTINE>List.concat (List.map f l)</CODEROUTINE>. Tail-recursive.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val mem : 'a -&gt; 'a list -&gt; bool</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>mem a list</CODEROUTINE> is true if and only if <CODEROUTINE>a</CODEROUTINE> is equal to an element of <CODEROUTINE>list</CODEROUTINE>.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val memq : 'a -&gt; 'a list -&gt; bool</CODEROUTINE></TERM>
            <DESC>Same as <CODEROUTINE>List.mem</CODEROUTINE>, but uses physical equality instead of structural equality to compare list elements.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val for_all : ('a -&gt; bool) -&gt; 'a list -&gt; bool</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>for_all f [a1; …; an]</CODEROUTINE> checks if all elements of the list satisfy the predicate <CODEROUTINE>f</CODEROUTINE>. That is, it returns <CODEROUTINE>(f a1) &gt;&gt; (f a2) &gt;&gt; … &gt;&gt; (f an)</CODEROUTINE> for a non-empty list and <CODEROUTINE>true</CODEROUTINE> if the list is empty.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val exists : ('a -&gt; bool) -&gt; 'a list -&gt; bool</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>exists f [a1; …; an]</CODEROUTINE> checks if at least one element of the list satisfies the predicate <CODEROUTINE>f</CODEROUTINE>. That is, it returns <CODEROUTINE>(f a1) || (f a2) || … || (f an)</CODEROUTINE> for a non-empty list and <CODEROUTINE>false</CODEROUTINE> if the list is empty.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val for_all2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a list -&gt; 'b list -&gt; bool</CODEROUTINE></TERM>
            <DESC>Same as <CODEROUTINE>List.for_all</CODEROUTINE>, but for a two-argument predicate.<BR/>
              Raises <CODEROUTINE>Invalid_argument</CODEROUTINE> if the two lists are determined to have different lengths.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val exists2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a list -&gt; 'b list -&gt; bool</CODEROUTINE></TERM>
            <DESC>Same as <CODEROUTINE>List.exists</CODEROUTINE>, but for a two-argument predicate.<BR/>
              Raises <CODEROUTINE>Invalid_argument</CODEROUTINE> if the two lists are determined to have different lengths.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val find : ('a -&gt; bool) -&gt; 'a list -&gt; 'a</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>find f l</CODEROUTINE> returns the first element of the list <CODEROUTINE>l</CODEROUTINE> that satisfies the predicate <CODEROUTINE>f</CODEROUTINE>.<BR/>
              Raises <CODEROUTINE>Not_found</CODEROUTINE> if there is no value that satisfies <CODEROUTINE>f</CODEROUTINE>in the list <CODEROUTINE>l</CODEROUTINE>.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val find_opt : ('a -&gt; bool) -&gt; 'a list -&gt; 'a option</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>find_opt f l</CODEROUTINE> returns the first element of the list <CODEROUTINE>l</CODEROUTINE> that satisfies the predicate <CODEROUTINE>f</CODEROUTINE>. Returns <CODEROUTINE>None</CODEROUTINE> if there is no value that satisfies <CODEROUTINE>f</CODEROUTINE> in the list <CODEROUTINE>l</CODEROUTINE>.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val filter : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list</CODEROUTINE><BR/>
              <CODEROUTINE>val find_all : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>filter f l</CODEROUTINE> returns all the elements of the list <CODEROUTINE>l</CODEROUTINE> that satisfy the predicate <CODEROUTINE>f</CODEROUTINE>. The order of the elements in the input list is preserved.<BR/>
              <CODEROUTINE>find_all</CODEROUTINE> is another name for <CODEROUTINE>filter</CODEROUTINE>.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val partition : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list * 'a list</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>partition f l</CODEROUTINE> returns a pair of lists <CODEROUTINE>(l1, l2)</CODEROUTINE>, where <CODEROUTINE>l1</CODEROUTINE> is the list of all the elements of <CODEROUTINE>l</CODEROUTINE> that satisfy the predicate <CODEROUTINE>f</CODEROUTINE>, and <CODEROUTINE>l2</CODEROUTINE> is the list of all the elements of <CODEROUTINE>l</CODEROUTINE> that do not satisfy <CODEROUTINE>f</CODEROUTINE>. The order of the elements in the input list is preserved.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val assoc : 'a -&gt; ('a * 'b) list -&gt; 'b</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>assoc a l</CODEROUTINE> returns the value associated with key <CODEROUTINE>a</CODEROUTINE> in the list of pairs <CODEROUTINE>l</CODEROUTINE>. That is, <CODEROUTINE>assoc a [ …; (a,b); …] = b</CODEROUTINE> if <CODEROUTINE>(a,b)</CODEROUTINE> is the leftmost binding of <CODEROUTINE>a</CODEROUTINE> in list <CODEROUTINE>l</CODEROUTINE>.<BR/>
              Raises <CODEROUTINE>Not_found</CODEROUTINE> if there is no value associated with <CODEROUTINE>a</CODEROUTINE> in the list <CODEROUTINE>l</CODEROUTINE>.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val assoc_opt : 'a -&gt; ('a * 'b) list -&gt; 'b option</CODEROUTINE></TERM>
            <DESC><CODEROUTINE>assoc_opt a l</CODEROUTINE> returns the value associated with key <CODEROUTINE>a</CODEROUTINE> in the list of pairs <CODEROUTINE>l</CODEROUTINE>. That is, <CODEROUTINE>assoc a [ …; (a,b); …] = Some b</CODEROUTINE> if <CODEROUTINE>(a,b)</CODEROUTINE> is the leftmost binding of <CODEROUTINE>a</CODEROUTINE> in list <CODEROUTINE>l</CODEROUTINE>.Returns <CODEROUTINE>None</CODEROUTINE> if there is no value associated with <CODEROUTINE>a</CODEROUTINE> in the list <CODEROUTINE>l</CODEROUTINE>.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val split : ('a * 'b) list -&gt; 'a list * 'b list</CODEROUTINE></TERM>
            <DESC>Transform a list of pairs into a pair of lists: <CODEROUTINE>split [(a1,b1); …; (an,bn)]</CODEROUTINE> is <CODEROUTINE>([a1; …; an], [b1; …; bn])</CODEROUTINE>. Not tail-recursive.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val combine : 'a list -&gt; 'b list -&gt; ('a * 'b) list</CODEROUTINE></TERM>
            <DESC>Transform a pair of lists into a list of pairs: <CODEROUTINE>combine [a1; …; an] [b1; …; bn]</CODEROUTINE> is <CODEROUTINE>[(a1,b1); …; (an,bn)]</CODEROUTINE>. Not tail-recursive.<BR/>
              Raises <CODEROUTINE>Invalid_argument</CODEROUTINE> if the two lists have different lengths.</DESC>
          </ROW>
          <ROW>
            <TERM><CODEROUTINE>val sort : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list</CODEROUTINE></TERM>
            <DESC>Sort a list in increasing order according to a comparison function.</DESC>
          </ROW>
        </DEFINITIONTABLE>
      </ITEM>
    </BLIST></ITEM>
    <ITEM><BLIST><TITLE>Tuples</TITLE>
      <ITEM>A fixed number of elements together. This is useful when a function returns several values, we no not have to define a record.</ITEM>
      <ITEM>Syntax
        <CODESAMPLE><PROMPT/>(true, 0.0, 0.45, 0.73, "french blue");;</CODESAMPLE>
      </ITEM>
      <ITEM>Destructuring <CODEROUTINE>let</CODEROUTINE>
        <CODESAMPLE><PROMPT/>let v = (1, true, "bonjour", 'a');;<BR/>
          val v : int * bool * string * char = (1, true, "bonjour", 'a')<BR/>
          <PROMPT/>let (a,b,c,d) = v;;<BR/>
          val a : int = 1<BR/>
          val b : bool = true<BR/>
          val c : string = "bonjour"<BR/>
          val d : char = 'a'</CODESAMPLE>
          This can also be written
        <CODESAMPLE><PROMPT/>let a,b,c,d = v;;<BR/>
          val a : int = 1<BR/>
          val b : bool = true<BR/>
          val c : string = "bonjour"<BR/>
          val d : char = 'a'</CODESAMPLE>
      </ITEM>
      <ITEM>We can use tuple as a function argument. This gives a nice syntax, but this is less performant because a tuple need to be built.
        <CODESAMPLE><PROMPT/>let f (x,y) = x + y;;<BR/>
          val f : int * int -&gt; int = &lt;fun&gt;<BR/>
          <PROMPT/>f (1,2);;<BR/>
          - : int = 3</CODESAMPLE>
      </ITEM>
      <ITEM>syntax to define a type
      <CODESAMPLE><PROMPT/>type square = int * int * int * int * int * int * int * int * int;;<BR/>
        <PROMPT/>let print_square (sq: square) : unit =<BR/>
        <TAB/>let (a ,b, c, d, e, f, g, h, i) = sq<BR/>
        <TAB/>in Printf.printf "%d %d %d\n%d %d %d\n%d %d %d\n" a b c d e f g h i;;</CODESAMPLE></ITEM>
    </BLIST></ITEM>
    <ITEM><BLIST><TITLE>Records</TITLE>
      <ITEM>A fixed number of labelled elements.</ITEM>
      <ITEM>Syntax
        <CODESAMPLE><PROMPT/>type colour = {websafe : bool; r : float; g : float; b : float; name : string};;<BR/>
          <PROMPT/>let b = {websafe = true; r = 0.0; g = 0.45; b = 0.73; name = "french blue"};;</CODESAMPLE>
      </ITEM>
      <ITEM>Use the dot notation to get a field
          <CODESAMPLE><PROMPT/>b.name;;</CODESAMPLE>
          or pattern matching
          <CODESAMPLE><PROMPT/>match b with {websafe = _; r = _; g = _; b = _; name = n} -&gt; n;;</CODESAMPLE>
          or pattern matching with syntactic sugar if we want to use the same name for both the field and a pattern variable
          <CODESAMPLE><PROMPT/>match b with {websafe ; r ; g ; b ; name } -&gt; name;;;</CODESAMPLE>
      </ITEM>
      <ITEM>It is possible to copy a record while modifying some fields
        <CODESAMPLE><PROMPT/>let c = { b with websafe = false; name = "bleu français" };;</CODESAMPLE>
      </ITEM>
      <ITEM>Records may be mutable
        <CODESAMPLE><PROMPT/>type person =  {first_name : string; surname : string; mutable age : int};;<BR/>
          <PROMPT/>let birthday p = p.age &lt;- p.age + 1;;</CODESAMPLE>
      </ITEM>
      <ITEM>Record types may be recursive
      <CODESAMPLE><PROMPT/>type node = {value : int; next : node};;</CODESAMPLE>
          But here, there is no way to construct a value of that type because of the circularity.
      </ITEM>
    </BLIST></ITEM>
    <ITEM><BLIST><TITLE>Fixed-length array</TITLE>
      <ITEM>A mutable compound data type contain elements of the same type.<BR/>
        Its elements may be accessed in constant time.</ITEM>
      <ITEM>Syntax
        <CODESAMPLE><PROMPT/>let arr = [|1; 2; 3|];;<BR/>
          <PROMPT/>arr.(0) &lt;- 0;;</CODESAMPLE>
      </ITEM>
      <ITEM><CODEROUTINE>Array</CODEROUTINE> module
          <DEFINITIONTABLE>
            <ROW>
              <TERM><CODEROUTINE>val length : 'a array -&gt; int</CODEROUTINE></TERM>
              <DESC>Return the length (number of elements) of the given array.</DESC>
            </ROW>
            <ROW>
              <TERM><CODEROUTINE>val get : 'a array -&gt; int -&gt; 'a</CODEROUTINE></TERM>
              <DESC><CODEROUTINE>get a n</CODEROUTINE> returns the element number <CODEROUTINE>n</CODEROUTINE> of array <CODEROUTINE>a</CODEROUTINE>. The first element has number <CODEROUTINE>0</CODEROUTINE>. <BR/>
                You can write <CODEROUTINE>a.(n)</CODEROUTINE> instead of <CODEROUTINE>get a n</CODEROUTINE>.</DESC>
            </ROW>
          </DEFINITIONTABLE>
      </ITEM>
    </BLIST></ITEM>
    <ITEM><BLIST><TITLE>Variants</TITLE>
      <ITEM>A variant type is a collection of constructors.
        <CODESAMPLE>type point = float * float<BR/>
          type shape =<BR/>
          <TAB/>| Point of point<BR/>
          <TAB/>| Circle of point * float (* center and radius *)<BR/>
          <TAB/>| Rect of point * point (* lower-left and upper-right corners *)<BR/>
          let area = function<BR/>
          <TAB/>| Point _ -&gt; 0.0<BR/>
          <TAB/>| Circle (_, r) -&gt; Float.pi *. (r ** 2.0)<BR/>
          <TAB/>| Rect ((x1, y1), (x2, y2)) -&gt;<BR/>
          <TAB/><TAB/>let w = x2 -. x1 in<BR/>
          <TAB/><TAB/>let h = y2 -. y1 in<BR/>
          <TAB/><TAB/>w *. h<BR/>
          let center = function<BR/>
          <TAB/>| Point p -&gt; p<BR/>
          <TAB/>| Circle (p, _) -&gt; p<BR/>
          <TAB/>| Rect ((x1, y1), (x2, y2)) -&gt; ((x2 +. x1) /. 2.0, (y2 +. y1) /. 2.0)</CODESAMPLE>
      </ITEM>
    </BLIST></ITEM>
  </BLIST></ITEM>
  <ITEM><BLIST><TITLE>Printing</TITLE>
  <ITEM>Built-in print functions: <CODEROUTINE>print_char</CODEROUTINE>, <CODEROUTINE>print_string</CODEROUTINE>, <CODEROUTINE>print_int</CODEROUTINE>, and <CODEROUTINE>print_float</CODEROUTINE>.</ITEM>
  <ITEM><CODEROUTINE>print_endline "str"</CODEROUTINE> prints a string followed by a newline.</ITEM>
  <ITEM><CODEROUTINE>print_newline ())</CODEROUTINE> prints a newline.</ITEM>
  <ITEM><CODEROUTINE>Printf</CODEROUTINE> module
    <DEFINITIONTABLE>
      <ROW>
        <TERM><CODEROUTINE>val printf : ('a, out_channel, unit) format -&gt; 'a</CODEROUTINE></TERM>
        <DESC>Format a message and print it on <CODEROUTINE>stdout</CODEROUTINE>.</DESC>
      </ROW>
      <ROW>
        <TERM><CODEROUTINE>val eprintf : ('a, out_channel, unit) format -&gt; 'a</CODEROUTINE></TERM>
        <DESC>Format a message and print it on <CODEROUTINE>stderr</CODEROUTINE>.</DESC>
      </ROW>
    </DEFINITIONTABLE>
  </ITEM>
  </BLIST></ITEM>
  <ITEM><BLIST><TITLE><CODEROUTINE>Stdlib</CODEROUTINE> module</TITLE>
      <ITEM>This module is automatically opened at the beginning of each compilation.</ITEM>
      <ITEM><DEFINITIONTABLE>
        <ROW>
          <TERM><CODEROUTINE>val ignore : 'a -&gt; unit</CODEROUTINE></TERM>
          <DESC>Discard the value of its argument and return <CODEROUTINE>()</CODEROUTINE>. For instance, <CODEROUTINE>ignore(f x)</CODEROUTINE> discards the result of the side-effecting function <CODEROUTINE>f</CODEROUTINE>. It is equivalent to <CODEROUTINE>f x; ()</CODEROUTINE>, except that the latter may generate a compiler warning; writing <CODEROUTINE>ignore(f x)</CODEROUTINE> instead avoids the warning.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val print_char : char -&gt; unit</CODEROUTINE></TERM>
          <DESC>Print a character on standard output.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val print_string : string -&gt; unit</CODEROUTINE></TERM>
          <DESC>Print a string on standard output.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val print_bytes : bytes -&gt; unit</CODEROUTINE></TERM>
          <DESC>Print a byte sequence on standard output.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val print_int : int -&gt; unit</CODEROUTINE></TERM>
          <DESC>Print an integer, in decimal, on standard output.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val print_float : float -&gt; unit</CODEROUTINE></TERM>
          <DESC>Print a floating-point number, in decimal, on standard output.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val print_endline : string -&gt; unit</CODEROUTINE></TERM>
          <DESC>Print a string, followed by a newline character, on standard output and flush standard output.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val print_newline : unit -&gt; unit</CODEROUTINE></TERM>
          <DESC>Print a newline character on standard output, and flush standard output. This can be used to simulate line buffering of standard output.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val float_of_int : int -&gt; float</CODEROUTINE><BR/>
            <CODEROUTINE>val float : int -&gt; float</CODEROUTINE></TERM>
          <DESC>Convert an integer to floating-point.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val int_of_float : float -&gt; int</CODEROUTINE><BR/>
            <CODEROUTINE>val truncate : float -&gt; int</CODEROUTINE></TERM>
          <DESC>Truncate the given floating-point number to an integer. The result is unspecified if the argument is nan or falls outside the range of representable integers.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val int_of_string_opt : string -&gt; int option</CODEROUTINE></TERM>
          <DESC>Convert the given string to an integer. The string is read in decimal (by default, or if the string begins with <CODEROUTINE>0u</CODEROUTINE>), in hexadecimal (if it begins with <CODEROUTINE>0x</CODEROUTINE> or <CODEROUTINE>0X</CODEROUTINE>), in octal (if it begins with <CODEROUTINE>0o</CODEROUTINE> or <CODEROUTINE>0O</CODEROUTINE>), or in binary (if it begins with <CODEROUTINE>0b</CODEROUTINE> or <CODEROUTINE>0B</CODEROUTINE>).<BR/>
            The <CODEROUTINE>0u</CODEROUTINE> prefix reads the input as an unsigned integer in the range <CODEROUTINE>[0, 2*max_int+1]</CODEROUTINE>. If the input exceeds <CODEROUTINE>max_int</CODEROUTINE> it is converted to the signed integer <CODEROUTINE>min_int + input - max_int - 1</CODEROUTINE>.<BR/>
            The <CODEROUTINE>_</CODEROUTINE> (underscore) character can appear anywhere in the string and is ignored.<BR/>
            Return <CODEROUTINE>None</CODEROUTINE> if the given string is not a valid representation of an integer, or if the integer represented exceeds the range of integers representable in type <CODEROUTINE>int</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val int_of_string : string -&gt; int</CODEROUTINE></TERM>
          <DESC>Same as <CODEROUTINE>int_of_string_opt</CODEROUTINE>, but raise <CODEROUTINE>Failure "int_of_string"</CODEROUTINE> instead of returning <CODEROUTINE>None</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val fst : 'a * 'b -&gt; 'a</CODEROUTINE></TERM>
          <DESC>Return the first component of a pair.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val snd : 'a * 'b -&gt; 'b</CODEROUTINE></TERM>
          <DESC>Return the second component of a pair.</DESC>
        </ROW>
      </DEFINITIONTABLE></ITEM>
  </BLIST></ITEM>
  <ITEM><CODEROUTINE>Sys</CODEROUTINE> module
      <DEFINITIONTABLE>
        <ROW>
          <TERM><CODEROUTINE>val argv : string array</CODEROUTINE></TERM>
          <DESC>The command line arguments given to the process. The first element is the command name used to invoke the program. The following elements are the command-line arguments given to the program.
            <CODESAMPLE>let seed = int_of_string Sys.argv.(1) </CODESAMPLE></DESC>
        </ROW>
      </DEFINITIONTABLE>
  </ITEM>
  <ITEM><CODEROUTINE>Random</CODEROUTINE> module
      <DEFINITIONTABLE>
        <ROW>
          <TERM><CODEROUTINE>val int : int -&gt; int</CODEROUTINE></TERM>
          <DESC>Return a random integer between 0 (inclusive) and bound (exclusive). bound must be greater than 0 and less than 2<SUP>30</SUP>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val init : int -&gt; unit</CODEROUTINE></TERM>
          <DESC>Initialize the domain-local generator, using the argument as a seed. The same seed will always yield the same sequence of numbers.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val full_init : int array -&gt; unit</CODEROUTINE></TERM>
          <DESC>Same as <CODEROUTINE>Random.init</CODEROUTINE> but takes more data as seed.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val self_init : unit -&gt; unit</CODEROUTINE></TERM>
          <DESC>Initialize the domain-local generator with a random seed chosen in a system-dependent way. If <CODEROUTINE>/dev/urandom</CODEROUTINE> is available on the host machine, it is used to provide a highly random initial seed. Otherwise, a less random seed is computed from system parameters (current time, process IDs, domain-local state).<BR/>
            <CODESAMPLE>let _ = Random.self_init ()<BR/>
              let a = Random.int 999</CODESAMPLE></DESC>
        </ROW>
      </DEFINITIONTABLE>
  </ITEM>
  <ITEM><BLIST><TITLE>Exceptions</TITLE>
    <ITEM>define an exception
      <CODESAMPLE><PROMPT/>exception Error ;;<BR/>
        exception Error<BR/>
        <PROMPT/>exception Unix_error of string ;;<BR/>
        exception Unix_error of string</CODESAMPLE>
    </ITEM>
    <ITEM>raise an exception
      <CODESAMPLE><PROMPT/>raise ( Unix_error "File not found" ) ;;<BR/>
        Exception: Unix_error "File not found".</CODESAMPLE>
    </ITEM>
    <ITEM>catching an exception
      <CODESAMPLE><PROMPT/>let safe_divide x y =<BR/>
        <TAB/>try ( x / y ) with<BR/>
        <TAB/><TAB/>| Division_by_zero -&gt; 666 ;;<BR/>
        val safe_divide : int -&gt; int -&gt; int = &lt;fun&gt;<BR/>
        <PROMPT/>safe_divide 1 0 ;;<BR/>
        - : int = 666</CODESAMPLE>
    </ITEM>
    <ITEM>There are some predefined exceptions.
    <BLIST>
      <ITEM><CODEROUTINE>Exit</CODEROUTINE> can be used to terminate an iteration, like a break statement.</ITEM>
      <ITEM><CODEROUTINE>Not_found</CODEROUTINE> should be raised when searching failed because there isn't anything satisfactory to be found.</ITEM>
      <ITEM><CODEROUTINE>Invalid_argument</CODEROUTINE> should be raised when a parameter can't be accepted.<BR/>
        It can be raised using <CODEROUTINE>val invalid_arg : string -&gt; 'a</CODEROUTINE></ITEM>
      <ITEM><CODEROUTINE>Failure</CODEROUTINE> should be raised when a result can't be produced.<BR/>
        It can be raised using <CODEROUTINE>val failwith : string -&gt; 'a</CODEROUTINE></ITEM>
    </BLIST>
    </ITEM>
    <ITEM>Example: verifying the command lines arguments
      <CODESAMPLE>let start = if (Array.length Sys.argv) != 2 then invalid_arg ("Syntax: " ^ Sys.argv.(0) ^ " &lt;seed&gt;"); int_of_string Sys.argv.(1)</CODESAMPLE>
    </ITEM>
  </BLIST></ITEM>
  <ITEM><BLIST><TITLE>Loops</TITLE>
    <ITEM>Three types of loops
      <BLIST>
        <ITEM><CODESAMPLE>while e1 do e2 done</CODESAMPLE></ITEM>
        <ITEM><CODESAMPLE>for x=e1 to e2 do e3 done</CODESAMPLE></ITEM>
        <ITEM><CODESAMPLE>for x=e1 downto e2 do e3 done</CODESAMPLE></ITEM>
      </BLIST>
    </ITEM>
  </BLIST></ITEM>
  <ITEM><BLIST><TITLE>Zarith: arithmetic and logical operations over arbitrary-precision integers</TITLE>
    <ITEM>example
      <CODESAMPLE>open Z<BR/>
        <BR/>
        let c =<BR/>
        <TAB/>let a = Z.of_string "12345678901234567890" in<BR/>
        <TAB/>let b = Z.of_string "98765432109876543210" in<BR/>
        <TAB/>a + b<BR/>
        <BR/>
        let _ = Printf.printf "Sum: %s\n" (Z.to_string c);<BR/></CODESAMPLE>
    </ITEM>
    <ITEM><CODEROUTINE>Z</CODEROUTINE> module
      <DEFINITIONTABLE>
        <ROW>
          <TERM><CODEROUTINE>type t</CODEROUTINE></TERM>
          <DESC>Type of integers of arbitrary length.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>exception Overflow</CODEROUTINE></TERM>
          <DESC>Raised by conversion functions when the value cannot be represented in the destination type.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val of_int : int -&gt; t</CODEROUTINE></TERM>
          <DESC>Converts from a base integer.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val to_int : t -&gt; int</CODEROUTINE></TERM>
          <DESC>Converts to a base integer. May raise an <CODEROUTINE>Overflow</CODEROUTINE>.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val of_string : string -&gt; t</CODEROUTINE></TERM>
          <DESC>Converts a string to an integer.
            An optional <CODEROUTINE>-</CODEROUTINE> prefix indicates a negative number, while a <CODEROUTINE>+</CODEROUTINE> prefix is ignored.
            An optional prefix <CODEROUTINE>0x</CODEROUTINE>, <CODEROUTINE>0o</CODEROUTINE>, or <CODEROUTINE>0b</CODEROUTINE> (following the optional <CODEROUTINE>-</CODEROUTINE> or <CODEROUTINE>+</CODEROUTINE> prefix) indicates that the number is, represented, in hexadecimal, octal, or binary, respectively.
            Otherwise, base 10 is assumed. (Unlike C, a lone <CODEROUTINE>0</CODEROUTINE> prefix does not denote octal.)</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val to_string : t -&gt; string</CODEROUTINE></TERM>
          <DESC>Gives a human-readable, decimal string representation of the argument.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val add : t -&gt; t -&gt; t</CODEROUTINE><BR/>
            <CODEROUTINE>val (+) : t -&gt; t -&gt; t</CODEROUTINE></TERM>
          <DESC>Addition.</DESC>
        </ROW>
        <ROW>
          <TERM><CODEROUTINE>val sub : t -&gt; t -&gt; t</CODEROUTINE><BR/>
            <CODEROUTINE>val (-) : t -&gt; t -&gt; t</CODEROUTINE></TERM>
          <DESC>Subtraction .</DESC>
        </ROW>
      </DEFINITIONTABLE>
  </ITEM>
  </BLIST></ITEM>
  <ITEM><BLIST><TITLE>Installation</TITLE>
    <ITEM><BLIST><TITLE>Using Docker</TITLE>
      <ITEM>a simple installation process:
        <CODESAMPLE>docker run  --name ocaml -it ocaml/opam:ubuntu-22.04-ocaml-4.13 bash</CODESAMPLE>
        in the container
        <CODESAMPLE>opam install utop<BR/>
        exit</CODESAMPLE>
    </ITEM>
    <ITEM>then use this container with
      <CODESAMPLE>docker start ocaml<BR/>
      docker exec -it ocaml bash</CODESAMPLE>
      in the container
      <CODESAMPLE>eval $(opam env)<BR/>
      utop</CODESAMPLE>
      …</ITEM>
    <ITEM>at the end, exit from utop
      <CODESAMPLE>exit 0;;</CODESAMPLE>
      exit from the container
      <CODESAMPLE>exit</CODESAMPLE>
      stop the container
      <CODESAMPLE>docker stop ocaml </CODESAMPLE>
      </ITEM>
    </BLIST></ITEM>
  </BLIST></ITEM>
  <ITEM><BLIST><TITLE>Set up the environment</TITLE>
    <ITEM>on Linux
      <CODESAMPLE><PROMPT/>eval $(opam env)</CODESAMPLE>
    </ITEM>
    <ITEM>on all OSes, to run a command with the environment being set up
      <CODESAMPLE><PROMPT/>opam exec &lt;cmd&gt;</CODESAMPLE>
    </ITEM>
  </BLIST></ITEM>
  <ITEM><BLIST><TITLE>Tools</TITLE>
    <ITEM><BLIST><TITLE><CODEROUTINE>ocamlc</CODEROUTINE></TITLE>
        <ITEM>Compile to bytecodes
          <CODESAMPLE><PROMPT/>ocamlc foobar.ml</CODESAMPLE>
          On most systems, the file produced by the linking phase can be run directly
          <CODESAMPLE><PROMPT/>./camlprog.exe</CODESAMPLE>
        </ITEM>
        <ITEM><CODEROUTINE>ocamlc</CODEROUTINE> can take in input
          <BLIST>
            <ITEM><CODEROUTINE>.ml</CODEROUTINE> which are taken to be source files</ITEM>
            <ITEM><CODEROUTINE>.mli</CODEROUTINE> which are taken to be source files for compilation unit interfaces</ITEM>
            <ITEM><CODEROUTINE>.cmo</CODEROUTINE> which are taken to be compiled object bytecode</ITEM>
            <ITEM><CODEROUTINE>.cma</CODEROUTINE> which are taken taken to be libraries of object bytecode (generated with <CODEROUTINE>ocaml -a</CODEROUTINE>)</ITEM>
            <ITEM><CODEROUTINE>.c</CODEROUTINE> which are taken taken to be C sources files, assed to the C compiler, which generates a <CODEROUTINE>.o</CODEROUTINE>/<CODEROUTINE>.obj</CODEROUTINE> object file</ITEM>
            <ITEM><CODEROUTINE>.o</CODEROUTINE> (<CODEROUTINE>.obj</CODEROUTINE> on Windows) which are assumed to be C object files</ITEM>
            <ITEM><CODEROUTINE>.a</CODEROUTINE> (<CODEROUTINE>.lib</CODEROUTINE> on Windows) which are assumed to be C libraries</ITEM>
            <ITEM><CODEROUTINE>.so</CODEROUTINE> (<CODEROUTINE>.dll</CODEROUTINE> on Windows) which are assumed to be C shared libraries</ITEM>
          </BLIST>
        </ITEM>
        <ITEM>When compiling a <CODEROUTINE>.ml</CODEROUTINE>
          <BLIST>
            <ITEM>If a <CODEROUTINE>.mli</CODEROUTINE> file already exists, <CODEROUTINE>ocamlc</CODEROUTINE> checks that it checks that the <CODEROUTINE>.ml</CODEROUTINE> repects it.<BR/>
              Otherwise it generates one.</ITEM>
              <ITEM><CODEROUTINE>ocamlc</CODEROUTINE> generates a <CODEROUTINE>.cmo</CODEROUTINE>.</ITEM>
              <ITEM><CODEROUTINE>ocamlc</CODEROUTINE> generates a bytecode file <CODEROUTINE>a.out</CODEROUTINE> (<CODEFILENAME>camlprog.exe</CODEFILENAME> on Windows).</ITEM>
          </BLIST>
        </ITEM>
        <ITEM>Compile to bytecodes with debug information and run with stacktrace dump
          <CODESAMPLE><PROMPT/>ocamlc -g foobar.ml<BR/>
            <PROMPT/>OCAMLRUNPARAM=b ./camlprog.exe</CODESAMPLE>
        </ITEM>
    </BLIST></ITEM>
    <ITEM><BLIST><TITLE><CODEROUTINE>ocamlrun</CODEROUTINE></TITLE>
        <ITEM>Run a bytecode file.<BR/>
          Most of the time, bytecode files can be run directly, without using <CODEROUTINE>ocamlrun</CODEROUTINE>.</ITEM>
    </BLIST></ITEM>
    <ITEM><BLIST><TITLE><CODEROUTINE>ocamldebug</CODEROUTINE></TITLE>
        <ITEM>Start the debugger
          <CODESAMPLE><PROMPT/>ocamldebug camlprog.exe</CODESAMPLE>
        </ITEM>
    </BLIST></ITEM>
    <ITEM><BLIST><TITLE><CODEROUTINE>opam</CODEROUTINE></TITLE>
      <ITEM>Initialise the <CODEFILENAME>~/.opam</CODEFILENAME> directory
        <CODESAMPLE><PROMPT/>opam init</CODESAMPLE>
      </ITEM>
      <ITEM>Synchronize opam's database with the package repositories
        <CODESAMPLE><PROMPT/>opam update</CODESAMPLE>
      </ITEM>
      <ITEM>List installed packages
        <CODESAMPLE><PROMPT/>opam list</CODESAMPLE>
      </ITEM>
      <ITEM>List all available packages
        <CODESAMPLE><PROMPT/>opam list -a</CODESAMPLE>
      </ITEM>
      <ITEM>Install the package <CODEROUTINE>&lt;name&gt;</CODEROUTINE>
        <CODESAMPLE><PROMPT/>opam install &lt;name&gt;</CODESAMPLE>
      </ITEM>
      <ITEM>It is possible to constrain the version to install
        <CODESAMPLE><PROMPT/>opam install &lt;name&gt;.&lt;version&gt;</CODESAMPLE>
        <CODESAMPLE><PROMPT/>opam install "&lt;name&gt;&gt;=&lt;version&gt;"</CODESAMPLE>
      </ITEM>
      <ITEM>Upgrade package <CODEROUTINE>&lt;name&gt;</CODEROUTINE>
        <CODESAMPLE><PROMPT/>opam upgrade &lt;name&gt;</CODESAMPLE>
      </ITEM>
      <ITEM>Upgrade all installed package <CODEROUTINE>&lt;name&gt;</CODEROUTINE>
        <CODESAMPLE><PROMPT/>opam upgrade</CODESAMPLE>
      </ITEM>
      <ITEM>Uninstall the package <CODEROUTINE>&lt;name&gt;</CODEROUTINE>
        <CODESAMPLE><PROMPT/>opam remove &lt;name&gt;</CODESAMPLE>
      </ITEM>
      <ITEM>Prints appropriate shell variable assignments to stdout
        <CODESAMPLE><PROMPT/>opam env</CODESAMPLE>
        To be used as
        <CODESAMPLE><PROMPT/>eval $(opam env)</CODESAMPLE>
      </ITEM>
    </BLIST></ITEM>
    <ITEM><BLIST><TITLE><CODEROUTINE>dune</CODEROUTINE></TITLE>
      <ITEM>Initialise the project <CODEROUTINE>&lt;project_name&gt;</CODEROUTINE>
        <CODESAMPLE><PROMPT/>dune init proj &lt;project_name&gt;</CODESAMPLE>
      </ITEM>
      <ITEM>Build the project in the current directory
        <CODESAMPLE><PROMPT/>dune build</CODESAMPLE>
      </ITEM>
      <ITEM>Run the tests of the project in the current directory
        <CODESAMPLE><PROMPT/>dune test</CODESAMPLE>
      </ITEM>
      <ITEM>Run the project
        <CODESAMPLE><PROMPT/>dune exec &lt;project_name&gt;</CODESAMPLE>
      </ITEM>
    </BLIST></ITEM>
  </BLIST></ITEM>
</BLIST>
</CONTENT>
<X><T>links</T><A>../links/ml.html#ocaml</A><L>en</L><F>HTML</F></X>
</PAGE>