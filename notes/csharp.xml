<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="../css/strict.xsl"?>
<PAGE xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../css/schema.xsd">
<TITLE>C#</TITLE>
<PATH>notes/csharp.xml</PATH>
<DATE><YEAR>2016</YEAR><MONTH>12</MONTH><DAY>22</DAY></DATE>
<CONTENT>
<BLIST><TITLE><U><B>Variables</B></U></TITLE>
<ITEM>Putting <CODEROUTINE>@</CODEROUTINE> at the beginning of a variable name, allows to use a keyword.
<CODESAMPLE>void Foo(int @string)</CODESAMPLE></ITEM>
</BLIST>
<BR/>
<BLIST><TITLE><U><B>Implicitly typed variable</B></U></TITLE>
<ITEM>An implicitly typed variable is strongly typed just as if you had declared the type yourself, but the compiler determines the type (i.e. the type of the constant). The following two declarations are equivalent:
<CODESAMPLE>var i = 10; // implicitly typed<BR/>
int i = 10; //explicitly typed</CODESAMPLE></ITEM>
<ITEM><BLIST><TITLE><CODEROUTINE>var</CODEROUTINE> can be used for</TITLE>
<ITEM>local variables</ITEM>
<ITEM>a <CODEROUTINE>for</CODEROUTINE> initialization statement</ITEM>
<ITEM>a <CODEROUTINE>foreach</CODEROUTINE> initialization statement</ITEM>
<ITEM>a <CODEROUTINE>using</CODEROUTINE> statement</ITEM>
</BLIST></ITEM>
<ITEM>Arrays can also be implicitly typed. Jagged arrays are supported, but not multidimensional arrays.
<CODESAMPLE>var a = new[] { 1, 10, 100, 1000 };<BR/>
var d = new[]<BR/>
<TAB/>{<BR/>
<TAB/><TAB/>new[]{"Luca", "Mads", "Luke", "Dinesh"},<BR/>
<TAB/><TAB/>new[]{"Karen", "Suma", "Frances"}<BR/>
<TAB/>};</CODESAMPLE></ITEM>
</BLIST>
<BR/>
<U><B>Anonymous type</B></U><BR/>
Anonymous types provide a convenient way to encapsulate a set of read-only properties into a single object without having to first explicitly define a type. The type name is generated by the compiler and is not available at the source code level.
<CODESAMPLE>var v = new { Amount = 108, Message = "Hello" };</CODESAMPLE>
Anonymous types are class types that consist of one or more public read-only properties. No other kinds of class members such as methods or events are allowed. An anonymous type cannot be cast to any interface or type except for object.<BR/>
<BR/>
<U><B>Const</B></U><BR/>
A constant expression is an expression that can be fully evaluated at compile time. Therefore, the only possible values for constants of reference types are string and null.<BR/>
The constant declaration can declare multiple constants, such as:<BR/>
<CODESAMPLE>public const double x = 1.0, y = 2.0, z = 3.0;</CODESAMPLE>
(The <CODEROUTINE>static</CODEROUTINE> modifier is not allowed in a constant declaration.)<BR/>
<BR/>
<BLIST><TITLE><U><B>Constructors</B></U></TITLE>
<ITEM>Constructors have the same name as the class.</ITEM>
<ITEM>A constructor that takes no parameters is called a default constructor. Default constructors are invoked whenever an object is instantiated using the new operator and no arguments are provided to new.</ITEM>
<ITEM>Unless the class is static, classes without constructors are given a public default constructor by the C# compiler in order to enable class instantiation.</ITEM>
<ITEM>A private constructor is a special instance constructor. It is commonly used in classes that contain static members only. If a class has one or more private constructors and no public constructors, then other classes (except nested classes) are not allowed to create instances of this class. The declaration of the empty constructor prevents the automatic generation of a default constructor.</ITEM>
<ITEM>Constructors for struct types are similar to class constructors, but structs cannot contain an explicit default constructor because one is provided automatically by the compiler. This constructor initializes each field in the struct to their default values. However, this default constructor is only invoked if the struct is instantiated with new.</ITEM>
<ITEM>Both classes and structs can define constructors that take parameters. Constructors that take parameters must be called through a new statement or a <CODEROUTINE>base</CODEROUTINE> statement.</ITEM>
<ITEM>In a derived class, if a base class constructor is not called explicitly using the <CODEROUTINE>base</CODEROUTINE> keyword, then the default constructor, if there is one, is called implicitly. If a base class does not offer a default constructor, the derived class must make an explicit call to a base constructor using <CODEROUTINE>base</CODEROUTINE>.</ITEM>
<ITEM>A constructor can invoke another constructor in the same object using the <CODEROUTINE>this</CODEROUTINE> keyword. Like <CODEROUTINE>base</CODEROUTINE>, <CODEROUTINE>this</CODEROUTINE> can be used with or without parameters, and any parameters in the constructor are available as parameters to <CODEROUTINE>this</CODEROUTINE>, or as part of an expression.
<CODESAMPLE>public Employee(int weeklySalary, int numberOfWeeks)<BR/>
<TAB/>: this(weeklySalary * numberOfWeeks) <BR/>
{<BR/>
}</CODESAMPLE></ITEM>
</BLIST>
<BR/>
<BLIST><TITLE><U><B>Static Constructors</B></U></TITLE>
<ITEM>A constructor can be declared static using the <CODEROUTINE>static</CODEROUTINE> keyword. Static constructors are called automatically, immediately before any static fields are accessed, and are normally used to initialize static class members.
<CODESAMPLE>class SampleClass<BR/>
{<BR/>
<TAB/>static SampleClass()<BR/>
<TAB/>{<BR/>
<TAB/><TAB/>…<BR/>
<TAB/>}<BR/>
}</CODESAMPLE></ITEM>
<ITEM>A static constructor does not take access modifiers or have parameters.</ITEM>
<ITEM>A static constructor is called automatically to initialize the class before the first instance is created or any static members are referenced.</ITEM>
<ITEM>A static constructor cannot be called directly.</ITEM>
<ITEM>The user has no control on when the static constructor is executed in the program.</ITEM>
<ITEM>A typical use of static constructors is when the class is using a log file and the constructor is used to write entries to this file.<BR/>
Static constructors are also useful when creating wrapper classes for unmanaged code, when the constructor can call the LoadLibrary method.</ITEM>
</BLIST>
<BR/>
<BLIST><TITLE><U><B>Destructors</B></U></TITLE>
<ITEM>You cannot call or override the <CODEROUTINE>Object.Finalize</CODEROUTINE> method from the C# or C++ programming languages. C# uses destructors as the mechanism for writing finalization code.</ITEM>
<ITEM>Destructors cannot be defined in structs. They are only used with classes.</ITEM>
<ITEM>A class can only have one destructor.</ITEM>
<ITEM>Destructors cannot be inherited or overloaded.</ITEM>
<ITEM>Destructors cannot be called. They are invoked automatically.</ITEM>
<ITEM>A destructor does not take modifiers or have parameters.</ITEM>
<ITEM>Destructors called recursively for all instances in the inheritance chain, from the most-derived to the least-derived.</ITEM>
<ITEM>Empty destructors should not be used. When a class contains a destructor, an entry is created in the Finalize queue. When the destructor is called, the garbage collector is invoked to process the queue. If the destructor is empty, this just causes a needless loss of performance.</ITEM>
<ITEM>If your application is using an expensive external resource, we also recommend that you provide a way to explicitly release the resource before the garbage collector frees the object. You do this by implementing a Dispose method from the IDisposable interface that performs the necessary cleanup for the object. This can considerably improve the performance of the application. Even with this explicit control over resources, the destructor becomes a safeguard to clean up resources if the call to the Dispose method failed.</ITEM>
</BLIST>
<BR/>
<U><B>Properties</B></U><BR/>
<CODESAMPLE>private string name;<BR/>
public string name {<BR/>
<TAB/>get { return name; }<BR/>
<TAB/>set { name = value;}<BR/>
}</CODESAMPLE>
then
<CODEROUTINE>foobar.name = "AAA"</CODEROUTINE> will call the setter<BR/>
<CODEROUTINE>a = foobar.name</CODEROUTINE> will call the getter<BR/>
<BR/>
<BLIST><TITLE><U><B>Auto-Implemented Properties</B></U></TITLE>
<ITEM>The compiler creates a private, anonymous backing field that can only be accessed through the property's get and set accessors.
<CODESAMPLE>public double Name { get; set; }</CODESAMPLE></ITEM>
<ITEM>For immutable classes, use
<CODESAMPLE>public string Name { get; private set; }<BR/>
public string Address { get; private set; }</CODESAMPLE>
to disable modification on the auto-implemented properties, then use a contructor
<CODESAMPLE>public Contact2(string contactName, string contactAddress)<BR/>
{<BR/>
<TAB/>Name = contactName;<BR/>
<TAB/>Address = contactAddress;<BR/>
}</CODESAMPLE>
or a factory
<CODESAMPLE>private Contact(string contactName, string contactAddress)<BR/>
{<BR/>
<TAB/>Name = contactName;<BR/>
<TAB/>Address = contactAddress;<BR/>
}<BR/>
public static Contact CreateContact(string name, string address)<BR/>
{<BR/>
<TAB/> new Contact(name, address);<BR/>
}</CODESAMPLE>
to instantiate the object</ITEM>
</BLIST>
<BR/>
<BLIST><TITLE><U><B>Object initializer</B></U><BR/></TITLE>
<ITEM>Initialize the properties between curly brackets, separated by a comma
<CODESAMPLE>Cat cat = new Cat { Age = 10, Name = "Fluffy" };</CODESAMPLE></ITEM>
<ITEM>This is particularly useful for anonymous types:
<CODESAMPLE>var productInfos =<BR/>
<TAB/>from p in products<BR/>
<TAB/>select new { p.ProductName, p.UnitPrice };</CODESAMPLE>
Each object in the new anonymous type has two public properties which receive the same names as the properties or fields in the original object. A field when can be renamed:
<CODESAMPLE>select new {p.ProductName, Price = p.UnitPrice};</CODESAMPLE></ITEM>
</BLIST>
<BR/>
<BLIST><TITLE><U><B>Collection Initializers</B></U><BR/></TITLE>
<ITEM>The element initializers can be a simple value, an expression or an object initializer. By using a collection initializer you do not have to specify multiple calls to the Add method of the class in your source code; the compiler adds the calls.
<CODESAMPLE>List&lt;int&gt; digits = new List&lt;int&gt; { 0, 1, 2, 3, 0 + 1, 12 % 3, MakeInt() };</CODESAMPLE></ITEM>
</BLIST>
<BR/>
<U><B>Readonly</B></U><BR/>
The <CODEROUTINE>readonly</CODEROUTINE> keyword is a modifier that you can use on fields: assignments to the fields can only occur as part of the declaration or in a constructor in the same class.<BR/>
The <CODEROUTINE>readonly</CODEROUTINE> keyword is different from the <CODEROUTINE>const</CODEROUTINE> keyword. A <CODEROUTINE>const</CODEROUTINE> field can only be initialized at the declaration of the field. A <CODEROUTINE>readonly</CODEROUTINE> field can be initialized either at the declaration or in a constructor. Therefore, <CODEROUTINE>readonly</CODEROUTINE> fields can have different values depending on the constructor used. Also, while a <CODEROUTINE>const</CODEROUTINE> field is a compile-time constant, the <CODEROUTINE>readonly</CODEROUTINE> field can be used for run-time constants, as in this line:
<CODESAMPLE>public static readonly uint l1 = (uint)DateTime.Now.Ticks;</CODESAMPLE>
<BR/>
<U><B>String literals</B></U><BR/>
<BLIST>
<ITEM>regular string literal: "string"<BR/>
<CODEROUTINE>\</CODEROUTINE> must be followed by one of the following characters: <CODEROUTINE>'</CODEROUTINE>, <CODEROUTINE>"</CODEROUTINE>, <CODEROUTINE>\</CODEROUTINE>, <CODEROUTINE>0</CODEROUTINE>, <CODEROUTINE>a</CODEROUTINE>, <CODEROUTINE>b</CODEROUTINE>, <CODEROUTINE>f</CODEROUTINE>, <CODEROUTINE>n</CODEROUTINE>, <CODEROUTINE>r</CODEROUTINE>, <CODEROUTINE>t</CODEROUTINE>, <CODEROUTINE>u</CODEROUTINE>, <CODEROUTINE>U</CODEROUTINE>, <CODEROUTINE>x</CODEROUTINE>, <CODEROUTINE>v</CODEROUTINE><BR/>
the string literal "\x123" contains a single character with hex value 123. To create a string containing the character with hex value 12 followed by the character 3, you could write "\x00123" or "\x12" + "3" instead.</ITEM>
<ITEM>use the <CODEROUTINE>\u</CODEROUTINE> prefix for Unicode characters, e.g. <CODEROUTINE>f</CODEROUTINE> is <CODEROUTINE>\u0066</CODEROUTINE>.</ITEM>
<ITEM>verbatim string literal: <CODEROUTINE>@"string"</CODEROUTINE><BR/>
all characters are interpreted verbatim, except the quote escape sequence (i.e. <CODEROUTINE>""</CODEROUTINE> to insert a <CODEROUTINE>"</CODEROUTINE>)</ITEM>
</BLIST>
<BR/>
<U><B>Array constants</B></U><BR/>
<BLIST>
<ITEM><CODESAMPLE>int[] entiers = new int[] {0,10,20,30};</CODESAMPLE></ITEM>
<ITEM><CODESAMPLE>double[,] réels = new double[,] { {0.5, 1.7}, {8.4, -6}};</CODESAMPLE></ITEM>
<ITEM><CODESAMPLE>double[,] réels = { {0.5, 1.7}, {8.4, -6}};</CODESAMPLE></ITEM>
</BLIST>
<BR/>
<BLIST><TITLE><U><B>Delegates</B></U></TITLE>
<ITEM>A delegate is a type that defines a method signature. When you instantiate a delegate, you can associate its instance with any method with a compatible signature. You can invoke (or call) the method through the delegate instance. Delegates are used to pass methods as arguments to other methods.</ITEM>
<ITEM><BLIST><TITLE>History</TITLE>
<ITEM><CODESAMPLE>delegate void TestDelegate(string s);</CODESAMPLE></ITEM>
<ITEM>C# 1.0, an instance of a delegate is explicitly initialized with a method that was defined elsewhere in the code.
<CODESAMPLE>static void M(string s)<BR/>
{<BR/>
<TAB/>Console.WriteLine(s);<BR/>
}<BR/>
…<BR/>
TestDelegate testDelA = new TestDelegate(M);</CODESAMPLE>
C# 2.0 allowed the syntax
<CODESAMPLE>TestDelegate testDelA = M;</CODESAMPLE></ITEM>
<ITEM>C# 2.0 introduced anonymous methods as a way to write unnamed inline statement blocks that can be executed in a delegate invocation.
<CODESAMPLE>TestDelegate testDelB = delegate(string s) { Console.WriteLine(s); };</CODESAMPLE></ITEM>
<ITEM>C# 3.0 introduced lambda expressions, which are similar in concept to anonymous methods but more expressive and concise.
<CODESAMPLE>TestDelegate testDelC = (x) =&gt; { Console.WriteLine(x); };</CODESAMPLE></ITEM>
<ITEM>Anonymous methods and lambda expressions are both known as "anonymous functions".</ITEM>
</BLIST></ITEM>
<ITEM>Delegates constructed with a named method can encapsulate either a static method or an instance method.</ITEM>
<ITEM>Delegate types are sealed, they cannot be derived from.</ITEM>
<ITEM>After a delegate is created, the method it is associated with never changes; delegate objects are immutable.</ITEM>
<ITEM>When a delegate is constructed to wrap an instance method, the delegate references both the instance and the method. A delegate has no knowledge of the instance type aside from the method it wraps, so a delegate can refer to any type of object as long as there is a method on that object that matches the delegate signature.</ITEM>
<ITEM><BLIST><TITLE>Multicasting</TITLE>
<ITEM>To add an extra method to the delegate's list of methods - the invocation list - simply requires adding two delegates using the addition or addition assignment operators ('+' or '+=').
<CODESAMPLE>MethodClass obj = new MethodClass();<BR/>
Del d1 = obj.Method1;<BR/>
Del d2 = obj.Method2;<BR/>
Del d3 = DelegateMethod;<BR/>
Del allMethodsDelegate = d1 + d2;<BR/>
allMethodsDelegate += d3;</CODESAMPLE>
The original three delegates, d1, d2, and d3, remain unchanged. When allMethodsDelegate is invoked, all three methods are called in order. If the delegate uses reference parameters, the reference is passed sequentially to each of the three methods in turn, and any changes by one method are visible to the next method. When any of the methods throws an exception that is not caught within the method, that exception is passed to the caller of the delegate and no subsequent methods in the invocation list are called. If the delegate has a return value and/or out parameters, it returns the return value and parameters of the last method invoked.</ITEM>
<ITEM>To remove a method from the invocation list, use the decrement or decrement assignment operator ('-' or '-='). <CODESAMPLE>//remove Method1<BR/>
allMethodsDelegate -= d1;<BR/>
// copy AllMethodsDelegate while removing d2<BR/>
Del oneMethodDelegate = allMethodsDelegate - d2;</CODESAMPLE></ITEM>
<ITEM>Because delegate types are derived from System.Delegate, the methods and properties defined by that class can be called on the delegate. For example, to find the number of methods in a delegate's invocation list:
<CODESAMPLE>int invocationCount = d1.GetInvocationList().GetLength(0);</CODESAMPLE></ITEM>
<ITEM>Delegates with more than one method in their invocation list derive from <CODEROUTINE>System.MulticastDelegate</CODEROUTINE>, which is a subclass of <CODEROUTINE>System.Delegate</CODEROUTINE>.</ITEM>
</BLIST></ITEM>
</BLIST>
<BR/>
<BLIST><TITLE><U><B>Anonymous methods</B></U></TITLE>
<ITEM>There is one case in which an anonymous method provides functionality not found in lambda expressions. Anonymous methods enable you to omit the parameter list. This means that an anonymous method can be converted to delegates with a variety of signatures. This is not possible with lambda expressions.</ITEM>
<ITEM>The local variables and parameters whose scope contains an anonymous method declaration are called outer variables of the anonymous method. For example, in the following code segment, n is an outer variable:
<CODESAMPLE>int n = 0;<BR/>
Del d = delegate() { System.Console.WriteLine("Copy #:{0}", ++n); };</CODESAMPLE>
Unlike local variables, the lifetime of the captured variable extends until the delegates that reference the anonymous methods are eligible for garbage collection. A reference to n is captured at the time the delegate is created.</ITEM>
<ITEM>An anonymous method cannot access the ref or out parameters of an outer scope.</ITEM>
<ITEM>No unsafe code can be accessed within the anonymous-method-block.</ITEM>
<ITEM>Anonymous methods are not allowed on the left side of the <CODEROUTINE>is</CODEROUTINE> operator.</ITEM>
</BLIST>
<BR/>
<BLIST><TITLE><U><B>Lambda expressions</B></U></TITLE>
<ITEM>A lambda expression is an anonymous function that can contain expressions and statements, and can be used to create delegates or expression tree types. All lambda expressions use the lambda operator <CODEROUTINE>=&gt;</CODEROUTINE>, which is read as "goes to". The left side of the lambda operator specifies the input parameters (if any) and the right side holds the expression or statement block.</ITEM>
<ITEM>The <CODEROUTINE>=&gt;</CODEROUTINE> operator has the same precedence as assignment (<CODEROUTINE>=</CODEROUTINE>) and is right-associative.</ITEM>
<ITEM>Lambdas are not allowed on the left side of the <CODEROUTINE>is</CODEROUTINE> or <CODEROUTINE>as</CODEROUTINE> operator.</ITEM>
<ITEM>A lambda expression with an expression on the right side is called an expression lambda.<BR/>
<CODESAMPLE>(input parameters) =&gt; expression</CODESAMPLE>
The parentheses are optional only if the lambda has one input parameter; otherwise they are required. Two or more input parameters are separated by commas enclosed in parentheses:
<CODESAMPLE>(x, y) =&gt; x == y</CODESAMPLE>
Sometimes it is difficult or impossible for the compiler to infer the input types. When this occurs, you can specify the types explicitly as shown in the following example:
<CODESAMPLE>(int x, string s) =&gt; s.Length &gt; x</CODESAMPLE>
Specify zero input parameters with empty parentheses:
<CODESAMPLE>() =&gt; SomeMethod()</CODESAMPLE></ITEM>
<ITEM>A statement lambda resembles an expression lambda except that the statement(s) is enclosed in braces:
<CODESAMPLE>(input parameters) =&gt; {statement;}</CODESAMPLE>
The body of a statement lambda can consist of any number of statements; however, in practice there are typically no more than two or three.<BR/>
Statement lambdas, like anonymous methods, cannot be used to create expression trees.<BR/>
The return value must be with <CODEROUTINE>return</CODEROUTINE>.<BR/>
<CODESAMPLE>(int x, string s) =&gt; s.Length &gt; x</CODESAMPLE> vs <CODESAMPLE>(int x, string s) =&gt; { return (s.Length &gt; x);}</CODESAMPLE></ITEM>
<ITEM>Type Inference in Lambdas<BR/>
When writing lambdas, you often do not have to specify a type for the input parameters because the compiler can infer the type based on the lambda body, the underlying delegate type, and other factors.
<BLIST>
<ITEM>The lambda must contain the same number of parameters as the delegate type.</ITEM>
<ITEM>Each input parameter in the lambda must be implicitly convertible to its corresponding delegate parameter.</ITEM>
<ITEM>The return value of the lambda (if any) must be implicitly convertible to the delegate's return type.</ITEM>
</BLIST></ITEM>
<ITEM>Variable Scope in Lambda Expressions<BR/>
Lambdas can refer to outer variables that are in scope in the enclosing method or type in which the lambda is defined. Variables that are captured in this manner are stored for use in the lambda expression even if variables would otherwise go out of scope and be garbage collected.
<BLIST>
<ITEM>A variable that is captured will not be garbage-collected until the delegate that references it goes out of scope.</ITEM>
<ITEM>Variables introduced within a lambda expression are not visible in the outer method.</ITEM>
<ITEM>A lambda expression cannot directly capture a ref or out parameter from an enclosing method.</ITEM>
<ITEM>A return statement in a lambda expression does not cause the enclosing method to return.</ITEM>
<ITEM>A lambda expression cannot contain a goto statement, break statement, or continue statement whose target is outside the body or in the body of a contained anonymous function.</ITEM>
</BLIST></ITEM>
</BLIST>
<BR/>
<U><B>Nullable Types</B></U><BR/>
Nullable types are instances of the <CODEROUTINE>System.Nullable struct</CODEROUTINE>. A nullable type can represent the normal range of values for its underlying value type, plus an additional null value. For example, a <CODEROUTINE>Nullable&lt;Int32&gt;</CODEROUTINE>, pronounced "Nullable of Int32," can be assigned any value from -2147483648 to 2147483647, or it can be assigned the null value. A <CODEROUTINE>Nullable&lt;bool&gt;</CODEROUTINE> can be assigned the values true or false, or null.<BR/>
Nullable types represent value-type variables that can be assigned the value of null. You cannot create a nullable type based on a reference type. (Reference types already support the null value.)<BR/>
The syntax <CODEROUTINE>T?</CODEROUTINE> is shorthand for <CODEROUTINE>System.Nullable&lt;T&gt;</CODEROUTINE>, where <CODEROUTINE>T</CODEROUTINE> is a value type. The two forms are interchangeable.<BR/>
Use the <CODEROUTINE>System.Nullable.GetValueOrDefault</CODEROUTINE> property to return either the assigned value, or the default value for the underlying type if the value is null.<BR/>
Use the <CODEROUTINE>HasValue</CODEROUTINE> and <CODEROUTINE>Value</CODEROUTINE> read-only properties to test for null and retrieve the value. The <CODEROUTINE>HasValue</CODEROUTINE> property returns true if the variable contains a value, or false if it is null. The <CODEROUTINE>Value</CODEROUTINE> property returns a value if one is assigned, otherwise a <CODEROUTINE>System.InvalidOperationException</CODEROUTINE> is thrown.<BR/>
The default value for a nullable type variable sets <CODEROUTINE>HasValue</CODEROUTINE> to false. The <CODEROUTINE>Value</CODEROUTINE> is undefined.<BR/>
Use the <CODEROUTINE>??</CODEROUTINE> (the null-coalescing operator) operator to assign a default value that will be applied when a nullable type whose current value is null is assigned to a non-nullable type
<CODESAMPLE>int? x = null; int y = x ?? -1;</CODESAMPLE><BR/>
<BR/>
<U><B>Argument by reference</B></U><BR/>
In order to pass argument by reference, use the <CODEROUTINE>ref</CODEROUTINE> or <CODEROUTINE>out</CODEROUTINE> both in the method definition and the method call
<CODESAMPLE>int i=1;<BR/>
setVar(ref i);<BR/>
…<BR/>
public void setVar(ref int a)<BR/>
{<BR/>
<TAB/>a=2;<BR/>
}</CODESAMPLE>
With <CODEROUTINE>ref</CODEROUTINE>, the variable must be initialized before.<BR/>
With <CODEROUTINE>out</CODEROUTINE>, the variable may not be initialized before.<BR/>
<BR/>
<U><B>Access modifiers</B></U><BR/>
<BLIST>
<ITEM><CODEROUTINE>public</CODEROUTINE>
The type or member can be accessed by any other code in the same assembly or another assembly that references it.</ITEM>
<ITEM><CODEROUTINE>private</CODEROUTINE>
The type or member can be accessed only by code in the same class or struct.</ITEM>
<ITEM><CODEROUTINE>protected</CODEROUTINE>
The type or member can be accessed only by code in the same class or struct, or in a class that is derived from that class.</ITEM>
<ITEM><CODEROUTINE>internal</CODEROUTINE>
The type or member can be accessed by any code in the same assembly, but not from another assembly.</ITEM>
<ITEM><CODEROUTINE>protected internal</CODEROUTINE>
The type or member can be accessed by any code in the assembly in which it is declared, or from within a derived class in another assembly. Access from another assembly must take place within a class declaration that derives from the class in which the protected internal element is declared, and it must take place through an instance of the derived class type.</ITEM>
</BLIST>
<BR/>
<U><B>Abstract class and abstract class member</B></U><BR/>
<BLIST>
<ITEM>An abstract class cannot be instantiated. The purpose of an abstract class is to provide a common definition of a base class that multiple derived classes can share.
<CODESAMPLE>public abstract class foo {}</CODESAMPLE></ITEM>
<ITEM>Abstract methods have no implementation, so the method definition is followed by a semicolon instead of a normal method block. Derived classes of the abstract class must implement all abstract methods.
<CODESAMPLE>public abstract class foo<BR/>
{<BR/>
<TAB/>public abstract void DoWork(int i); <BR/>
}</CODESAMPLE></ITEM>
<ITEM>When an abstract class inherits a virtual method from a base class, the abstract class can override the virtual method with an abstract method.
<CODESAMPLE>public class D<BR/>
{<BR/>
<TAB/>public virtual void DoWork(int i)<BR/>
<TAB/>{<BR/>
<TAB/><TAB/>// Original implementation<BR/>
<TAB/>}<BR/>
}<BR/>
<BR/>
public abstract class E : D<BR/>
{<BR/>
<TAB/>public abstract override void DoWork(int i);<BR/>
}<BR/>
<BR/>
public class F : E<BR/>
{<BR/>
<TAB/>public override void DoWork(int i)<BR/>
<TAB/>{<BR/>
<TAB/><TAB/>// New implementation<BR/>
<TAB/>}<BR/>
}</CODESAMPLE>
If a virtual method is declared abstract, it is still virtual to any class inheriting from the abstract class. A class inheriting an abstract method cannot access the original implementation of the method. In the previous example, <CODEROUTINE>DoWork</CODEROUTINE> on class F cannot call <CODEROUTINE>DoWork</CODEROUTINE> on class D. In this way, an abstract class can force derived classes to provide new method implementations for virtual methods.</ITEM>
</BLIST>
<BR/>
<U><B>Sealed class and sealed class member</B></U><BR/>
<BLIST>
<ITEM>When applied to a class, the sealed modifier prevents other classes from inheriting from it.
<CODESAMPLE>public sealed class foo {}</CODESAMPLE></ITEM>
<ITEM>A class member, method, field, property, or event can also be <CODEROUTINE>sealed</CODEROUTINE>. This allows classes to derive from the class while preventing them from overriding specific virtual methods or properties.
<CODESAMPLE>public class foo : bar
{
<TAB/>public sealed override void DoWork() { }
}</CODESAMPLE></ITEM>
</BLIST>
<BR/>
<U><B>Partial class definition</B></U><BR/>
It is possible to split the definition of a class or a struct, or an interface over two or more source files. Each source file contains a section of the class definition, and all parts are combined when the application is compiled.
<CODESAMPLE>public partial class Employee<BR/>
{<BR/>
<TAB/>public void DoWork()<BR/>
<TAB/>{<BR/>
<TAB/>}<BR/>
}<BR/>
<BR/>
public partial class Employee<BR/>
{<BR/>
<TAB/>public void GoToLunch()<BR/>
<TAB/>{<BR/>
<TAB/>}<BR/>
}</CODESAMPLE>
<BR/>
<U><B>Deriving a class</B></U><BR/>
<CODESAMPLE>class TestBase<BR/>
{<BR/>
<TAB/>private String content;<BR/>
<TAB/>public TestBase(string initialValue)<BR/>
<TAB/>{<BR/>
<TAB/><TAB/>this.content = initialValue;<BR/>
<TAB/>}<BR/>
}<BR/>
<BR/>
class TestDerived : TestBase<BR/>
{<BR/>
<TAB/>private int increment;<BR/>
<BR/>
<TAB/>public TestDerived(string initialValue, int increment)<BR/>
<TAB/><TAB/>: base(initialValue)<BR/>
<TAB/>{<BR/>
<TAB/><TAB/>this.increment = increment;<BR/>
<TAB/>}<BR/>
}</CODESAMPLE>
<BR/>
<U><B>Overriding a method</B></U><BR/>
<CODESAMPLE>class TestBase<BR/>
{<BR/>
…<BR/>
public virtual void dump()<BR/>
{<BR/>
…<BR/>
}<BR/>
}<BR/>
<BR/>
class TestDerived<BR/>
{<BR/>
…<BR/>
public override void dump()<BR/>
{<BR/>
…<BR/>
}<BR/>
}</CODESAMPLE>
<BR/>
<U><B>Base</B></U><BR/>
<BLIST><TITLE>The base keyword is used to access members of the base class from within a derived class:</TITLE>
<ITEM>Call a method on the base class that has been overridden by another method.</ITEM>
<ITEM>Specify which base-class constructor should be called when creating instances of the derived class.</ITEM>
</BLIST>
A base class access is permitted only in a constructor, an instance method, or an instance property accessor. It is an error to use the base keyword from within a static method.<BR/>
<BR/>
<U><B>Extension methods</B></U><BR/>
Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.
<CODESAMPLE>namespace ExtensionMethods<BR/>
{<BR/>
<TAB/>public static class MyExtensions<BR/>
<TAB/>{<BR/>
<TAB/><TAB/>public static int WordCount(this String str)<BR/>
<TAB/><TAB/>{<BR/>
<TAB/><TAB/><TAB/>return str.Split(new char[] { ' ', '.', '?' }, StringSplitOptions.RemoveEmptyEntries).Length;<BR/>
<TAB/><TAB/>}<BR/>
<TAB/>}<BR/>
}</CODESAMPLE>
<CODESAMPLE>using ExtensionMethods;<BR/>
…<BR/>
string s = "Hello Extension Methods";<BR/>
int i = s.WordCount();</CODESAMPLE>
<BR/>
<U><B>Variable number of parameters</B></U><BR/>
<CODESAMPLE>static void Main()<BR/>
{<BR/>
<TAB/>MaFonctionVariable("Bonjour");<BR/>
<TAB/>MaFonctionVariable("Bonjour", "Au revoir");<BR/>
}<BR/>
<BR/>
static void MaFonctionVariable(params String[] MesParams)<BR/>
{<BR/>
<TAB/>foreach (String courantString in MesParams)<BR/>
<TAB/><TAB/>Console.WriteLine("Valeur du paramètre : {0}", courantString);<BR/>
}</CODESAMPLE>
In order to use parameters of different types, define the parameter as of type <CODEROUTINE>Object[]</CODEROUTINE>.<BR/>
<BR/>
<U><B>Unsafe code</B></U><BR/>
The <CODEROUTINE>unsafe</CODEROUTINE> keyword denotes an unsafe context, which is required for any operation involving pointers.<BR/>
You can use the unsafe modifier in the declaration of a type, a member, or a code block.<BR/>
<BR/>
<U><B><CODEROUTINE>yield</CODEROUTINE></B></U><BR/>
Used in an iterator block to provide a value to the enumerator object or to signal the end of iteration. It takes one of the following forms:
<CODESAMPLE>yield return &lt;expression&gt;;</CODESAMPLE>
<CODESAMPLE>yield break;</CODESAMPLE>
<BR/>
<U><B><CODEROUTINE>throw</CODEROUTINE></B></U><BR/>
The throw statement is used to signal the occurrence of an anomalous situation (exception) during the program execution. It takes the following form <CODEROUTINE>throw [expression];</CODEROUTINE>, where <CODEROUTINE>expression</CODEROUTINE> is the exception object. This is omitted when rethrowing the current exception object in a catch clause.<BR/>
<BR/>
<U><B>try-catch-finally</B></U><BR/>
A common usage of <CODEROUTINE>catch</CODEROUTINE> and <CODEROUTINE>finally</CODEROUTINE> together is to obtain and use resources in a <CODEROUTINE>try</CODEROUTINE> block, deal with exceptional circumstances in a <CODEROUTINE>catch</CODEROUTINE> block, and release the resources in the <CODEROUTINE>finally</CODEROUTINE> block.
<CODESAMPLE>using System;<BR/>
public class EHClass<BR/>
{<BR/>
<TAB/>public static void Main ()<BR/>
<TAB/>{<BR/>
<TAB/><TAB/>try<BR/>
<TAB/><TAB/>{<BR/>
<TAB/><TAB/><TAB/>Console.WriteLine("Executing the try statement.");<BR/>
<TAB/><TAB/><TAB/>throw new NullReferenceException();<BR/>
<TAB/><TAB/>}<BR/>
<TAB/><TAB/>catch(NullReferenceException e)<BR/>
<TAB/><TAB/>{<BR/>
<TAB/><TAB/><TAB/>Console.WriteLine("{0} Caught exception #1.", e);<BR/>
<TAB/><TAB/>}<BR/>
<TAB/><TAB/>catch<BR/>
<TAB/><TAB/>{<BR/>
<TAB/><TAB/><TAB/>Console.WriteLine("Caught exception #2.");<BR/>
<TAB/><TAB/>}<BR/>
<TAB/><TAB/>finally<BR/>
<TAB/><TAB/>{<BR/>
<TAB/><TAB/><TAB/>Console.WriteLine("Executing finally block.");<BR/>
<TAB/><TAB/>}<BR/>
<TAB/>}<BR/>
}</CODESAMPLE>
<BR/>
<U><B><CODEROUTINE>using</CODEROUTINE></B></U><BR/>
Defines a scope, outside of which an object or objects will be disposed.
<CODESAMPLE>using (Font font = new Font("Arial", 10.0f))<BR/>
{<BR/>
<TAB/>// use font<BR/>
}</CODESAMPLE>
or
<CODESAMPLE>Font font = new Font("Arial", 10.0f);<BR/>
using (font)<BR/>
{<BR/>
<TAB/>// use font<BR/>
}</CODESAMPLE>
Multiple objects can be used in with a using statement, but they must be declared inside the using statement, like this:
<CODESAMPLE>using (Font font3 = new Font("Arial", 10.0f),<BR/>
font4 = new Font("Arial", 10.0f))<BR/>
{<BR/>
<TAB/>// Use font3 and font4.<BR/>
}</CODESAMPLE>
<BR/>
<BLIST><TITLE><U><B>Unit tests</B></U></TITLE>
<ITEM>Attributes
<DEFINITIONTABLE>
<ROW><TERM><CODEROUTINE>TestClassAttribute</CODEROUTINE></TERM><DESC>used to tag a class has containing test methods</DESC></ROW>
<ROW><TERM><CODEROUTINE>TestMethodAttribute</CODEROUTINE></TERM><DESC>used to tag a test method</DESC></ROW>
<ROW><TERM><CODEROUTINE>ExpectedExceptionAttribute</CODEROUTINE></TERM><DESC>used to indicate that a test method expects an exception<BR/>
example: <CODEROUTINE>[ExpectedException(typeof(System.DivideByZeroException))]</CODEROUTINE></DESC></ROW>
<ROW><TERM><CODEROUTINE>OwnerAttribute</CODEROUTINE></TERM><DESC>define the test owner</DESC></ROW>
<ROW><TERM><CODEROUTINE>DescriptionAttribute</CODEROUTINE></TERM><DESC>describe the test</DESC></ROW>
<ROW><TERM><CODEROUTINE>TestPropertyAttribute</CODEROUTINE></TERM><DESC>add a name-value pair</DESC></ROW>
<ROW><TERM><CODEROUTINE>AssemblyInitializeAttribute</CODEROUTINE></TERM><DESC>identify the method to be executed before running all the test of an assembly</DESC></ROW>
<ROW><TERM><CODEROUTINE>AssemblyCleanupAttribute</CODEROUTINE></TERM><DESC>identify the method to be executed after running all the test of an assembly</DESC></ROW>
<ROW><TERM><CODEROUTINE>ClassInitializeAttribute</CODEROUTINE></TERM><DESC>identify the method to be executed before running all the tests of a test class (only one method in a class may be decorated with this attribute)</DESC></ROW>
<ROW><TERM><CODEROUTINE>ClassCleanupAttribute</CODEROUTINE></TERM><DESC>identify the method to be executed before running all the tests of a test class (only one method in a class may be decorated with this attribute)</DESC></ROW>
<ROW><TERM><CODEROUTINE>TestInitializeAttribute</CODEROUTINE></TERM><DESC>identify the method to be executed before running every test of a test class</DESC></ROW>
<ROW><TERM><CODEROUTINE>TestCleanupAttribute</CODEROUTINE></TERM><DESC>identify the method to be executed after running every test of a test class</DESC></ROW>
<ROW><TERM><CODEROUTINE>DataSourceAttribute</CODEROUTINE></TERM><DESC>define the source for test data (e.g. a SQL table)</DESC></ROW>
</DEFINITIONTABLE>
<BR/>
The order of execution is<BR/>
1 Methods marked with the AssemblyInitializeAttribute<BR/>
2 Methods marked with the ClassInitializeAttribute<BR/>
3 Methods marked with the TestInitializeAttribute<BR/>
4 Methods marked with the TestMethodAttribute<BR/>
5 Methods marked with the TestCleanupAttribute<BR/>
6 Methods marked with the ClassCleanupAttribute<BR/>
7 Methods marked with the AssemblyCleanupAttribute<BR/>
</ITEM>
<ITEM>methods of <CODEROUTINE>Assert</CODEROUTINE>
<DEFINITIONTABLE>
<ROW><TERM><CODEROUTINE>Inconclusive()</CODEROUTINE><BR/>
<CODEROUTINE>Inconclusive(String)</CODEROUTINE><BR/>
<CODEROUTINE>Inconclusive(String, Object[])</CODEROUTINE></TERM><DESC>the assertion cannot be verified</DESC></ROW>
<ROW><TERM><CODEROUTINE>AreEqual(Object, Object)</CODEROUTINE><BR/>
<CODEROUTINE>AreEqual&lt;T&gt;(Object, Object)</CODEROUTINE><BR/>
<CODEROUTINE>AreEqual(Object, Object, String)</CODEROUTINE><BR/>
<CODEROUTINE>AreEqual&lt;T&gt;(Object, Object, String)</CODEROUTINE><BR/>
<CODEROUTINE>AreEqual(Object, Object, String, Object[])</CODEROUTINE><BR/>
<CODEROUTINE>AreEqual&lt;T&gt;(Object, Object, String, Object[])</CODEROUTINE></TERM><DESC> verify that two values are equal by using the equality operator</DESC></ROW>
<ROW><TERM><CODEROUTINE>AreEqual(Single, Single, Single)</CODEROUTINE><BR/>
<CODEROUTINE>AreEqual(Single, Single, Single, String)</CODEROUTINE><BR/>
<CODEROUTINE>AreEqual(Single, Single, Single, String, Object[])</CODEROUTINE></TERM><DESC>verify that two specified singles are equal, or within the specified accuracy of each other </DESC></ROW>
<ROW><TERM><CODEROUTINE>AreEqual(Double, Double, Double)</CODEROUTINE><BR/>
<CODEROUTINE>AreEqual(Double, Double, Double, String)</CODEROUTINE><BR/>
<CODEROUTINE>AreEqual(Double, Double, Double, String, Object[])</CODEROUTINE></TERM><DESC>verify that two specified doubles are equal, or within the specified accuracy of each other </DESC></ROW>
<ROW><TERM><CODEROUTINE>IsTrue(Boolean)</CODEROUTINE><BR/>
<CODEROUTINE>IsTrue(Boolean, String)</CODEROUTINE><BR/>
<CODEROUTINE>IsFalse(Boolean, String, Object[])</CODEROUTINE></TERM><DESC>verify that the specified condition is true</DESC></ROW>
<ROW><TERM><CODEROUTINE>IsFalse(Boolean)</CODEROUTINE><BR/>
<CODEROUTINE>IsFalse(Boolean, String)</CODEROUTINE><BR/>
<CODEROUTINE>IsFalse(Boolean, String, Object[])</CODEROUTINE></TERM><DESC>verify that the specified condition is true</DESC></ROW>
<ROW><TERM><CODEROUTINE>IsNull(Object)</CODEROUTINE><BR/>
<CODEROUTINE>IsNull(Object, String)</CODEROUTINE><BR/>
<CODEROUTINE>IsNull(Object, String, Object[])</CODEROUTINE></TERM><DESC>verify that the specified object is null</DESC></ROW>
<ROW><TERM><CODEROUTINE>IsNotNull(Object)</CODEROUTINE><BR/>
<CODEROUTINE>IsNotNull(Object, String)</CODEROUTINE><BR/>
<CODEROUTINE>IsNotNull(Object, String, Object[])</CODEROUTINE></TERM><DESC>verify that the specified object is not null</DESC></ROW>
</DEFINITIONTABLE>
</ITEM>
</BLIST>
<BR/>
<BLIST><TITLE><U><B>Exception</B></U></TITLE>
<ITEM>
<DEFINITIONTABLE>
<ROW><TERM><CODEROUTINE>System.ArgumentException</CODEROUTINE></TERM><DESC>thrown when one of the arguments provided to a method is not valid</DESC></ROW>
<ROW><TERM><CODEROUTINE>System.ArgumentNullException</CODEROUTINE></TERM><DESC>thrown when a null reference is passed to a method that does not accept it as a valid argument</DESC></ROW>
<ROW><TERM><CODEROUTINE>System.NotImplementedException</CODEROUTINE></TERM><DESC>thrown when a requested method or operation is not implemented</DESC></ROW>
</DEFINITIONTABLE>
</ITEM>
</BLIST>
<BR/>
<BLIST><TITLE><U><B>Collections</B></U></TITLE>
<ITEM>
All of them have the following basic methods and properties to manipulate the stored data:
<DEFINITIONTABLE>
<ROW><TERM><CODEROUTINE>Add</CODEROUTINE></TERM><DESC>add a new element</DESC></ROW>
<ROW><TERM><CODEROUTINE>Remove</CODEROUTINE></TERM><DESC>remove an existing element</DESC></ROW>
<ROW><TERM><CODEROUTINE>Count</CODEROUTINE></TERM><DESC>get the total number of elements stored in a collection</DESC></ROW>
</DEFINITIONTABLE>
</ITEM>
<ITEM>Non-Generic Collections<BR/>
Found under the <CODEROUTINE>System.Collections</CODEROUTINE> namespace.
<DEFINITIONTABLE>
<ROW><TERM><CODEROUTINE>ArrayList</CODEROUTINE></TERM><DESC>an array of contiguous indexed elements whose size can be increased dynamically at run time as required</DESC></ROW>
<ROW><TERM><CODEROUTINE>BitArray</CODEROUTINE></TERM><DESC>an array of contiguous bit values (zeros and ones). Its size must be determined at design time</DESC></ROW>
<ROW><TERM><CODEROUTINE>SortedList</CODEROUTINE></TERM><DESC>a list of key/value pair elements, sorted by keys and can be accessed by key and by index</DESC></ROW>
<ROW><TERM><CODEROUTINE>Stack</CODEROUTINE></TERM><DESC>a LIFO data structure</DESC></ROW>
<ROW><TERM><CODEROUTINE>Queue</CODEROUTINE></TERM><DESC>a FIFO data structure</DESC></ROW>
<ROW><TERM><CODEROUTINE>HashTable</CODEROUTINE></TERM><DESC>a collection of key/value pair elements stored based on the hash code of the key</DESC></ROW>
</DEFINITIONTABLE>
</ITEM>
<ITEM>Generic Collections<BR/>
Found under the <CODEROUTINE>System.Collections.Generic</CODEROUTINE> namespace.
<DEFINITIONTABLE>
<ROW><TERM><CODEROUTINE>HashSet</CODEROUTINE></TERM><DESC>a set of values</DESC></ROW>
<ROW><TERM><CODEROUTINE>SortedSet</CODEROUTINE></TERM><DESC>a collection of objects that is maintained in sorted order</DESC></ROW>
<ROW><TERM><CODEROUTINE>LinkedList</CODEROUTINE></TERM><DESC>linked list data structure</DESC></ROW>
<ROW><TERM><CODEROUTINE>Dictionary</CODEROUTINE></TERM><DESC>set of key/value pair elements</DESC></ROW>
<ROW><TERM><CODEROUTINE>List</CODEROUTINE></TERM><DESC>same as ArrayList</DESC></ROW>
<ROW><TERM><CODEROUTINE>Queue</CODEROUTINE></TERM><DESC>same as Queue</DESC></ROW>
<ROW><TERM><CODEROUTINE>Stack</CODEROUTINE></TERM><DESC>same as Stack</DESC></ROW>
</DEFINITIONTABLE>
</ITEM>
</BLIST>
<BR/>
<BLIST><TITLE><U><B>Predefined delegates (member of <CODEROUTINE>System</CODEROUTINE>)</B></U></TITLE>
<ITEM><CODEROUTINE>public delegate TResult Func&lt;out TResult&gt;()</CODEROUTINE></ITEM>
<ITEM><CODEROUTINE>public delegate TResult Func&lt;in T,out TResult&gt;(T arg)</CODEROUTINE></ITEM>
<ITEM><CODEROUTINE>public delegate TResult Func&lt;in T1,in T2,out TResult&gt;(T1 arg1, T2 arg2)</CODEROUTINE></ITEM>
<ITEM>…</ITEM>
<ITEM><CODEROUTINE>public delegate TResult Func&lt;in T1,in T2,in T3,in T4,in T5,in T6,in T7,in T8,in T9,in T10,in T11,in T12,in T13,in T14,in T15,in T16,out TResult&gt;(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16)</CODEROUTINE></ITEM>
<ITEM><CODEROUTINE>public delegate void Action()</CODEROUTINE></ITEM>
<ITEM><CODEROUTINE>public delegate void Action&lt;in T&gt;(T obj)</CODEROUTINE></ITEM>
<ITEM><CODEROUTINE>public delegate void Action&lt;in T1,in T2&gt;(T1 arg1, T2 arg2)</CODEROUTINE></ITEM>
<ITEM>…</ITEM>
<ITEM><CODEROUTINE>public delegate void Action&lt;in T1,in T2,in T3,in T4,in T5,in T6,in T7,in T8,in T9,in T10,in T11,in T12,in T13,in T14,in T15,in T16&gt;(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16)</CODEROUTINE></ITEM>
</BLIST>
<BR/>
<BLIST><TITLE><U><B>Linq</B></U></TITLE>
<ITEM>Enumerable Methods
<DEFINITIONTABLE>
<ROW><TERM><CODEROUTINE>public static bool <X><T>Any</T><A>https://msdn.microsoft.com/en-us/library/bb337697</A><L>fr</L><F>HTML</F></X>&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source)</CODEROUTINE></TERM><DESC>determines whether a sequence contains any elements</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static bool <X><T>Any</T><A>https://msdn.microsoft.com/en-us/library/bb534972</A><L>fr</L><F>HTML</F></X>&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate)</CODEROUTINE></TERM><DESC>determines whether any element of a sequence satisfies a predicate</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static bool <X><T>All</T><A>https://msdn.microsoft.com/en-us/library/bb548541</A><L>fr</L><F>HTML</F></X>&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate)</CODEROUTINE></TERM><DESC>determines whether all elements of a sequence satisfy a predicate</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static TSource <X><T>First</T><A>https://msdn.microsoft.com/en-us/library/bb291976</A><L>fr</L><F>HTML</F></X>&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source)</CODEROUTINE></TERM><DESC>return the first element<BR/>throws <CODEROUTINE>InvalidOperationException</CODEROUTINE> if the Enumerable is empty</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static TSource <X><T>First</T><A>https://msdn.microsoft.com/en-us/library/bb535050</A><L>fr</L><F>HTML</F></X>&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate)</CODEROUTINE></TERM><DESC>return the first element that satisfies a predicate<BR/>throws <CODEROUTINE>InvalidOperationException</CODEROUTINE> if the Enumerable is empty or if no element satisfies the predicate</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static TSource <X><T>FirstOrDefault</T><A>https://msdn.microsoft.com/en-us/library/bb340482</A><L>fr</L><F>HTML</F></X>&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source)</CODEROUTINE></TERM><DESC>return the first element<BR/>returns the default value if the Enumerable is empty</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static TSource <X><T>FirstOrDefault</T><A>https://msdn.microsoft.com/en-us/library/bb549039</A><L>fr</L><F>HTML</F></X>&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate)</CODEROUTINE></TERM><DESC>return the first element that satisfies a predicate<BR/> returns the default value if the Enumerable is empty or if no element satisfies the predicate</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static TSource <X><T>Last</T><A>https://msdn.microsoft.com/en-us/library/bb358775</A><L>fr</L><F>HTML</F></X>&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source)</CODEROUTINE></TERM><DESC>return the last element<BR/>throws <CODEROUTINE>InvalidOperationException</CODEROUTINE> if the Enumerable is empty</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static TSource <X><T>Last</T><A>https://msdn.microsoft.com/en-us/library/bb549138</A><L>fr</L><F>HTML</F></X>&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate)</CODEROUTINE></TERM><DESC>return the last element that satisfies a predicate<BR/>throws <CODEROUTINE>InvalidOperationException</CODEROUTINE> if the Enumerable is empty or if no element satisfies the predicate</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static TSource <X><T>LastOrDefault</T><A>https://msdn.microsoft.com/en-us/library/bb301849</A><L>fr</L><F>HTML</F></X>&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source)</CODEROUTINE></TERM><DESC>return the last element<BR/>returns the default value if the Enumerable is empty</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static TSource <X><T>LastOrDefault</T><A>https://msdn.microsoft.com/en-us/library/bb548915</A><L>fr</L><F>HTML</F></X>&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate)</CODEROUTINE></TERM><DESC>return the last element that satisfies a predicate<BR/> returns the default value if the Enumerable is empty or if no element satisfies the predicate</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static int <X><T>Count</T><A>https://msdn.microsoft.com/en-us/library/bb338038</A><L>fr</L><F>HTML</F></X>&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source)</CODEROUTINE></TERM><DESC>returns the number of elements in a sequence</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static int <X><T>Count</T><A>https://msdn.microsoft.com/en-us/library/bb535181</A><L>fr</L><F>HTML</F></X>&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate)</CODEROUTINE></TERM><DESC>returns a number that represents how many elements in the specified sequence satisfy a predicate</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static IEnumerable&lt;TSource&gt; <X><T>Where</T><A>https://msdn.microsoft.com/en-us/library/bb534803</A><L>fr</L><F>HTML</F></X>&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate)</CODEROUTINE></TERM><DESC>filters a sequence of values based on a predicate</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static IEnumerable&lt;TSource&gt; <X><T>Where</T><A>https://msdn.microsoft.com/en-us/library/bb549418</A><L>fr</L><F>HTML</F></X>&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, int, bool&gt; predicate)</CODEROUTINE></TERM><DESC>filters a sequence of values based on a predicate using the element's index</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static IEnumerable&lt;TResult&gt; <X><T>OfType</T><A>https://msdn.microsoft.com/en-us/library/bb360913</A><L>fr</L><F>HTML</F></X>&lt;TResult&gt;(this IEnumerable source)</CODEROUTINE></TERM><DESC>filters the elements of a sequence based on a specified type</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static IOrderedEnumerable&lt;TSource&gt; <X><T>OrderBy</T><A>https://msdn.microsoft.com/en-us/library/bb534966.aspx</A><L>fr</L><F>HTML</F></X>&lt;TSource, TKey&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector)</CODEROUTINE></TERM><DESC>sorts the elements of a sequence in ascending order according to a key</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static IOrderedEnumerable&lt;TSource&gt; <X><T>OrderBy</T><A>https://msdn.microsoft.com/en-us/library/bb549422.aspx</A><L>fr</L><F>HTML</F></X>&lt;TSource, TKey&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector, IComparer&lt;TKey&gt; comparer)</CODEROUTINE></TERM><DESC>sorts the elements of a sequence in ascending order by using a specified comparer</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static IOrderedEnumerable&lt;TSource&gt; <X><T>OrderByDescending</T><A>https://msdn.microsoft.com/en-us/library/bb534855.aspx</A><L>fr</L><F>HTML</F></X>&lt;TSource, TKey&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector)</CODEROUTINE></TERM><DESC>sorts the elements of a sequence in descending order according to a key</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static IOrderedEnumerable&lt;TSource&gt; <X><T>OrderByDescending</T><A>https://msdn.microsoft.com/en-us/library/bb548916.aspx</A><L>fr</L><F>HTML</F></X>&lt;TSource, TKey&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector, IComparer&lt;TKey&gt; comparer)</CODEROUTINE></TERM><DESC>sorts the elements of a sequence in descending order by using a specified comparer</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static IOrderedEnumerable&lt;TSource&gt; <X><T>ThenBy</T><A>https://msdn.microsoft.com/en-us/library/bb534743.aspx</A><L>fr</L><F>HTML</F></X>&lt;TSource, TKey&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector)</CODEROUTINE></TERM><DESC>performs a subsequent ordering of the elements of a sequence in ascending order according to a key</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static IOrderedEnumerable&lt;TSource&gt; <X><T>ThenBy</T><A>https://msdn.microsoft.com/en-us/library/bb534500.aspx</A><L>fr</L><F>HTML</F></X>&lt;TSource, TKey&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector, IComparer&lt;TKey&gt; comparer)</CODEROUTINE></TERM><DESC> performs a subsequent ordering of the elements of a sequence in ascending order by using a specified comparer</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static IOrderedEnumerable&lt;TSource&gt; <X><T>ThenByDescending</T><A>https://msdn.microsoft.com/en-us/library/bb534736.aspx</A><L>fr</L><F>HTML</F></X>&lt;TSource, TKey&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector)</CODEROUTINE></TERM><DESC> performs a subsequent ordering of the elements of a sequence in descending order according to a key</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static IOrderedEnumerable&lt;TSource&gt; <X><T>ThenByDescending</T><A>https://msdn.microsoft.com/en-us/library/bb534489.aspx</A><L>fr</L><F>HTML</F></X>&lt;TSource, TKey&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector, IComparer&lt;TKey&gt; comparer)</CODEROUTINE></TERM><DESC> performs a subsequent ordering of the elements of a sequence in descending order by using a specified comparer</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static IEnumerable&lt;TResult&gt; <X><T>Select</T><A>https://msdn.microsoft.com/en-us/library/bb548891</A><L>fr</L><F>HTML</F></X>&lt;TSource, Tresult&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TResult&gt; selector)</CODEROUTINE></TERM><DESC>applies a function to each element of the Enumerable and returns the corresponding Enumerable</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static IEnumerable&lt;TResult&gt; <X><T>Select</T><A>https://msdn.microsoft.com/en-us/library/bb534869</A><L>fr</L><F>HTML</F></X>&lt;TSource, TResult&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, int, TResult&gt; selector)</CODEROUTINE></TERM><DESC>applies a function to each element, using its index, of the Enumerable and returns the corresponding Enumerable</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static IEnumerable&lt;TResult&gt; <X><T>SelectMany</T><A>https://msdn.microsoft.com/en-us/library/bb534336</A><L>fr</L><F>HTML</F></X>&lt;TSource, TResult&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, IEnumerable&lt;TResult&gt;&gt; selector)</CODEROUTINE></TERM><DESC>applies a function returning an Enumerable to each element of the Enumerable and return the flatten Enumerable</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static IEnumerable&lt;TResult&gt; <X><T>SelectMany</T><A>https://msdn.microsoft.com/en-us/library/bb549142</A><L>fr</L><F>HTML</F></X>&lt;TSource, TResult&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, int, IEnumerable&lt;TResult&gt;&gt; selector)</CODEROUTINE></TERM><DESC>applies a function returning an Enumerable to each element, using its index, of the Enumerable and return the flatten Enumerable</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static IEnumerable&lt;TResult&gt; <X><T>SelectMany</T><A>https://msdn.microsoft.com/en-us/library/bb534631</A><L>fr</L><F>HTML</F></X>&lt;TSource, TCollection, TResult&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource, TCollection, TResult&gt; resultSelector)</CODEROUTINE></TERM><DESC>applies a function returning an Enumerable to each element of the Enumerable, build the flatten Enumerable, and applies a function on each couple (element of the initial Enumerable, element of that element's Enumerable</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static IEnumerable&lt;TResult&gt; <X><T>SelectMany</T><A>https://msdn.microsoft.com/en-us/library/bb534732</A><L>fr</L><F>HTML</F></X>&lt;TSource, TCollection, TResult&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, int, IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource, TCollection, TResult&gt; resultSelector)</CODEROUTINE></TERM><DESC>applies a function returning an Enumerable to each element, using its index, of the Enumerable, build the flatten Enumerable, and applies a function on each couple (element of the initial Enumerable, element of that element's Enumerable</DESC></ROW>
<ROW><TERM><CODEROUTINE>public static TSource <X><T>Aggregate</T><A>https://msdn.microsoft.com/en-us/library/bb548651</A><L>fr</L><F>HTML</F></X>&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TSource, TSource&gt; func)</CODEROUTINE></TERM><DESC>applies an accumulator function over a sequence<BR/>This method works by calling <CODEROUTINE>func</CODEROUTINE> one time for each element in <CODEROUTINE>source</CODEROUTINE> except the first one. Each time <CODEROUTINE>func</CODEROUTINE> is called, <CODEROUTINE>Aggregate</CODEROUTINE> passes both the element from the sequence and an aggregated value (as the first argument to <CODEROUTINE>func</CODEROUTINE>). The first element of <CODEROUTINE>source</CODEROUTINE> is used as the initial aggregate value. The result of <CODEROUTINE>func</CODEROUTINE> replaces the previous aggregated value. <CODEROUTINE>Aggregate</CODEROUTINE> returns the final result of <CODEROUTINE>func</CODEROUTINE>.</DESC></ROW>
</DEFINITIONTABLE>
</ITEM>
</BLIST>
<BR/>
<BLIST><TITLE><U><B>Code contracs</B></U></TITLE>
<ITEM><CODEROUTINE>PureAttribute</CODEROUTINE> indicates that a method is pure.
</ITEM>
</BLIST>
<BR/>
<BLIST><TITLE><U><B><CODEROUTINE>checked</CODEROUTINE>/<CODEROUTINE>unchecked</CODEROUTINE></B></U></TITLE>
<ITEM><CODEROUTINE>unchecked</CODEROUTINE> suppresses overflow-checking for integral-type arithmetic operations and conversions.
<CODESAMPLE>try<BR/>
{<BR/>
<TAB/>z = checked((short)(x + y));<BR/>
}<BR/>
catch (System.OverflowException e) <BR/>
{<BR/>
<TAB/>Console.WriteLine(e.ToString());<BR/>
}</CODESAMPLE>
</ITEM>
<ITEM><CODEROUTINE>checked</CODEROUTINE> explicitly enables overflow-checking for integral-type arithmetic operations and conversions.
<CODESAMPLE>unchecked<BR/>
{<BR/>
<TAB/>z = x * y;<BR/>
}</CODESAMPLE>
</ITEM>
<ITEM>If neither <CODEROUTINE>checked</CODEROUTINE> nor <CODEROUTINE>unchecked</CODEROUTINE> is specified, the default context depends on external factors such as compiler options.</ITEM>
</BLIST>
<BR/>
</CONTENT>
<X><T>links</T><A>../links/csharp.html</A><L>en</L><F>HTML</F></X>
<X><T>Visual Studio</T><A>../notes/visualstudio.html</A><L>en</L><F>HTML</F></X>
</PAGE>