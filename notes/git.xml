<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="../css/strict.xsl"?>
<PAGE xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../css/schema.xsd">
<TITLE>Git</TITLE>
<PATH>notes/git.xml</PATH>
<DATE><YEAR>2021</YEAR><MONTH>3</MONTH><DAY>21</DAY></DATE>
<CONTENT>
<BLIST><TITLE>Places</TITLE>
<ITEM>stash</ITEM>
<ITEM>workspace</ITEM>
<ITEM>index</ITEM>
<ITEM>local repository</ITEM>
<ITEM>upstream repository</ITEM>
</BLIST>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git --version</CODEROUTINE></TERM>
    <DESC>Print the version of Git.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git init</CODEROUTINE></TERM>
    <DESC>Create an empty local repository.</DESC>
  </ROW>
  <ROW>
    <TERM><CODESAMPLE>mkdir projet.git<BR/>cd projet.git<BR/>git --bare init</CODESAMPLE></TERM>
    <DESC>Create an empty server repository.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git clone &lt;bare repository directory&gt;</CODEROUTINE></TERM>
    <DESC>Create a repository which is the clone of a bare repository.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clone &lt;bare repository directory&gt; &lt;my directory name&gt;</CODEROUTINE></TERM>
    <DESC>Create a repository with name &lt;my directory name&gt; which is the clone of a bare repository (if &lt;my directory name&gt; is not specified, the name of the remote repository is used).</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clone --bare &lt;path to directory containing .git&gt;</CODEROUTINE></TERM>
    <DESC>Create a bare repository which is the clone of a repository.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clone --single-branch</CODEROUTINE></TERM>
    <DESC>Clone only the history leading to the tip of a single branch, either specified by the <CODEROUTINE>--branch</CODEROUTINE> option or the primary branch remote’s HEAD points at.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clone --depth &lt;depth&gt;</CODEROUTINE></TERM>
    <DESC>Create a shallow clone with a history truncated to the specified number of commits. Imply <CODEROUTINE>--single-branch</CODEROUTINE> unless <CODEROUTINE>--no-single-branch</CODEROUTINE> is given to fetch the histories near the tips of all branches.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git remote</CODEROUTINE></TERM>
    <DESC>List the upsteam and downstream repositories.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git remote -v</CODEROUTINE></TERM>
    <DESC>The same more verbose and with remote URL after name.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git remote add &lt;remotename&gt; &lt;url&gt;</CODEROUTINE></TERM>
    <DESC>Add a remote named &lt;remotename&gt; for the repository at &lt;url&gt;.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git config --get remote.origin.url</CODEROUTINE></TERM>
    <DESC>Display the URL the local repository has been cloned from.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git remote -v rm origin</CODEROUTINE></TERM>
    <DESC>Remove the tracking of the remote "origin".</DESC>
  </ROW>
</DEFINITIONTABLE>
<BLIST>
  <ITEM>Workaround to clone a repository which is too big to be transfered.
    <CODESAMPLE>git clone quux@foobar.com:myprojet<BR/>
      git fetch --depth 100</CODESAMPLE>
    Later on, when high bandwidth is available, get the whole repo with
    <CODESAMPLE>git fetch --unshallow</CODESAMPLE>
  </ITEM>
</BLIST>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git ls-files</CODEROUTINE></TERM>
    <DESC>List files which are in the workspace or in the index.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git ls-files -m</CODEROUTINE></TERM>
    <DESC>List modified files.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git ls-files -o</CODEROUTINE></TERM>
    <DESC>List files which are in the workspace and not in the index.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git add &lt;file&gt;</CODEROUTINE></TERM>
    <DESC>update &lt;file&gt; in the index using the current content found in the working tree</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git add .</CODEROUTINE></TERM>
    <DESC>update the content of the current directory in the index</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git stage</CODEROUTINE></TERM>
    <DESC><CODEROUTINE>git stage</CODEROUTINE> is a synonym of <CODEROUTINE>git add</CODEROUTINE></DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git rm &lt;file&gt;</CODEROUTINE></TERM>
    <DESC>remove &lt;file&gt; from the index, or from the working tree and the index</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git commit -m &lt;msg&gt;</CODEROUTINE></TERM>
    <DESC>store the current contents of the index in a new commit along with message &lt;msg&gt;</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git commit -a</CODEROUTINE></TERM>
    <DESC>automatically stage files that have been modified and deleted, but new files you have not told Git about are not affected</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git commit --amend</CODEROUTINE></TERM>
    <DESC>replace the tip of the current branch by creating a new commit</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git commit --amend -m "an updated commit message"</CODEROUTINE></TERM>
    <DESC>change the commit message</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git commit --amend --reset-author</CODEROUTINE></TERM>
    <DESC>declare that the authorship of the new commit belongs to the committer</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git commit --amend --author="John &lt;John@foo.bar&gt;"</CODEROUTINE></TERM>
    <DESC>declare that the authorship of the new commit belongs to the specified name/email.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git diff</CODEROUTINE></TERM>
    <DESC>display the differences between the workspace and the index</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git diff --cached</CODEROUTINE></TERM>
    <DESC>display the differences between the index and the local repository</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git diff --name-only</CODEROUTINE></TERM>
    <DESC>display only the filenames</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git diff &lt;commit 1&gt; &lt;commit 2&lt; &lt;file&lt;</CODEROUTINE></TERM>
    <DESC>compare two revisions of a file</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git diff &lt;commit 1&gt;:&lt;file 1&gt; &lt;commit 2&gt;:&lt;file 2&gt;</CODEROUTINE></TERM>
    <DESC>compare two different files in two different revisions</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git status</CODEROUTINE></TERM>
    <DESC>
      <BLIST><TITLE>Display</TITLE>
        <ITEM>paths that have differences between the index file and the current HEAD commit</ITEM>
        <ITEM>paths that have differences between the working tree and the index file, and</ITEM>
        <ITEM>paths in the working tree that are not tracked by Git</ITEM>
      </BLIST>
    </DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git stash</CODEROUTINE><BR/><CODEROUTINE>git stash push</CODEROUTINE></TERM>
    <DESC>Save local modifications away and revert the working directory to match the HEAD commit (in the working tree and in the index).</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git stash push --message &lt;message&gt;</CODEROUTINE><BR/><CODEROUTINE>git stash push -m &lt;message&gt;</CODEROUTINE></TERM>
    <DESC>Attach a description to the stashed state.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git stash push --keep-index</CODEROUTINE></TERM>
    <DESC>All changes already added to the index are left intact.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git stash push [--include-untracked|--all]</CODEROUTINE><BR/>
      <CODEROUTINE>git stash -u</CODEROUTINE><BR/><CODEROUTINE>git stash -a</CODEROUTINE></TERM>
    <DESC><CODEROUTINE>--include-untracked</CODEROUTINE>, <CODEROUTINE>-u</CODEROUTINE>: all untracked files are also stashed and then cleaned up with <CODEROUTINE>git clean</CODEROUTINE><BR/><CODEROUTINE>--all</CODEROUTINE>, <CODEROUTINE>-a</CODEROUTINE>: the ignored files are stashed and cleaned in addition to the untracked files.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git stash list</CODEROUTINE></TERM>
    <DESC>List the stashed entries.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git stash apply [&lt;stash&gt;]</CODEROUTINE></TERM>
    <DESC>Restore the entry &lt;stash&gt; (the last one if &lt;stash&gt; is not present).</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git stash apply --index [&lt;stash&gt;]</CODEROUTINE></TERM>
    <DESC>Try to reinstate not only the working tree’s changes, but also the index’s ones.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git stash drop [&lt;stash&gt;]</CODEROUTINE></TERM>
    <DESC>Remove the stash entry &lt;stash&gt; (the last one if &lt;stash&gt; is not present).</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git stash pop [--index] [&lt;stash&gt;]</CODEROUTINE></TERM>
    <DESC>Apply and remove the stash entry &lt;stash&gt; (the last one if &lt;stash&gt; is not present).</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git stash branch &lt;branchname&gt; [&lt;stash&gt;]</CODEROUTINE></TERM>
    <DESC>Create and check out a new branch &lt;branchname&gt; starting from the commit at which &lt;stash&gt; was created, apply the changes recorded in &lt;stash&gt; to the new working tree and index.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git stash clear</CODEROUTINE></TERM>
    <DESC>Remove all stash entries.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git log</CODEROUTINE></TERM>
    <DESC>Show commit logs.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --full-history</CODEROUTINE></TERM>
    <DESC>Do not prune some history as the default mode (useful to see the merges).</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>--</CODEROUTINE></TERM>
    <DESC>Separate paths from revisions.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --full-history -- myfile</CODEROUTINE></TERM>
    <DESC>Display the log of a file even if this one does not exist anymore.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log -&lt;n&gt;</CODEROUTINE></TERM>
    <DESC>Limit the log to the n last commits.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --since "2020-09-05 00:00" --until "2020-09-06 24:00"</CODEROUTINE></TERM>
    <DESC>Limit the log between two datetimes.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --committer=&lt;regex&gt;</CODEROUTINE></TERM>
    <DESC>Filter on a given committer (if there are several <CODEROUTINE>--committer</CODEROUTINE> flags, return commits of committers matching any of the regexps).</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --author=&lt;regex&gt;</CODEROUTINE></TERM>
    <DESC>Filter on a given author (if there are several <CODEROUTINE>--author</CODEROUTINE> flags, return commits of authors matching any of the regexps).</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --pretty="%cI %s"</CODEROUTINE></TERM>
    <DESC>Show the commit date and the commit subject.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --pretty="%ce,%cd" --date=short > commits.csv</CODEROUTINE></TERM>
    <DESC>Dump the authors and dates of the commits in a file.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --stat</CODEROUTINE></TERM>
    <DESC>Indicate the modified files with a graph of the stats of the changes.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --shortstat</CODEROUTINE></TERM>
    <DESC>Indicate the numbers of modified files, added and deleted lines.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log -p</CODEROUTINE><BR/>
          <CODEROUTINE>git log --patch</CODEROUTINE></TERM>
    <DESC>Show the code changes in each commit.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log -U&lt;n&gt;</CODEROUTINE><BR/>
          <CODEROUTINE>git log --unified=&lt;n&gt;</CODEROUTINE></TERM>
    <DESC>Generate diffs with n lines of context instead of the usual 3. Implies <CODEROUTINE>-p</CODEROUTINE>.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git whatchanged</CODEROUTINE></TERM>
    <DESC>List the last commits: hash, author, date, and list of impacted files.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git show &lt;commit&gt;</CODEROUTINE></TERM>
    <DESC>show the log message and textual diff</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git show &lt;commit&gt;:&lt;file&gt;</CODEROUTINE></TERM>
    <DESC>display a given version of a file</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git reset &lt;commit&gt;</CODEROUTINE></TERM>
    <DESC>reset current HEAD to a previous commit<BR/>if no commit is specified, the current HEAD is used</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git reset --soft</CODEROUTINE></TERM>
    <DESC>do not touch the index file or the working tree</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git reset --mixed</CODEROUTINE></TERM>
    <DESC>reset the index but not the working tree<BR/>this is the default</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git reset --hard</CODEROUTINE></TERM>
    <DESC>reset the index and the working tree</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git reset --hard HEAD~2</CODEROUTINE></TERM>
    <DESC>delete the last two commits from the local repository</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git blame &lt;file&gt;</CODEROUTINE></TERM>
    <DESC>annotate each line of the file with information from the revision which last modified the line</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git blame -M</CODEROUTINE></TERM>
    <DESC>detects moved or copied lines within a file</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git blame -w</CODEROUTINE></TERM>
    <DESC>ignores whitespaces</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git fetch</CODEROUTINE></TERM>
    <DESC>download objects and refs from upstream repository into local repository.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git fetch --depth=&lt;depth&gt;</CODEROUTINE></TERM>
    <DESC>limit fetching to the specified number of commits from the tip of each remote branch history<BR/>
      tags for the deepened commits are not fetched</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git fetch --deepen=&lt;depth&gt;</CODEROUTINE></TERM>
    <DESC>similar to <CODEROUTINE>--depth</CODEROUTINE>, except it specifies the number of commits from the current shallow boundary instead of from the tip of each remote branch history</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git fetch --unshallow</CODEROUTINE></TERM>
    <DESC>If the source repository is complete, convert a shallow repository to a complete one, removing all the limitations imposed by shallow repositories.<BR/>
      If the source repository is shallow, fetch as much as possible so that the current repository has the same history as the source repository.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git pull</CODEROUTINE></TERM>
    <DESC>
      <BLIST><SUBTITLE>incorporate changes of the remote repository into the current branch, it is the same as</SUBTITLE>
        <ITEM><CODEROUTINE>git fetch</CODEROUTINE> scoped to the local branch that HEAD is pointed at</ITEM>
        <ITEM>followed by <CODEROUTINE>git merge FETCH_HEAD</CODEROUTINE>.</ITEM>
      </BLIST>
    </DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git pull --rebase</CODEROUTINE></TERM>
    <DESC>perform a rebase instead of a merge</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git push &lt;remotename&gt; &lt;branchname&gt;</CODEROUTINE></TERM>
    <DESC>push commits made on a local branch to a remote repository in the branch of same name.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>-u</CODEROUTINE><BR/><CODEROUTINE>--set-upstream</CODEROUTINE></TERM>
    <DESC>for every branch that is up to date or successfully pushed, add upstream (tracking) reference</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/><DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git clean -d</CODEROUTINE></TERM>
    <DESC>recurse into untracked directories</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clean -f</CODEROUTINE><BR/>
      <CODEROUTINE>git clean --force</CODEROUTINE></TERM>
    <DESC>perform the deletion if the Git configuration variable <CODEROUTINE>clean.requireForce</CODEROUTINE> is not set to <CODEROUTINE>false</CODEROUTINE><BR/>
      untracked nested git repositories (directories with a <CODEROUTINE>.git</CODEROUTINE> subdirectory) are ignored unless a second <CODEROUTINE>-f</CODEROUTINE> is given</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clean -i</CODEROUTINE><BR/>
      <CODEROUTINE>git clean --interactive</CODEROUTINE></TERM>
    <DESC>show what would be done and clean files interactively</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clean -n</CODEROUTINE><BR/>
      <CODEROUTINE>git clean --dry-run</CODEROUTINE></TERM>
    <DESC>does not remove anything, list the files and directories that would be removed</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git branch &lt;new branch&gt;</CODEROUTINE></TERM>
    <DESC>create a new branch</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git branch</CODEROUTINE></TERM>
    <DESC>list the branches, the current one is prefixed with <CODEROUTINE>*</CODEROUTINE></DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git checkout &lt;branch&gt;</CODEROUTINE></TERM>
    <DESC>switch to another branch</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git merge &lt;branch&gt;</CODEROUTINE></TERM>
    <DESC>merge a branch in the workspace</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git mergetool</CODEROUTINE></TERM>
    <DESC>perform merge conflict resolution with a tool</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git mergetool --tool-help</CODEROUTINE></TERM>
    <DESC>list the supported merge tools, indicating which ones are available</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git gc</CODEROUTINE></TERM>
    <DESC>compress file revision and remove uneachable objects</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git config --global --list</CODEROUTINE></TERM>
    <DESC>display the global configuration</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git config --global --edit</CODEROUTINE></TERM>
    <DESC>open an editor to edit the global configuration file</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git config --global user.name "John Doe"</CODEROUTINE></TERM>
    <DESC>set the name in the global configuration file</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git config --global user.email johndoe@example.com</CODEROUTINE></TERM>
    <DESC>set the email in the global configuration file</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git config --system user.email johndoe@example.com</CODEROUTINE></TERM>
    <DESC>set the email in the system-wide configuration file</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git config user.name "John Doe"</CODEROUTINE><BR/>
      <CODEROUTINE>git config user.name "John Doe"</CODEROUTINE></TERM>
    <DESC>set the name in the local repository configuration file</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<BLIST><TITLE><CODEFILENAME>.gitignore</CODEFILENAME></TITLE>
  <ITEM>It is possible to ignore files/directories in a given directory by listing them in the <CODEFILENAME>.gitignore</CODEFILENAME> file of that directory.</ITEM>
</BLIST>
<BR/>
<BLIST><TITLE>Changing the author of old commits</TITLE>
  <ITEM><CODEROUTINE>git rebase -i &lt;commit&gt;</CODEROUTINE> where &lt;commit&gt; is the commit before the first one to be edited. Use <CODEROUTINE>git rebase -i --root</CODEROUTINE> if the first commit must be edited.</ITEM>
  <ITEM>In the list of commits, change <CODEROUTINE>pick</CODEROUTINE> to <CODEROUTINE>edit</CODEROUTINE> for the commits to be edited.</ITEM>
  <ITEM>When the interactive rebase pauses, <CODEROUTINE>git commit --amend --author="Author Name &lt;email@address.com&gt;"</CODEROUTINE>, then <CODEROUTINE>git rebase --continue</CODEROUTINE>.</ITEM>
  <ITEM><CODEROUTINE>git push -f</CODEROUTINE>.</ITEM>
</BLIST>
</CONTENT>
<X><T>links</T><A>../links/coding.html#git</A><L>en</L><F>HTML</F></X>
</PAGE>