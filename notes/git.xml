<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="../css/strict.xsl"?>
<PAGE xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../css/schema.xsd" xml:lang="en">
<TITLE>Git</TITLE>
<PATH>notes/git.xml</PATH>
<DATE><YEAR>2023</YEAR><MONTH>9</MONTH><DAY>13</DAY></DATE>
<CONTENT>
<BLIST><TITLE>Places</TITLE>
<ITEM>stash</ITEM>
<ITEM>workspace</ITEM>
<ITEM>index</ITEM>
<ITEM>local repository</ITEM>
<ITEM>upstream repository</ITEM>
</BLIST>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git --version</CODEROUTINE></TERM>
    <DESC>Print the version of Git.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE><X><T>git init</T><A>https://git-scm.com/docs/git-init</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>Create an empty local repository.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git init -q</CODEROUTINE><BR/>
      <CODEROUTINE>git init --quiet</CODEROUTINE></TERM>
    <DESC>Only print error and warning messages; all other output will be suppressed.</DESC>
  </ROW>
  <ROW>
    <TERM><CODESAMPLE>mkdir projet.git<BR/>
      cd projet.git<BR/>
      git --bare init</CODESAMPLE></TERM>
    <DESC>Create an empty server repository.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE><X><T>git clone</T><A>https://git-scm.com/docs/git-clone</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>Clone a repository into a new directory.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clone &lt;bare repository directory&gt;</CODEROUTINE></TERM>
    <DESC>Create a repository which is the clone of a bare repository.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clone &lt;bare repository directory&gt; &lt;my directory name&gt;</CODEROUTINE></TERM>
    <DESC>Create a repository with name &lt;my directory name&gt; which is the clone of a bare repository (if &lt;my directory name&gt; is not specified, the name of the remote repository is used).</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clone --bare &lt;path to directory containing .git&gt;</CODEROUTINE></TERM>
    <DESC>Create a bare repository which is the clone of a repository.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clone --single-branch</CODEROUTINE></TERM>
    <DESC>Clone only the history leading to the tip of a single branch, either specified by the <CODEROUTINE>--branch</CODEROUTINE> option or the primary branch remote’s HEAD points at.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clone --depth &lt;depth&gt;</CODEROUTINE></TERM>
    <DESC>Create a shallow clone with a history truncated to the specified number of commits. Imply <CODEROUTINE>--single-branch</CODEROUTINE> unless <CODEROUTINE>--no-single-branch</CODEROUTINE> is given to fetch the histories near the tips of all branches.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clone --recurse-submodules</CODEROUTINE></TERM>
    <DESC>Clone all submodules.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clone --quiet</CODEROUTINE><BR/>
      <CODEROUTINE>git clone -q</CODEROUTINE></TERM>
    <DESC>Progress is not reported to the standard error stream.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clone --verbose</CODEROUTINE><BR/>
      <CODEROUTINE>git clone -v</CODEROUTINE></TERM>
    <DESC>Run verbosely, but progress is reported as usual on stderr.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clone --config &lt;key&gt;=&lt;value&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git clone -c &lt;key&gt;=&lt;value&gt;</CODEROUTINE></TERM>
    <DESC>Set a configuration variable in the created repository, after the repository is initialised, before the remote history is fetched or any files checked out.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE><X><T>git remote</T><A>https://git-scm.com/docs/git-remote</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>List the upstream and downstream repositories.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git remote -v</CODEROUTINE></TERM>
    <DESC>The same more verbose and with remote URL after name.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git remote add &lt;remotename&gt; &lt;url&gt;</CODEROUTINE></TERM>
    <DESC>Add a remote named &lt;remotename&gt; for the repository at &lt;url&gt;.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git remote remove &lt;remotename&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git remote rm &lt;remotename&gt;</CODEROUTINE></TERM>
    <DESC>Remove the remote named &lt;remotename&gt;. All remote-tracking branches and configuration settings for the remote are removed.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git config --get remote.origin.url</CODEROUTINE></TERM>
    <DESC>Display the URL the local repository has been cloned from.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git remote -v rm origin</CODEROUTINE></TERM>
    <DESC>Remove the tracking of the remote "origin".</DESC>
  </ROW>
</DEFINITIONTABLE>
<BLIST>
  <ITEM>Workaround to clone a repository which is too big to be transferred (shallow clone).
    <CODESAMPLE>git clone --depth 5 https://gitlab.com/foo/bar.git</CODESAMPLE>
    Later on, when high bandwidth is available, get the whole repo with
    <CODESAMPLE>git fetch --unshallow</CODESAMPLE>
  </ITEM>
  <ITEM>Clone a directory with file paths/names too long for Windows.
    <CODESAMPLE>git clone -c core.longpaths=true https://gitlab.com/foo/bar.git</CODESAMPLE>
  </ITEM>
  <ITEM>On Windows, the Windows Credential Manager (Gestionnaire d'identification) is used by default (see <CODEROUTINE>git config --system --get credential.helper</CODEROUTINE>).</ITEM>
  <ITEM>To be able to use Git in a directory owned by someone else (this was implemented to fix <X><T>CVE-2022-24765</T><A>https://www.cve.org/CVERecord?id=CVE-2022-24765</A><L>en</L><F>HTML</F></X>)
    <CODESAMPLE>git config --global --add safe.directory H:/the/directory</CODESAMPLE>
    To list all the directories declared as safe
    <CODESAMPLE>git config --get-all --global safe.directory</CODESAMPLE>
  </ITEM>
</BLIST>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE><X><T>git ls-files</T><A>https://git-scm.com/docs/git-ls-files</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>List files which are in the workspace or in the index.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git ls-files -m</CODEROUTINE></TERM>
    <DESC>List modified files.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git ls-files -o</CODEROUTINE></TERM>
    <DESC>List files which are in the workspace and not in the index.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git add &lt;file&gt;</CODEROUTINE></TERM>
    <DESC>Update &lt;file&gt; in the index using the current content found in the working tree.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git add .</CODEROUTINE></TERM>
    <DESC>Update the content of the current directory in the index.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git add -i</CODEROUTINE><BR/>
      <CODEROUTINE>git add --interactive</CODEROUTINE></TERM>
    <DESC>Add modified contents in the working tree interactively to the index.<BR/>
      Optional path arguments may be supplied to limit operation to a subset of the working tree</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE><X><T>git stage</T><A>https://git-scm.com/docs/git-stage</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC><CODEROUTINE>git stage</CODEROUTINE> is a synonym of <CODEROUTINE>git add</CODEROUTINE>.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git rm &lt;file&gt;</CODEROUTINE></TERM>
    <DESC>Remove &lt;file&gt; from the index, or from the working tree and the index.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE><X><T>git status</T><A>https://git-scm.com/docs/git-status</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC><BLIST><TITLE>Display</TITLE>
        <ITEM>paths that have differences between the index file and the current HEAD commit</ITEM>
        <ITEM>paths that have differences between the working tree and the index file, and</ITEM>
        <ITEM>paths in the working tree that are not tracked by Git</ITEM>
      </BLIST></DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git commit -m &lt;msg&gt;</CODEROUTINE></TERM>
    <DESC>Store the current contents of the index in a new commit along with message &lt;msg&gt;.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git commit -a</CODEROUTINE><BR/>
      <CODEROUTINE>git commit --all</CODEROUTINE></TERM>
    <DESC>Automatically stage files that have been modified and deleted, but new files you have not told Git about are not affected.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git commit -o</CODEROUTINE><BR/>
      <CODEROUTINE>git commit --only</CODEROUTINE></TERM>
    <DESC>Make a commit by taking the updated working tree contents of the paths specified on the command line, disregarding any contents that have been staged for other paths.
      (This is the default of <CODEROUTINE>git commit</CODEROUTINE> if any paths are given on the command line. So, in this case the <CODEROUTINE>-o</CODEROUTINE> is useless.)</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git commit --amend</CODEROUTINE></TERM>
    <DESC>Replace the tip of the current branch by creating a new commit.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git commit --amend --no-edit</CODEROUTINE></TERM>
    <DESC>Amend a commit without changing its commit message.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git commit --amend -m "an updated commit message"</CODEROUTINE></TERM>
    <DESC>Change the commit message.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git commit --amend --reset-author</CODEROUTINE></TERM>
    <DESC>Declare that the authorship of the new commit belongs to the committer.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git commit --amend --author="John &lt;John@foo.bar&gt;"</CODEROUTINE></TERM>
    <DESC>Declare that the authorship of the new commit belongs to the specified name/email.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE><X><T>git diff</T><A>https://git-scm.com/docs/git-diff</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>Display the differences between the workspace and the index.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git diff --cached</CODEROUTINE></TERM>
    <DESC>Display the differences between the index and the local repository.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git diff origin/main</CODEROUTINE></TERM>
    <DESC>Display the differences between the work space and the <CODEROUTINE>main</CODEROUTINE> branch on the upstream repository.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git diff --name-only</CODEROUTINE></TERM>
    <DESC>Display only the filenames.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git diff &lt;commit 1&gt; &lt;commit 2&gt; &lt;file&gt;</CODEROUTINE></TERM>
    <DESC>Compare two revisions of a file.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git diff &lt;branch 1&gt; &lt;branch 2&gt; -- &lt;file&gt;</CODEROUTINE></TERM>
    <DESC>Compare two versions of a file in different branches, <BR/>
      <CODEROUTINE>git diff master remotes/origin/hisbranch -- pom.xml</CODEROUTINE></DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git diff &lt;branch&gt; -- &lt;file&gt;</CODEROUTINE></TERM>
    <DESC>Compare the current version of a file with one in a different branch.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git diff &lt;commit 1&gt;:&lt;file 1&gt; &lt;commit 2&gt;:&lt;file 2&gt;</CODEROUTINE></TERM>
    <DESC>Compare two different files in two different revisions.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE><X><T>git apply</T><A>https://git-scm.com/docs/git-apply</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>Apply a patch.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE><X><T>git log</T><A>https://git-scm.com/docs/git-log</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>Show commit logs.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --all</CODEROUTINE></TERM>
    <DESC>Pretend as if all the refs in <CODEROUTINE>refs/</CODEROUTINE>, along with <CODEROUTINE>HEAD</CODEROUTINE>, are listed on the command line as &lt;commit&gt;.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --full-history</CODEROUTINE></TERM>
    <DESC>Do not prune some history as the default mode (useful to see the merges).</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>--</CODEROUTINE></TERM>
    <DESC>Separate paths from revisions.<BR/>
    <CODEROUTINE>git log -- **/*.md</CODEROUTINE> will show logs of commits impacting the Python files.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>-L&lt;start&gt;,&lt;end&gt;:&lt;file&gt;</CODEROUTINE><BR/>
          <CODEROUTINE>-L:&lt;funcname&gt;:&lt;file&gt;</CODEROUTINE></TERM>
    <DESC>Show the code changes for a part of a file.<BR/>
      <CODEROUTINE>&lt;start&gt;</CODEROUTINE> and <CODEROUTINE>&lt;end&gt;</CODEROUTINE> are numbers or regexps.<BR/>
      <CODEROUTINE>&lt;end&gt;</CODEROUTINE> can be defined as an offset.<BR/>
      <CODEROUTINE>&lt;funcname&gt;</CODEROUTINE> is a regexp.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --full-history</CODEROUTINE></TERM>
    <DESC>Does not prune some history.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --full-history --simplify-merges</CODEROUTINE></TERM>
    <DESC>Same as <CODEROUTINE>--full-history</CODEROUTINE> but remove some needless merges.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --full-history -- &lt;myfile&gt;</CODEROUTINE></TERM>
    <DESC>Display the log of a file even if this one does not exist anymore.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log -&lt;n&gt;</CODEROUTINE></TERM>
    <DESC>Limit the log to the n last commits.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --since "2020-09-05 00:00" --until "2020-09-06 24:00"</CODEROUTINE></TERM>
    <DESC>Limit the log between two datetimes.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --committer=&lt;regex&gt;</CODEROUTINE></TERM>
    <DESC>Filter on a given committer (if there are several <CODEROUTINE>--committer</CODEROUTINE> flags, return commits of committers matching any of the regexps).</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --author=&lt;regex&gt;</CODEROUTINE></TERM>
    <DESC>Filter on a given author (if there are several <CODEROUTINE>--author</CODEROUTINE> flags, return commits of authors matching any of the regexps).</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --grep=&lt;regexp&gt;</CODEROUTINE></TERM>
    <DESC>Filter the commits to the ones with log message that matches the specified pattern (regular expression).<BR/>
      With more than one <CODEROUTINE>--grep=&lt;regexp&gt;</CODEROUTINE>, commits whose message matches any of the given patterns are chosen.<BR/>
      With more than one <CODEROUTINE>--grep=&lt;regexp&gt;</CODEROUTINE> and <CODEROUTINE>---all-match</CODEROUTINE>, limit the commits output to ones that match all given regular expressions.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>--invert-grep</CODEROUTINE></TERM>
    <DESC>Limit the commits output to ones with log message that do not match.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>-i</CODEROUTINE><BR/>
      <CODEROUTINE>--regexp-ignore-case</CODEROUTINE></TERM>
    <DESC>Match the regular expression limiting patterns without regard to letter case.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>--basic-regexp</CODEROUTINE></TERM>
    <DESC>Consider the limiting patterns to be basic regular expressions; this is the default.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>-E</CODEROUTINE><BR/>
      <CODEROUTINE>--extended-regexp</CODEROUTINE></TERM>
    <DESC>Consider the limiting patterns to be extended regular expressions instead of the default basic regular expressions</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>-F</CODEROUTINE><BR/>
      <CODEROUTINE>--fixed-strings</CODEROUTINE></TERM>
    <DESC>Consider the limiting patterns to be fixed strings.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>-P</CODEROUTINE><BR/>
      <CODEROUTINE>--perl-regexp</CODEROUTINE></TERM>
    <DESC>Consider the limiting patterns to be Perl-compatible regular expressions.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log -S&lt;string&gt;</CODEROUTINE></TERM>
    <DESC>Look for differences that change the number of occurrences of the specified string.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log -S&lt;string&gt; --pickaxe-regex</CODEROUTINE></TERM>
    <DESC>Treat &lt;string&gt; as a regular expression.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log -G&lt;regexp&gt;</CODEROUTINE></TERM>
    <DESC>Look for differences whose patch text contains added/removed lines that match the specified regular expression.<BR/>
      (Use <CODEROUTINE>git log -G&lt;regexp&gt; -p</CODEROUTINE> to display all the matching changes.<BR/>
      Use <CODEROUTINE>git log -G&lt;regexp&gt; --all</CODEROUTINE> to look in all branches.)</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>--pickaxe-all</CODEROUTINE></TERM>
    <DESC>When <CODEROUTINE>-S</CODEROUTINE> or -<CODEROUTINE>-G</CODEROUTINE> finds a change, show all the changes in that changeset, not just the files that contain the string/regexp.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --pretty=&lt;format&gt;</CODEROUTINE></TERM>
    <DESC>Show more and more information.
      <BLIST>
        <ITEM>oneline</ITEM>
        <ITEM>short</ITEM>
        <ITEM>medium</ITEM>
        <ITEM>full</ITEM>
        <ITEM>fuller</ITEM>
      </BLIST></DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --pretty="%cI %s"</CODEROUTINE></TERM>
    <DESC>Show the commit date and the commit subject.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --pretty="%ce,%cd" --date=short &gt; commits.csv</CODEROUTINE></TERM>
    <DESC>Dump the authors and dates of the commits in a file.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --name-only</CODEROUTINE></TERM>
    <DESC>Show only names of changed files.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --name-status</CODEROUTINE></TERM>
    <DESC>Show only names and status of changed files.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --abbrev-commit</CODEROUTINE></TERM>
    <DESC>SInstead of showing the full 40-byte hexadecimal commit object name, show a prefix that names the object uniquely.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --oneline</CODEROUTINE></TERM>
    <DESC>Shorthand for <CODEROUTINE>--pretty=oneline --abbrev-commit</CODEROUTINE>.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log decorate</CODEROUTINE><BR/>
      <CODEROUTINE>git log decorate=short</CODEROUTINE></TERM>
    <DESC>Print out the ref names of any commits that are shown. The ref name prefixes <CODEROUTINE>refs/heads/</CODEROUTINE>, <CODEROUTINE>refs/tags/</CODEROUTINE>, and <CODEROUTINE>refs/remotes/</CODEROUTINE> are not printed.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log decorate=long</CODEROUTINE></TERM>
    <DESC>Print out the full ref names of any commits that are shown.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log decorate=auto</CODEROUTINE></TERM>
    <DESC>If the output is going to a terminal, the ref names are shown as if <CODEROUTINE>short</CODEROUTINE> was given, otherwise no ref names are shown.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --stat</CODEROUTINE></TERM>
    <DESC>Indicate the modified files with a graph of the stats of the changes.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --shortstat</CODEROUTINE></TERM>
    <DESC>Indicate the numbers of modified files, added and deleted lines.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log -p</CODEROUTINE><BR/>
          <CODEROUTINE>git log --patch</CODEROUTINE></TERM>
    <DESC>Show the code changes in each commit.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log -U&lt;n&gt;</CODEROUTINE><BR/>
          <CODEROUTINE>git log --unified=&lt;n&gt;</CODEROUTINE></TERM>
    <DESC>Generate diffs with n lines of context instead of the usual 3. Implies <CODEROUTINE>-p</CODEROUTINE>.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git log --graph</CODEROUTINE></TERM>
    <DESC>Draw a text-based graphical representation.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE><X><T>git whatchanged</T><A>https://git-scm.com/docs/git-whatchanged</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>List the last commits: hash, author, date, and list of impacted files.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE><X><T>git shortlog</T><A>https://git-scm.com/docs/git-shortlog</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>Summarize <CODEROUTINE>git log</CODEROUTINE> output.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git shortlog -n</CODEROUTINE><BR/>
          <CODEROUTINE>git shortlog --numbered</CODEROUTINE></TERM>
    <DESC>Sort output according to the number of commits per author instead of author alphabetic order.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git shortlog -s</CODEROUTINE><BR/>
          <CODEROUTINE>git shortlog --summary</CODEROUTINE></TERM>
    <DESC>Suppress commit description and provide a commit count summary only.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git shortlog -e</CODEROUTINE><BR/>
          <CODEROUTINE>git shortlog --email</CODEROUTINE></TERM>
    <DESC>Show the email address of each author.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git shortlog -nse</CODEROUTINE></TERM>
    <DESC>List of authors with their amails sorted by number of commits.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git show &lt;commit&gt;</CODEROUTINE></TERM>
    <DESC>Show the log message and textual diff</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git show --name-only &lt;commit&gt;</CODEROUTINE></TERM>
    <DESC>Show the log message and the name of the modified files</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git show --name-status &lt;commit&gt;</CODEROUTINE></TERM>
    <DESC>Show the log message and the name and status of the modified files</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git show &lt;commit&gt;:&lt;file&gt;</CODEROUTINE></TERM>
    <DESC>Display a given version of a file</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git blame &lt;file&gt;</CODEROUTINE></TERM>
    <DESC>Annotate each line of the file with information from the revision which last modified the line</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git blame -M</CODEROUTINE></TERM>
    <DESC>Detect moved or copied lines within a file</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git blame -w</CODEROUTINE></TERM>
    <DESC>Ignore whitespaces</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git blame -f</CODEROUTINE><BR/>
      <CODEROUTINE>git blame --show-name</CODEROUTINE></TERM>
    <DESC>Show the filename in the original commit (by default the filename is shown if there is any line that came from a file with a different name, due to rename detection)</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git blame --date=format:%Y%d</CODEROUTINE></TERM>
    <DESC>Define a format for the dates</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git blame --show-email</CODEROUTINE></TERM>
    <DESC>Show the author email instead of author name</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git blame -l</CODEROUTINE></TERM>
    <DESC>indicate all (40) characters of the revision</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git annotate &lt;file&gt;</CODEROUTINE></TERM>
    <DESC>Same feature as <CODEROUTINE>git blame</CODEROUTINE> but the output is slightly different.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git stash</CODEROUTINE><BR/><CODEROUTINE>git stash push</CODEROUTINE></TERM>
    <DESC>Save local modifications away and revert the working directory to match the HEAD commit (in the working tree and in the index).</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git stash push --message &lt;message&gt;</CODEROUTINE><BR/><CODEROUTINE>git stash push -m &lt;message&gt;</CODEROUTINE></TERM>
    <DESC>Attach a description to the stashed state.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git stash push --keep-index</CODEROUTINE></TERM>
    <DESC>All changes already added to the index are left intact.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git stash push [--include-untracked|--all]</CODEROUTINE><BR/>
      <CODEROUTINE>git stash -u</CODEROUTINE><BR/><CODEROUTINE>git stash -a</CODEROUTINE></TERM>
    <DESC><CODEROUTINE>--include-untracked</CODEROUTINE>, <CODEROUTINE>-u</CODEROUTINE>: all untracked files are also stashed and then cleaned up with <CODEROUTINE>git clean</CODEROUTINE><BR/>
      <CODEROUTINE>--all</CODEROUTINE>, <CODEROUTINE>-a</CODEROUTINE>: the ignored files are stashed and cleaned in addition to the untracked files.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git stash push -u foo.txt bar.txt new.txt</CODEROUTINE></TERM>
    <DESC>Stash a list of modified and new files.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git stash list</CODEROUTINE></TERM>
    <DESC>List the stashed entries.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git stash apply [&lt;stash&gt;]</CODEROUTINE></TERM>
    <DESC>Restore the entry &lt;stash&gt; (the last one if &lt;stash&gt; is not present).</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git stash apply --index [&lt;stash&gt;]</CODEROUTINE></TERM>
    <DESC>Try to reinstate not only the working tree’s changes, but also the index’s ones.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git stash drop [&lt;stash&gt;]</CODEROUTINE></TERM>
    <DESC>Remove the stash entry &lt;stash&gt; (the last one if &lt;stash&gt; is not present).</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git stash pop [--index] [&lt;stash&gt;]</CODEROUTINE></TERM>
    <DESC>Apply and remove the stash entry &lt;stash&gt; (the last one if &lt;stash&gt; is not present).</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git stash branch &lt;branchname&gt; [&lt;stash&gt;]</CODEROUTINE></TERM>
    <DESC>Create and check out a new branch &lt;branchname&gt; starting from the commit at which &lt;stash&gt; was created, apply the changes recorded in &lt;stash&gt; to the new working tree and index.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git stash clear</CODEROUTINE></TERM>
    <DESC>Remove all stash entries.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git worktree add &lt;path&gt; &lt;branchname&gt;</CODEROUTINE></TERM>
    <DESC>Create a worktree in directory &lt;path&gt; for branch &lt;branchname&gt;.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git worktree list</CODEROUTINE></TERM>
    <DESC>List details of each working tree. The main working tree is listed first.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git worktree remove &lt;worktree&gt;</CODEROUTINE></TERM>
    <DESC>Remove a worktree. The main working tree cannot be removed.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE><X><T>git clean</T><A>https://git-scm.com/docs/git-clean</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>Remove untracked files from the working tree</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clean -i</CODEROUTINE><BR/>
      <CODEROUTINE>git clean --interactive</CODEROUTINE></TERM>
    <DESC>Show what would be done and clean files interactively.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clean -f</CODEROUTINE><BR/>
      <CODEROUTINE>git clean --force</CODEROUTINE></TERM>
    <DESC>Clean file with no interaction.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clean -d</CODEROUTINE></TERM>
    <DESC>Recurse into untracked directories.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clean -e &lt;pattern&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git clean --exclude=&lt;pattern&gt;</CODEROUTINE></TERM>
    <DESC>Use the given exclude pattern in addition to the standard ignore rules.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clean -x</CODEROUTINE></TERM>
    <DESC>Don’t use the standard ignore rules, but still use the ignore rules given with <CODEROUTINE>-e</CODEROUTINE> options from the command line. This allows removing all untracked files, including build products</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clean -X</CODEROUTINE></TERM>
    <DESC>Remove only files ignored by Git. This may be useful to rebuild everything from scratch, but keep manually created files.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git reset &lt;commit&gt;</CODEROUTINE></TERM>
    <DESC>Reset the index entries for all paths to a previous commit<BR/>
      If no commit is specified, the current HEAD is used.<BR/>
      The local changes are not lost.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git reset HEAD~</CODEROUTINE></TERM>
    <DESC>Cancel the last commit</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git reset &lt;commit&gt; &lt;pathspec&gt;</CODEROUTINE></TERM>
    <DESC>Reset the index &lt;pathspec&gt; entry to a previous commit<BR/>
      if no commit is specified, the current HEAD is used.<BR/>
      This means that <CODEROUTINE>git reset &lt;pathspec&gt;</CODEROUTINE> is the opposite of <CODEROUTINE>git add &lt;pathspec&gt;</CODEROUTINE>.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git reset --soft &lt;commit&gt;</CODEROUTINE></TERM>
    <DESC>Do not touch the index file or the working tree. Only resets the head to &lt;commit&gt;, just like all modes do.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git reset --mixed &lt;commit&gt;</CODEROUTINE></TERM>
    <DESC>Reset the index but not the working tree<BR/>
      this is the default.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git reset --hard &lt;commit&gt;</CODEROUTINE></TERM>
    <DESC>Reset the index and the working tree.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git reset --hard HEAD~2</CODEROUTINE></TERM>
    <DESC>Delete the last two commits from the local repository.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git restore &lt;file&gt;</CODEROUTINE></TERM>
    <DESC>Replace &lt;file&gt; in the working tree by its version in HEAD.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git restore --source &lt;commit&gt; &lt;file&gt;</CODEROUTINE></TERM>
    <DESC>Replace &lt;file&gt; in the working tree by its version in commit &lt;commit&gt;.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git revert &lt;commit1&gt; &lt;commit2&gt; …</CODEROUTINE></TERM>
    <DESC>Revert some commits (a revert is a staged commit reverting a given past commit). If we indicate several commits on the command line, there will be one revert per indicated commit.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE><X><T>git fetch</T><A>https://git-scm.com/docs/git-fetch</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>Download objects and refs from another repository.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git fetch</CODEROUTINE></TERM>
    <DESC>Download objects and refs from upstream repository into local repository.<BR/>
      The names of refs that are fetched, together with the object names they point at, are written to <CODEFILENAME>.git/FETCH_HEAD</CODEFILENAME>.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git fetch --all</CODEROUTINE></TERM>
    <DESC>Fetch all remotes.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git fetch --append</CODEROUTINE><BR/>
      <CODEROUTINE>git fetch -a</CODEROUTINE></TERM>
    <DESC>Append ref names and object names of fetched refs to the existing contents of <CODEFILENAME>.git/FETCH_HEAD</CODEFILENAME>. Without this option old data in <CODEFILENAME>.git/FETCH_HEAD</CODEFILENAME> will be overwritten.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git fetch --depth=&lt;depth&gt;</CODEROUTINE></TERM>
    <DESC>Limit fetching to the specified number of commits from the tip of each remote branch history.<BR/>
      Tags for the deepened commits are not fetched.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git fetch --deepen=&lt;depth&gt;</CODEROUTINE></TERM>
    <DESC>Similar to <CODEROUTINE>--depth</CODEROUTINE>, except it specifies the number of commits from the current shallow boundary instead of from the tip of each remote branch history.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git fetch --unshallow</CODEROUTINE></TERM>
    <DESC>If the source repository is complete, convert a shallow repository to a complete one, removing all the limitations imposed by shallow repositories.<BR/>
      If the source repository is shallow, fetch as much as possible so that the current repository has the same history as the source repository.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git fetch origin dev:dev</CODEROUTINE></TERM>
    <DESC>Update the <CODEROUTINE>dev</CODEROUTINE> branch to be the head of the remote <CODEROUTINE>dev</CODEROUTINE> branch.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE><X><T>git pull</T><A>https://git-scm.com/docs/git-pull</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>Fetch from and integrate with another repository or a local branch.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git pull</CODEROUTINE></TERM>
    <DESC><BLIST><SUBTITLE>Incorporate changes of the remote repository into the current branch, it is the same as</SUBTITLE>
        <ITEM><CODEROUTINE>git fetch</CODEROUTINE> scoped to the local branch that HEAD is pointed at</ITEM>
        <ITEM>followed by <CODEROUTINE>git merge FETCH_HEAD</CODEROUTINE>.</ITEM>
      </BLIST></DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git pull --rebase</CODEROUTINE></TERM>
    <DESC>Perform a rebase instead of a merge.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE><X><T>git push</T><A>https://git-scm.com/docs/git-push</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>Update remote refs along with associated objects.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git push &lt;remotename&gt; &lt;branchname&gt;</CODEROUTINE></TERM>
    <DESC>Push commits made on a local branch to a remote repository in the branch of same name.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git push https://username:password@mygithost.com/file.git</CODEROUTINE></TERM>
    <DESC>Specify the credentials on the command line.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git push --all</CODEROUTINE></TERM>
    <DESC>Push all branches.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git push -u origin &lt;branchname&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git push --set-upstream origin &lt;branchname&gt;</CODEROUTINE></TERM>
    <DESC>For every branch that is up to date or successfully pushed, add upstream (tracking) reference.<BR/>
      This is to be used when a branch has been created locally and does not exist in the remote repository.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git push --force</CODEROUTINE><BR/>
      <CODEROUTINE>git push -f</CODEROUTINE></TERM>
    <DESC>Do not check that the remote ref is an ancestor of the local ref</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git push --force-with-lease</CODEROUTINE></TERM>
    <DESC>Only allow to force-push if no-one else has pushed changes up to the remote in the interim</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git push --mirror</CODEROUTINE></TERM>
    <DESC>All refs under <CODEROUTINE>refs/</CODEROUTINE> (which includes but is not limited to <CODEROUTINE>refs/heads/</CODEROUTINE>, <CODEROUTINE>refs/remotes/</CODEROUTINE>, and <CODEROUTINE>refs/tags/)</CODEROUTINE> are mirrored to the remote repository. Newly created local refs are pushed to the remote end, locally updated refs are force updated on the remote end, and deleted refs are removed from the remote end.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git push --dry-run</CODEROUTINE><BR/>
      <CODEROUTINE>git push -n</CODEROUTINE></TERM>
    <DESC>Do everything except actually send the updates.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/><DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE><X><T>git clean</T><A>https://git-scm.com/docs/git-clean</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>Delete untracked files from the working tree.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clean -d</CODEROUTINE></TERM>
    <DESC>Recurse into untracked directories.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clean -e &lt;pattern&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git clean --exclude=&lt;pattern&gt;</CODEROUTINE></TERM>
    <DESC>Exclude the files/directories matching &lt;pattern&gt;.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clean -x</CODEROUTINE></TERM>
    <DESC>Also remove the files/directories which are ignored by Git (but still use the ignore rules given with <CODEROUTINE>-e</CODEROUTINE> options).</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clean -X</CODEROUTINE></TERM>
    <DESC>Only remove the files/directories which are ignored by Git.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clean -f</CODEROUTINE><BR/>
      <CODEROUTINE>git clean --force</CODEROUTINE></TERM>
    <DESC>Perform the deletion if the Git configuration variable <CODEROUTINE>clean.requireForce</CODEROUTINE> is not set to <CODEROUTINE>false</CODEROUTINE>.<BR/>
      Untracked nested git repositories (directories with a <CODEROUTINE>.git</CODEROUTINE> subdirectory) are ignored unless a second <CODEROUTINE>-f</CODEROUTINE> is given.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clean -i</CODEROUTINE><BR/>
      <CODEROUTINE>git clean --interactive</CODEROUTINE></TERM>
    <DESC>Show what would be done and clean files interactively.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git clean -n</CODEROUTINE><BR/>
      <CODEROUTINE>git clean --dry-run</CODEROUTINE></TERM>
    <DESC>Does not remove anything, list the files and directories that would be removed.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE><X><T>git branch</T><A>https://git-scm.com/docs/git-branch</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>List, create, or delete branches.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git branch &lt;new branch&gt;</CODEROUTINE></TERM>
    <DESC>Create a new branch (but does not switch to it).</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git branch</CODEROUTINE><BR/>
      <CODEROUTINE>git branch -l</CODEROUTINE><BR/>
      <CODEROUTINE>git branch --list</CODEROUTINE></TERM>
    <DESC>List the local branches, the current one is prefixed with <CODEROUTINE>*</CODEROUTINE>.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git branch -v</CODEROUTINE><BR/>
      <CODEROUTINE>git branch --verbose</CODEROUTINE></TERM>
    <DESC>List the local branches, indicating sha1 and commit subject line for each head, and relationship to upstream branch (if any)</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git branch -vv</CODEROUTINE></TERM>
    <DESC>The same with path of the linked worktree (if any) and the name of the upstream branch</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git branch -a</CODEROUTINE><BR/>
      <CODEROUTINE>git branch --all</CODEROUTINE></TERM>
    <DESC>List the local and remote branches.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git branch --contains &lt;commit&gt;</CODEROUTINE></TERM>
    <DESC>Only list branches which contain the specified commit.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git branch --no-contains &lt;commit&gt;</CODEROUTINE></TERM>
    <DESC>Only list branches which do not contain the specified commit.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git branch -m &lt;new name&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git branch --move &lt;new name&gt;</CODEROUTINE></TERM>
    <DESC>Rename the current branch, with its config and reflog.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git branch -m &lt;new name&gt; -f</CODEROUTINE><BR/>
      <CODEROUTINE>git branch --move &lt;new name&gt; --force</CODEROUTINE><BR/>
      <CODEROUTINE>git branch -M &lt;new name&gt;</CODEROUTINE></TERM>
    <DESC>Rename the current branch, with its config and reflog, even if a branch &lt;new name&gt; already exists.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git branch -c &lt;name&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git branch --copy &lt;name&gt;</CODEROUTINE></TERM>
    <DESC>Copy the current branch, with its config and reflog.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git branch -c &lt;name&gt; -f</CODEROUTINE><BR/>
      <CODEROUTINE>git branch --copy &lt;name&gt; --force</CODEROUTINE><BR/>
      <CODEROUTINE>git branch -C &lt;name&gt;</CODEROUTINE></TERM>
    <DESC>Copy the current branch, with its config and reflog, even if a branch &lt;name&gt; already exists.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE><X><T>git switch</T><A>https://git-scm.com/docs/git-switch</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>Switch branches.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE><X><T>git checkout</T><A>https://git-scm.com/docs/git-checkout</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>Switch branches or restore working tree files.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git switch &lt;branch&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git checkout &lt;branch&gt;</CODEROUTINE></TERM>
    <DESC>Switch to another branch.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git switch -</CODEROUTINE><BR/>
      <CODEROUTINE>git checkout -</CODEROUTINE></TERM>
    <DESC>Switch back to the previous branch.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git switch -c &lt;branch&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git switch --create &lt;branch&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git checkout -b &lt;branch&gt;</CODEROUTINE></TERM>
    <DESC>Create a new branch (while leaving the working tree unchanged) and check it out.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git switch -C &lt;branch&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git switch --force-create &lt;branch&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git checkout -B &lt;branch&gt;</CODEROUTINE></TERM>
    <DESC>The same except that if &lt;branch&gt; already exists, it is reset to the current head.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git switch -c &lt;branch&gt; &lt;starting point&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git switch --create &lt;branch&gt; &lt;starting point&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git checkout -b &lt;branch&gt; &lt;starting point&gt;</CODEROUTINE></TERM>
    <DESC>Create a new branch from a starting point and check it out.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git switch -C &lt;branch&gt; &lt;starting point&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git switch --force-create &lt;branch&gt; &lt;starting point&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git checkout -B &lt;branch&gt; &lt;starting point&gt;</CODEROUTINE></TERM>
    <DESC>The same except that if &lt;branch&gt; already exists, it is reset to &lt;starting point&gt;.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git branch -d &lt;branch&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git branch --delete &lt;branch&gt;</CODEROUTINE></TERM>
    <DESC>Delete a local branch. The branch must be fully merged in its upstream branch.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git branch -d -f &lt;branch&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git branch --delete --force &lt;branch&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git branch -D &lt;branch&gt;</CODEROUTINE></TERM>
    <DESC>Delete a local branch even if it has not been merged.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git push origin --delete &lt;branch&gt;</CODEROUTINE></TERM>
    <DESC>Delete a branch in the remote repository.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git merge &lt;branch&gt;</CODEROUTINE></TERM>
    <DESC>Merge a branch in the workspace.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git merge &lt;branch&gt; --no-commit --no-ff</CODEROUTINE></TERM>
    <DESC>Merge a branch in the workspace without committing.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git merge --abort</CODEROUTINE></TERM>
    <DESC>Cancel the current ongoing merge (if there was a conflict or with the <CODEROUTINE>--no-commit</CODEROUTINE> flag).</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git merge --squash</CODEROUTINE></TERM>
    <DESC>Update the working tree and index by merging the branch, but the commit is not performed (the commit will have to be done later). This can be used to merge one or several branches in a single commit.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git merge -s ours</CODEROUTINE><BR/>
      <CODEROUTINE>git merge --strategy=ours</CODEROUTINE></TERM>
    <DESC>Create a merge that keeps the current branch head (i.e. it ignores all the changes done on the other branches).</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git merge --allow-unrelated-histories</CODEROUTINE></TERM>
    <DESC>Allow merging histories of two projects that started their lives independently.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git cherry-pick &lt;commit&gt;</CODEROUTINE></TERM>
    <DESC>Cherry pick a commit and commit it.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git cherry-pick &lt;commit&gt; -m 1</CODEROUTINE><BR/>
      <CODEROUTINE>git cherry-pick &lt;commit&gt; --mainline 1</CODEROUTINE></TERM>
    <DESC>Use to cherry pick a merge commit, <CODEROUTINE>-m 1</CODEROUTINE> indicates to replay the change relative to the first parent.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git cherry-pick &lt;commit&gt; -n</CODEROUTINE><BR/>
      <CODEROUTINE>git cherry-pick &lt;commit&gt; --no-commit</CODEROUTINE></TERM>
    <DESC>Cherry pick a commit, but does not commit it.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE><X><T>git mergetool</T><A>https://git-scm.com/docs/git-mergetool</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>Run merge conflict resolution tools to resolve merge conflicts.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git mergetool</CODEROUTINE></TERM>
    <DESC>Perform merge conflict resolution with a tool.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git mergetool --tool-help</CODEROUTINE></TERM>
    <DESC>List the supported merge tools, indicating which ones are available.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git checkout --patch &lt;commit&gt; .</CODEROUTINE></TERM>
    <DESC>Does not change the current branch.<BR/>
      Bring and manually accept the files of &lt;commit&gt; in the index.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE><X><T>git tag</T><A>https://git-scm.com/docs/git-tag</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>Create, list, delete or verify a tag object signed with GPG.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git tag</CODEROUTINE><BR/>
      <CODEROUTINE>git tag -l</CODEROUTINE><BR/>
      <CODEROUTINE>git tag --list</CODEROUTINE></TERM>
    <DESC>List the existing tags.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git tag -l &lt;wildcard&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git tag --list &lt;wildcard&gt;</CODEROUTINE></TERM>
    <DESC>List the existing tags matching a wildcard, e.g.:<BR/>
      <CODEROUTINE>git tag --list "*.RELEASE"</CODEROUTINE></DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git tag --contains &lt;commit&gt;</CODEROUTINE></TERM>
    <DESC>Only list tags which contain the specified commit.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git tag --no-contains &lt;commit&gt;</CODEROUTINE></TERM>
    <DESC>Only list tags which do not contain the specified commit.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git tag -a &lt;tagname&gt; -m &lt;tagcomment&gt;</CODEROUTINE></TERM>
    <DESC>Create an annotated tag.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git tag &lt;tagname&gt;</CODEROUTINE></TERM>
    <DESC>Create a lightweight tag.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git tag -a &lt;tagname&gt; &lt;commitchecksum&gt;</CODEROUTINE></TERM>
    <DESC>Create a tag corresponding to a past commit.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git push origin &lt;tagname&gt;</CODEROUTINE></TERM>
    <DESC>Push a tag on the remote.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git push origin --tags</CODEROUTINE></TERM>
    <DESC>Push all tags on the remote.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git tag -d &lt;tagname&gt;</CODEROUTINE></TERM>
    <DESC>Delete a tag locally.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git push origin :refs/tags/&lt;tagname&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git push origin --delete &lt;tagname&gt;</CODEROUTINE></TERM>
    <DESC>Delete a tag on the remote.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE><X><T>git bisect</T><A>https://git-scm.com/docs/git-bisect</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>Use binary search to find the commit that introduced a bug.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE><X><T>git show-ref</T><A>https://git-scm.com/docs/git-show-ref</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>List the references in the local repository and their associated commits.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git hash-object &lt;file&gt;</CODEROUTINE></TERM>
    <DESC>Compute the file hash.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git hash-object --stdin</CODEROUTINE></TERM>
    <DESC>Read data to hash from standard input.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git hash-object -w</CODEROUTINE></TERM>
    <DESC>Actually write the object into the object database.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git hash-object -t &lt;type&gt;</CODEROUTINE></TERM>
    <DESC>Specify the type (default: "blob").</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git cat-file -t 47281c0d4fae6480a95aced8887244544feba9c5</CODEROUTINE></TERM>
    <DESC>Display the type of a repository object.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git cat-file -p 47281c0d4fae6480a95aced8887244544feba9c5</CODEROUTINE></TERM>
    <DESC>Display the content (pretty printed) of a repository object.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE><X><T>git count-objects</T><A>https://git-scm.com/docs/git-count-objects</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>Display the number of unpacked object files and disk space consumed by them.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE><X><T>git grep</T><A>https://git-scm.com/docs/git-grep</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>Print lines matching a pattern.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git update-ref -d &lt;ref&gt;</CODEROUTINE></TERM>
    <DESC>Delete reference &lt;ref&gt; in the local repository.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE><X><T>git gc</T><A>https://git-scm.com/docs/git-gc</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>Compress file revision and remove unreachable objects.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git maintenance register</CODEROUTINE></TERM>
    <DESC>Initialize Git config values so any scheduled maintenance will start running on this repository.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git maintenance unregister</CODEROUTINE></TERM>
    <DESC>Remove the current repository from background maintenance.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git submodule add https://github.com/chaconinc/DbConnector</CODEROUTINE></TERM>
    <DESC>Add an existing Git repository as a submodule.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE><X><T>git config</T><A>https://git-scm.com/docs/git-config</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>Get and set repository or global options.<BR/>
      When reading, the values are read from the system, global, and repository local configuration files by default, and options <CODEROUTINE>--system</CODEROUTINE>, <CODEROUTINE>--global</CODEROUTINE>, <CODEROUTINE>--local</CODEROUTINE>, <CODEROUTINE>--worktree</CODEROUTINE> and <CODEROUTINE>--file</CODEROUTINE> &lt;filename&gt; can be used to tell the command to read from only that location.<BR/>
      When writing, the new value is written to the repository local configuration file by default, and options <CODEROUTINE>--system</CODEROUTINE>, <CODEROUTINE>--global</CODEROUTINE>, <CODEROUTINE>--worktree</CODEROUTINE>, <CODEROUTINE>--file</CODEROUTINE> &lt;filename&gt; can be used to tell the command to write to that location (we can use <CODEROUTINE>--local</CODEROUTINE> but that is the default).</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git config -l</CODEROUTINE><BR/>
      <CODEROUTINE>git config --list</CODEROUTINE></TERM>
    <DESC>List all variables set in config file with their values.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git config --global --list</CODEROUTINE></TERM>
    <DESC>Display the global configuration.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git config -l --show-origin</CODEROUTINE></TERM>
    <DESC>List all variables set in config file with, their values, and the files in which they are defined.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git config --global --edit</CODEROUTINE></TERM>
    <DESC>Open an editor to edit the global configuration file.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git config --global user.name "John Doe"</CODEROUTINE></TERM>
    <DESC>Set the name in the global configuration file.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git config --global user.email johndoe@example.com</CODEROUTINE></TERM>
    <DESC>Set the email in the global configuration file.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git config --system user.email johndoe@example.com</CODEROUTINE></TERM>
    <DESC>Set the email in the system-wide configuration file.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git config user.name "John Doe"</CODEROUTINE><BR/>
      <CODEROUTINE>git config --local user.name "John Doe"</CODEROUTINE></TERM>
    <DESC>Set the name in the local repository configuration file.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git config --unset &lt;name&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git config --local --unset &lt;name&gt;</CODEROUTINE></TERM>
    <DESC>Remove the line matching the key &lt;name&gt; from config file</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git config --remove-section &lt;name&gt;</CODEROUTINE></TERM>
    <DESC>Remove the section &lt;name&gt; from the configuration file.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git config --replace-all</CODEROUTINE></TERM>
    <DESC>Default behavior is to replace at most one line. This replaces all lines matching the key.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git config --add</CODEROUTINE></TERM>
    <DESC>Adds a new line to the option without altering any existing values.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git config --rename-section &lt;old-name&gt; &lt;new-name&gt;</CODEROUTINE></TERM>
    <DESC>Rename the section &lt;old-name&gt; into &lt;new-name&gt;.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git config --global alias ac "commit -am"</CODEROUTINE></TERM>
    <DESC>Define an alias. The alias can be used as <CODEROUTINE>git ac "Fixed my bug"</CODEROUTINE>.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
It is possible to ignore files/directories in a given directory by listing them in the <CODEFILENAME>.gitignore</CODEFILENAME> file of that directory.<BR/>
<BR/>
In order to commit an empty directory, create a <CODEFILENAME>.gitkeep</CODEFILENAME> file in it. This is not defined by Git, but it is a common usage.<BR/>
<BR/>
To remove the last commit locally and on the remote repository (nobody should have pulled meanwhile)
  <CODESAMPLE>git reset --hard HEAD^<BR/>
  git push -f</CODESAMPLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE><X><T>git rebase</T><A>https://git-scm.com/docs/git-rebase</A><L>en</L><F>HTML</F></X></CODEROUTINE></TERM>
    <DESC>Reapply commits on top of another base tip</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git rebase --interactive</CODEROUTINE><BR/>
      <CODEROUTINE>git rebase -i</CODEROUTINE></TERM>
    <DESC>Start an interactive rebase: the list of commits is generated and the user can edit them.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git rebase --continue</CODEROUTINE></TERM>
    <DESC>Restart the rebasing process after having resolved a merge conflict.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git rebase --abort</CODEROUTINE></TERM>
    <DESC>Abort the rebase operation and reset HEAD to the original branch.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git rebase --quit</CODEROUTINE></TERM>
    <DESC>Abort the rebase operation but HEAD is not reset back to the original branch.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git rebase --exec &lt;cmd&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git rebase -x &lt;cmd&gt;</CODEROUTINE></TERM>
    <DESC>Append <CODEFILENAME>exec &lt;cmd&gt;</CODEFILENAME> after each line creating a commit in the final history.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<DEFINITIONTABLE>
  <ROW>
    <TERM><CODEROUTINE>git commit --fixup=&lt;commit&gt;</CODEROUTINE></TERM>
    <DESC>Create a <CODEROUTINE>fixup!</CODEROUTINE> commit which changes the content of &lt;commit&gt; but leaves its log message untouched.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git commit --fixup=amend:&lt;commit&gt;</CODEROUTINE></TERM>
    <DESC>Similar but create an <CODEROUTINE>amend!</CODEROUTINE> commit which also replaces the log message of &lt;commit&gt; with the log message of the <CODEROUTINE>amend!</CODEROUTINE> commit.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git commit --fixup=reword:&lt;commit&gt;</CODEROUTINE><BR/>
      <CODEROUTINE>git commit --fixup=amend:&lt;commit&gt; --only</CODEROUTINE></TERM>
    <DESC>Create an <CODEROUTINE>amend!</CODEROUTINE> commit which replaces the log message of &lt;commit&gt; with its own log message but makes no changes to the content of &lt;commit&gt;.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git commit --squash=&lt;commit&gt;</CODEROUTINE></TERM>
    <DESC>Construct a commit message for use with <CODEROUTINE>rebase --autosquash</CODEROUTINE>. The commit message subject line is taken from the specified commit with a prefix of <CODEROUTINE>squash!</CODEROUTINE>.</DESC>
  </ROW>
  <ROW>
    <TERM><CODEROUTINE>git rebase --autosquash</CODEROUTINE></TERM>
    <DESC>When the commit log message begins with <CODEROUTINE>squash! …​</CODEROUTINE> or <CODEROUTINE>fixup! …​</CODEROUTINE> or <CODEROUTINE>amend! …​</CODEROUTINE>, and there is already a commit in the todo list that matches the same <CODEROUTINE>…</CODEROUTINE>, automatically modify the todo list of <CODEROUTINE>rebase -i</CODEROUTINE>, so that the commit marked for squashing comes right after the commit to be modified, and change the action of the moved commit from <CODEROUTINE>pick</CODEROUTINE> to <CODEROUTINE>squash</CODEROUTINE> or <CODEROUTINE>fixup</CODEROUTINE> or <CODEROUTINE>fixup -C</CODEROUTINE> respectively.<BR/>
    A commit matches the <CODEROUTINE>…</CODEROUTINE> if the commit subject matches, or if the <CODEROUTINE>…</CODEROUTINE> refers to the commit’s hash. As a fall-back, partial matches of the commit subject work, too.</DESC>
  </ROW>
</DEFINITIONTABLE>
<BR/>
<BLIST><TITLE>Changing the author of old commits</TITLE>
  <ITEM><CODEROUTINE>git rebase -i &lt;commit&gt;</CODEROUTINE> where &lt;commit&gt; is the commit before the first one to be edited. Use <CODEROUTINE>git rebase -i --root</CODEROUTINE> if the first commit must be edited.</ITEM>
  <ITEM>In the list of commits, change <CODEROUTINE>pick</CODEROUTINE> to <CODEROUTINE>edit</CODEROUTINE> for the commits to be edited.</ITEM>
  <ITEM>When the interactive rebase pauses, <CODEROUTINE>git commit --amend --author="Author Name &lt;email@address.com&gt;"</CODEROUTINE>, then <CODEROUTINE>git rebase --continue</CODEROUTINE>.</ITEM>
  <ITEM><CODEROUTINE>git push -f</CODEROUTINE>.</ITEM>
</BLIST>
<BR/>
Script to mirror a repository in another (to be completed to support GitHub)
<CODESAMPLE>#!/bin/bash<BR/>
  <BR/>
  source_repo="gitlab.com/lmazure_TestGroup"<BR/>
  source_project="secondtestproject"<BR/>
  target_repo="gitlab.com/lmazure_testmirroring"<BR/>
  target_project="secondtestprojectmirror"<BR/>
  git clone --mirror https://$source_repo/$source_project.git<BR/>
  cd $source_project.git<BR/>
  git show-ref | grep ' refs/merge-requests/' | cut -d' ' -f2 | xargs -n1 -r git update-ref -d # do not push merge-requests refs to GitLab, it will refuse them<BR/>
  git push --mirror https://$target_repo/$target_project.git<BR/>
  cd ..<BR/>
  rm -fr $project.git</CODESAMPLE>
<BR/>
<BLIST><TITLE>Git SVN</TITLE>
  <ITEM>Create a Git repo linked to a SVN repo<BR/>
    <CODEROUTINE>git svn clone -s file:///cygdrive/m/laurent_svn_repository/homepage</CODEROUTINE>
  </ITEM>
  <ITEM>Fetch revisions from the SVN repo of the current HEAD and rebase the current (uncommitted to SVN) work against it<BR/>
    <CODEROUTINE>git svn rebase</CODEROUTINE>
  </ITEM>
</BLIST>
<BR/>
<BLIST><TITLE>Fix a repository created by Eclipse</TITLE>
  <ITEM>Eclipse may configure a repository tracking only the current and main branches:
    <CODESAMPLE><PROMPT/>git config --local --list<BR/>
      …<BR/>
      remote.origin.fetch=+refs/heads/55-proper-support-of-removed-articles:refs/remotes/origin/55-proper-support-of-removed-articles<BR/>
      remote.origin.fetch=+refs/heads/main:refs/remotes/origin/main<BR/>
      …</CODESAMPLE>
  </ITEM>
  <ITEM>to fix it and track all branches:
    <CODESAMPLE><PROMPT/>git config --local --replace-all remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"</CODESAMPLE>
  </ITEM>
  <ITEM>then <CODEROUTINE>git fetch</CODEROUTINE> will fetch all branches.</ITEM>
</BLIST>
<BR/>
<BLIST><TITLE>Git BASH on Windows</TITLE>
  <ITEM>The home directory is defined by the <CODEROUTINE>%HOME%</CODEROUTINE> Windows environment variable (which is not used by Windows, so it is safe to set/modify it).</ITEM>
  <ITEM>To display the remote repository in the browser: <CODEROUTINE>start `git remote get-url origin`</CODEROUTINE>.</ITEM>
  <ITEM>To run Python: <CODEROUTINE>winpty python</CODEROUTINE></ITEM>
  <ITEM>To display an HTML file: <CODEROUTINE>start report.html</CODEROUTINE></ITEM>
</BLIST>
</CONTENT>
<X><T>links</T><A>../links/scm.html#git</A><L>en</L><F>HTML</F></X>
</PAGE>