<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="GENERATOR"
 content="Mozilla/4.74 [en] (Win95; U) [Netscape]">
  <title>Python</title>
  <link rel="STYLESHEET" type="text/css" href="../css/standard"
 title="standard">
  <script language="JavaScript" src="../css/common.js"></script>
</head>
<body>
syntax
<ul>
  <li>comment starts with <tt>#</tt> and extend to the end of the line</li>
  <li>multiple assignment</li>
  <tt>a,b=0,1</tt> <br>
  <tt>a,b=b,a+b</tt> <li><tt>del</tt> can be used to delete a variable</li>
  <tt>del a</tt> <li><tt>in</tt> test if a value is in a sequence</li>
  <li> <tt>not in</tt> test if a value is not in a sequence</li>
  <li> <tt>and</tt>, <tt>or</tt> and <tt>not</tt> are boolean
operators</li>
  <tt>and</tt> and <tt>or</tt> perform a shortcut evaluation <br>
  <tt>&gt;&gt;&gt; print '' or 'a' or 'b'</tt> <br>
  <tt>a</tt> <li>in interactive mode, <tt>_</tt> is a read-only
variable
containing the
last printed expression</li>
  <li>exit</li>
  <tt>import sys</tt> <br>
  <tt>sys.exit()</tt>
</ul>
complex
<ul>
  <li>complex can be created by using <tt>j</tt> or <tt>J</tt> to
indicate
the
complex part</li>
  <tt>1+2j</tt> <br>
or with the complex function <br>
  <tt>complex(1,2)</tt> <br>
  <tt>real</tt> and <tt>imag</tt> can be used to retrieve the real and
imaginary part of a complex <br>
  <tt>a=1.5+0.5j</tt> <br>
  <tt>a.real</tt> <br>
  <tt>a.imag</tt>
</ul>
sequences
<ul>
  <li>sequences can be lists, strings or tuples</li>
</ul>
strings
<ul>
  <li>strings litterals can be enclosed in single or double quotes</li>
  <tt>"foobar 'n \" quux"</tt> <br>
  <tt>'foobar \'n" quux'</tt> <li>new line can be escaped by \</li>
  <tt>"first line \n\</tt> <br>
  <tt>second line"</tt> <li>triple single or double quotes can also be
used to create strings
containing
new lines</li>
  <tt>"""first line</tt> <br>
  <tt>seconde line"""</tt> <li>string litterals are automatically
concatenated</li>
  <tt>"foo" "bar"</tt> <li>+ append strings</li>
  <tt>"foo"+"bar"</tt> <li><tt>*</tt> repeats strings</li>
  <tt>"foo"*5</tt> is <tt>"foofoofoofoofoo"</tt> <li>slices</li>
  <tt>str[4]</tt> fifth letter <br>
  <tt>str[2:4]</tt> third and fourth letters <br>
  <tt>str[:2]</tt> first two characters <br>
  <tt>str[2:]</tt> all but first two characters <br>
  <tt>str[-1]</tt> last character <br>
  <tt>str[-2]</tt> last but one character <br>
  <tt>str[-2:]</tt> last two characters <br>
  <tt>str[:-2]</tt> all but the last two characters <br>
slices are immutable <li><tt>len</tt> return the length a string</li>
  <tt>len(str)</tt>
</ul>
lists
<ul>
  <li>lists can mix types</li>
  <tt>a=['foo',69,'bar']</tt> <li>lists support slices (these ones are
mutable and can even be used
to change
the size of the list)</li>
  <tt>a[0:2]</tt> removes the two first elements of the list <br>
  <tt>a[:0]=a</tt> insert a copy ot itself at the beginning of the list
  <li><tt>del</tt> can be use to remeove elements in a list</li>
  <tt>del a[2:4]</tt> <li><tt>len</tt> return the number of elements
of a list</li>
  <li>lists can be nested</li>
  <tt>q=[45,3]</tt> <br>
  <tt>p=[0,q,14]</tt> <li>list unpacking</li>
  <tt>a=[1,2,3,4]</tt> <br>
  <tt>[a1,a2,a3,a4]=a</tt> <li>methods</li>
  <ul>
    <li> <tt>insert(pos,item)</tt> insert an item at a given position</li>
    <li> <tt>append(elem)</tt> append an item at the list end</li>
    <li>pop(i) remove the item at the given position in the list and
return it</li>
    <li>pop() remove the last item and return it</li>
    <li> <tt>index(item)</tt> return the index of the first occurence
of
the valueitem</li>
    <li> <tt>remove(item)</tt> remove the first occurence of the value
item</li>
    <li> <tt>sort()</tt> sort the list</li>
    <li> <tt>reverse()</tt> reverse the list</li>
    <li> <tt>count(item)</tt> return the number of occurences of the
value
item</li>
  </ul>
  <li>functions</li>
  <ul>
    <li> <tt>filter(function,l)</tt> return the list of elements <tt>elem</tt>
of<tt>l</tt>for
which <tt>function(elem)</tt> is true</li>
    <li> <tt>map(function,l)</tt> return the list of values of <tt>function</tt>
called for each element of <tt>l</tt></li>
more than one list can be passed to <tt>map</tt>, in this case, <tt>function</tt>
must have the same number of arguments (if a list is shorter than the
other
one, <tt>function</tt> will be called with the value <tt>None</tt>) <br>
if <tt>None</tt> is passed instead of a function, <tt>map</tt>
returnits
arguments <br>
    <tt>&gt;&gt;&gt; map(None,[1,2,3,4],[5,6,7])</tt> <br>
    <tt>[(1, 5), (2, 6), (3, 7), (4, None)]</tt> <li><tt>reduce(function,l)</tt>
call <tt>function</tt> on the two
first items,then
on the result and the next item...</li>
    <tt>&gt;&gt;&gt; reduce(lambda x,y:x+y , [1,2,3,4,5,6])</tt> <br>
    <tt>21</tt> <br>
a third argument can be passed to indicate the starting value (this
value will be returned in case of an empty list)
  </ul>
</ul>
tuples
<ul>
  <li>a tuple is a number of values separated by a comma</li>
(they may be input with or without parentheses) <br>
  <tt>t=1,2,"azerty"</tt> <li>tuples support slicing</li>
  <li>an empty tuple is created with the syntax:</li>
  <tt>empty=()</tt> <li>a singleton tuple is created with an empty
comma</li>
  <tt>singleton=1,</tt> <li>tuple packing</li>
  <tt>t=1,2,3</tt> <br>
tuple unpacking <br>
  <tt>x,y,z=t</tt> <li>tuple are immutable: it is not possible ot
assign to the
individual items
of a tuple</li>
</ul>
dictionaries
<ul>
  <li>syntax</li>
  <tt>d={'key1':1234,'key2':5678}</tt> <br>
  <tt>d['key3']=43</tt> <li>keys must be immuable: numbers, strings
and tuples containing
only numbers,
strings and tuples</li>
  <li> <tt>del</tt> can be used to delete entries of a dictionary</li>
  <tt>del d['key3']</tt> <li>methods</li>
  <ul>
    <li> <tt>keys</tt> return the keys of a dictionary</li>
    <li> <tt>has_key</tt> test if a key is in the dictionary</li>
  </ul>
</ul>
print
<ul>
  <li>arguments are comma separated</li>
  <tt>print "i=",i</tt> <li>a trailing comma indicates to not add a
new line</li>
  <tt>print i,</tt>
</ul>
control flow
<ul>
  <li> <tt>if x==1:</tt></li>
  <tt>&nbsp;&nbsp;&nbsp; print "one"</tt> <br>
  <tt>elif x==2:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; print "two"</tt> <br>
  <tt>elif x==3:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; print "three"</tt> <br>
  <tt>else:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; print "other"</tt> <li><tt>for</tt> loops on
a string or list content</li>
the <tt>else</tt> clause is executed when the list is exhausted <br>
  <tt>a=[1,2,3]</tt> <br>
  <tt>for x in a:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; print x</tt> <br>
  <tt>else:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; print "finished"</tt> <li>it is not safe to
modified the content of the list being looped
on, a copy
should be generated</li>
  <tt>for x in a[:]:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; if x&gt;2: a.insert(0,x)</tt> <li><tt>while</tt>
loops as long a condition is true</li>
  <tt>while b&lt;10:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; b=b+1</tt> <br>
  <tt>else:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; print "end"</tt> <li>there is no <tt>do</tt>/<tt>while</tt>
statement</li>
instead use <br>
  <tt>while 1:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; line = sys.stdin.readline()</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; if line == "\n": break</tt> <li><tt>range(stop)</tt>
returns <tt>[0,1,2...stop-1]</tt></li>
  <tt>range(start,stop)</tt> returns <tt>[start,start+1...stop-1]</tt>
  <br>
  <tt>range(start,stop,incr)</tt> returns <tt>[start,start+incr...stop-incr]</tt>
  <li><tt>break</tt> breaks out of the smallest enclosing <tt>for</tt>
or <tt>while</tt>loop</li>
the <tt>else</tt> clause is not executed <li><tt>continue</tt>
continues with the next iteration of the loop</li>
  <li> <tt>pass</tt> is a noop statement</li>
</ul>
function
<ul>
  <li>syntax (the docstring is optional):</li>
  <tt>def myfunction(a,b,c):</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; "docstring"</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; # ... code</tt> <li>all variable assignments
store value in the local symbol table</li>
variable references are look in the local symbl table, then in the
global symbol table and, at last, in the table of built-in names <li>parameters
are passed by reference</li>
  <li>function references can be stored in variables</li>
  <tt>f=myfunction</tt> <li><tt>return</tt> returns the <tt>None</tt>
value</li>
  <tt>return s</tt> returns the <tt>s</tt> value <li>default argument
values can be used, they are evaluated only once</li>
  <tt>def f(a,l=[]):</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; l.append(a)</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; return l</tt> <br>
  <tt>print f(1) prints [1]</tt> <br>
  <tt>print f(2) prints [1,2]</tt> <br>
  <tt>print f(3) prints [1,2,3]</tt> <br>
to avoid this: <br>
  <tt>def f(a,l=None)</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; if l is None:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l=[]</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; l.append(a)</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; return l</tt> <li>parameters can be passed by
keywords</li>
  <tt>def foobar(a,b,c,d):</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; #...</tt> <br>
  <tt>foobar(0,1,d=4,c=3)</tt> <li><tt>*name</tt> can be used to get
an arbitrary number of
positional arguments</li>
  <tt>**name</tt> can be used to get an arbitrary number of keyword
arguments <br>
  <tt>def quux(*a,**b):</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; for arg in a: print arg</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; for kw in b.keys(): print kw,':',b[kw]</tt> <li><tt>lambda</tt>
can be used to create anonymous functions</li>
they are restricted to a single expression <br>
  <tt>lambda a,b:a+b</tt> <br>
another example using a default argument value <br>
  <tt>def make_incrementator(n)</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; return lambda x,incr=n:x+incr</tt>
</ul>
modules
<ul>
  <li>a module is a file containing Python definitions and statements</li>
the statements are executed the first time the module is imported <li>syntax
to import a module</li>
  <tt>&gt;&gt;&gt; import mymod</tt> <br>
  <tt>mymod.myfunc(2)</tt> <li>symbols of the imported module can be
declared in the importing
module's
symbol table</li>
  <tt>from mymod import myfunc, myfunc2</tt> <br>
all symbols (except those beginning by an underscore) can be declared
in the importing module's symbol table <br>
  <tt>from mymod import *</tt> <li>reload a module</li>
  <tt>reload(mymod)</tt> <li>inside a module, its name is defined in <tt>__name__</tt></li>
  <li> <tt>sys.builtin_module_names</tt> lists the modules compiled in
the
interpreter</li>
  <li>module path</li>
  <ul>
    <li>modules are looked for in the directories listed by <tt>sys.path</tt>
(which
is initially defined by the environment variable <tt>$PYTHONPATH</tt>)</li>
    <li>append a new directory to the path:</li>
    <tt>sys.path.append('C:\\windows\desktop')</tt>
  </ul>
  <li> <tt>dir</tt> returns a list of the names defined in a module</li>
  <tt>dir(mymod)</tt> <li><tt>__builtin__</tt> is the standard module</li>
</ul>
packages
<ul>
  <li>packages are structured as directories containing the file <tt>__init__.py</tt>
(possibly empty) and other files being modules</li>
a package can also contain subdirectories (i.e. subpackages) <li><tt>__init__.py</tt>
can define <tt>__all__.py</tt> which is the
list of
the modules which should be imported when the syntax <tt>from
mypackageimport
*</tt> is used.</li>
</ul>
classes
<ul>
  <li>the definition of a class starts with the declaration <tt>class:</tt></li>
  <li>the initialisation method is <tt>__init__</tt></li>
  <tt>class Complex:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; def __init__(self, realpart, imagpart):</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.r = realpart</tt>
  <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.i = imagpart</tt>
</ul>
objects
<blockquote><li> <tt>is</tt> test if two objects are the same</li>
  <li> <tt>is not</tt> test if two objects are not the same</li>
  <li> <tt>id()</tt> return an integer representing the identity of
the
object
(currently implemented as its address)</li>
  <li> <tt>type()</tt> return the type of an object</li>
</blockquote>
exceptions
<ul>
  <li>use try to declare the temptative code block and except to catch
the
exeception</li>
  <tt>try:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; ...</tt> <br>
  <tt>except ValueError:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; ...</tt> <li>it is possible to have several
exceptions with the same handler
and several
handlers with the same <tt>try</tt> clause</li>
  <tt>try:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; ...</tt> <br>
  <tt>except (RuntimeError, TypeError, NameError):</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; ...</tt> <br>
  <tt>except ValueError:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; ...</tt> <li>a final <tt>except</tt> handler
will cathc all exceptions</li>
  <tt>try:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; ...</tt> <br>
  <tt>except (RuntimeError, TypeError, NameError):</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; ...</tt> <br>
  <tt>except:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; ...</tt> <li>an <tt>else</tt> clause may be
added after the exception
handlers, it will
be executed anytime no exception occured</li>
  <tt>try:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; ...</tt> <br>
  <tt>except (RuntimeError, TypeError, NameError):</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; ...</tt> <br>
  <tt>else:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; ...</tt> <li>it is possible to retrieve the
exception details by adding a
variable name
after the exception list</li>
  <tt>try:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; ...</tt> <br>
  <tt>except IOError, (errno, strerror):</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; ...</tt> <br>
  <tt>except ZeroDivisionError, detail:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; ...</tt> <li>a <tt>finally</tt> block can be
used instead of <tt>except</tt>
handlers:
it will be always excuted, but if an exception occured, it will be
reraised
after this excution</li>
  <tt>try:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; ...</tt> <br>
  <tt>finally:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; ...</tt> <li><tt>raise</tt> can be used to
raise an exception (the argument is
optional)</li>
  <br>
  <tt>raise NameError, 'HiThere'</tt> <li><tt>raise</tt> with no
argument reraise the current exception</li>
</ul>
<tt>sys</tt> module
<ul>
  <li> <tt>sys.ps1</tt> is the primary prompt</li>
  <li> <tt>sys.ps2</tt> is the secondary prompt</li>
  <li> <tt>sys.path</tt> is the module search path</li>
  <li> <tt>sys.exit()</tt> to exit the script</li>
</ul>
<p><br>
<tt>os</tt> module:
</p>
<ul>
  <li>use <tt>os.patch.join</tt> to manipulate directory and file names</li>
</ul>
<hr noshade="noshade" width="80%">
<p><i><font size="-1">Last update: December 2</font><sup><font size="-2">nd</font></sup><font
 size="-1">,2001
- <a href="javascript:do_email()">Laurent</a></font></i>
</p>
</body>
</html>
