<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="GENERATOR"
 content="Mozilla/4.74 [en] (Win95; U) [Netscape]">
  <title>Python</title>
  <link rel="STYLESHEET" type="text/css" href="../css/standard"
 title="standard">
  <script src="../scripts/common.js"  type="module"></script>
</head>
<body>
print
<ul>
  <li>arguments are comma separated</li>
  <tt>print "i=",i</tt> <li>a trailing comma indicates to not add a
new line</li>
  <tt>print i,</tt>
</ul>
control flow
<ul>
  <li> <tt>if x==1:</tt></li>
  <tt>&nbsp;&nbsp;&nbsp; print "one"</tt> <br>
  <tt>elif x==2:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; print "two"</tt> <br>
  <tt>elif x==3:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; print "three"</tt> <br>
  <tt>else:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; print "other"</tt> <li><tt>for</tt> loops on
a string or list content</li>
the <tt>else</tt> clause is executed when the list is exhausted <br>
  <tt>a=[1,2,3]</tt> <br>
  <tt>for x in a:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; print x</tt> <br>
  <tt>else:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; print "finished"</tt> <li>it is not safe to
modified the content of the list being looped
on, a copy
should be generated</li>
  <tt>for x in a[:]:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; if x&gt;2: a.insert(0,x)</tt> <li><tt>while</tt>
loops as long a condition is true</li>
  <tt>while b&lt;10:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; b=b+1</tt> <br>
  <tt>else:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; print "end"</tt> <li>there is no <tt>do</tt>/<tt>while</tt>
statement</li>
instead use <br>
  <tt>while 1:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; line = sys.stdin.readline()</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; if line == "\n": break</tt> <li><tt>range(stop)</tt>
returns <tt>[0,1,2...stop-1]</tt></li>
  <tt>range(start,stop)</tt> returns <tt>[start,start+1...stop-1]</tt>
  <br>
  <tt>range(start,stop,incr)</tt> returns <tt>[start,start+incr...stop-incr]</tt>
  <li><tt>break</tt> breaks out of the smallest enclosing <tt>for</tt>
or <tt>while</tt>loop</li>
the <tt>else</tt> clause is not executed <li><tt>continue</tt>
continues with the next iteration of the loop</li>
  <li> <tt>pass</tt> is a noop statement</li>
</ul>
function
<ul>
  <li>syntax (the docstring is optional):</li>
  <tt>def myfunction(a,b,c):</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; "docstring"</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; # ... code</tt> <li>all variable assignments
store value in the local symbol table</li>
variable references are look in the local symbl table, then in the
global symbol table and, at last, in the table of built-in names <li>parameters
are passed by reference</li>
  <li>function references can be stored in variables</li>
  <tt>f=myfunction</tt> <li><tt>return</tt> returns the <tt>None</tt>
value</li>
  <tt>return s</tt> returns the <tt>s</tt> value <li>default argument
values can be used, they are evaluated only once</li>
  <tt>def f(a,l=[]):</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; l.append(a)</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; return l</tt> <br>
  <tt>print f(1) prints [1]</tt> <br>
  <tt>print f(2) prints [1,2]</tt> <br>
  <tt>print f(3) prints [1,2,3]</tt> <br>
to avoid this: <br>
  <tt>def f(a,l=None)</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; if l is None:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l=[]</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; l.append(a)</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; return l</tt> <li>parameters can be passed by
keywords</li>
  <tt>def foobar(a,b,c,d):</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; #...</tt> <br>
  <tt>foobar(0,1,d=4,c=3)</tt> <li><tt>*name</tt> can be used to get
an arbitrary number of
positional arguments</li>
  <tt>**name</tt> can be used to get an arbitrary number of keyword
arguments <br>
  <tt>def quux(*a,**b):</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; for arg in a: print arg</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; for kw in b.keys(): print kw,':',b[kw]</tt> <li><tt>lambda</tt>
can be used to create anonymous functions</li>
they are restricted to a single expression <br>
  <tt>lambda a,b:a+b</tt> <br>
another example using a default argument value <br>
  <tt>def make_incrementator(n)</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; return lambda x,incr=n:x+incr</tt>
</ul>
modules
<ul>
  <li>a module is a file containing Python definitions and statements</li>
the statements are executed the first time the module is imported <li>syntax
to import a module</li>
  <tt>&gt;&gt;&gt; import mymod</tt> <br>
  <tt>mymod.myfunc(2)</tt> <li>symbols of the imported module can be
declared in the importing
module's
symbol table</li>
  <tt>from mymod import myfunc, myfunc2</tt> <br>
all symbols (except those beginning by an underscore) can be declared
in the importing module's symbol table <br>
  <tt>from mymod import *</tt> <li>reload a module</li>
  <tt>reload(mymod)</tt> <li>inside a module, its name is defined in <tt>__name__</tt></li>
  <li> <tt>sys.builtin_module_names</tt> lists the modules compiled in
the
interpreter</li>
  <li>module path</li>
  <ul>
    <li>modules are looked for in the directories listed by <tt>sys.path</tt>
(which
is initially defined by the environment variable <tt>$PYTHONPATH</tt>)</li>
    <li>append a new directory to the path:</li>
    <tt>sys.path.append('C:\\windows\desktop')</tt>
  </ul>
  <li> <tt>dir</tt> returns a list of the names defined in a module</li>
  <tt>dir(mymod)</tt> <li><tt>__builtin__</tt> is the standard module</li>
</ul>
packages
<ul>
  <li>packages are structured as directories containing the file <tt>__init__.py</tt>
(possibly empty) and other files being modules</li>
a package can also contain subdirectories (i.e. subpackages) <li><tt>__init__.py</tt>
can define <tt>__all__.py</tt> which is the
list of
the modules which should be imported when the syntax <tt>from
mypackageimport
*</tt> is used.</li>
</ul>
classes
<ul>
  <li>the definition of a class starts with the declaration <tt>class:</tt></li>
  <li>the initialisation method is <tt>__init__</tt></li>
  <tt>class Complex:</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp; def __init__(self, realpart, imagpart):</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.r = realpart</tt>
  <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.i = imagpart</tt>
</ul>
objects
<blockquote><li> <tt>is</tt> test if two objects are the same</li>
  <li> <tt>is not</tt> test if two objects are not the same</li>
  <li> <tt>id()</tt> return an integer representing the identity of
the
object
(currently implemented as its address)</li>
  <li> <tt>type()</tt> return the type of an object</li>
</blockquote>

<tt>sys</tt> module
<ul>
  <li> <tt>sys.ps1</tt> is the primary prompt</li>
  <li> <tt>sys.ps2</tt> is the secondary prompt</li>
  <li> <tt>sys.path</tt> is the module search path</li>
  <li> <tt>sys.exit()</tt> to exit the script</li>
</ul>
<p><br>
<tt>os</tt> module:
</p>
<ul>
  <li>use <tt>os.patch.join</tt> to manipulate directory and file names</li>
</ul>
<hr noshade="noshade" width="80%">
<p><i><font size="-1">Last update: December 2</font><sup><font size="-2">nd</font></sup><font
 size="-1">,2001
- <a href="javascript:do_email()">Laurent</a></font></i>
</p>
</body>
</html>
