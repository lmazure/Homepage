<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="../css/strict.xsl"?>
<PAGE xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../css/schema.xsd" xml:lang="en">
<TITLE>Python</TITLE>
<PATH>notes/python.xml</PATH>
<DATE><YEAR>2022</YEAR><MONTH>12</MONTH><DAY>6</DAY></DATE>
<CONTENT>
<BLIST><TITLE><U><B>Syntax</B></U></TITLE>
  <ITEM>comment starts with <CODEROUTINE>#</CODEROUTINE> and extends to the end of the line</ITEM>
  <ITEM>multiple assignment<BR/>
    <CODEROUTINE>a,b=0,1</CODEROUTINE><BR/>
    <CODEROUTINE>a,b=b,a+b</CODEROUTINE></ITEM>
  <ITEM><CODEROUTINE>del</CODEROUTINE> can be used to delete a variable<BR/>
    <CODEROUTINE>del a</CODEROUTINE></ITEM>
  <ITEM><CODEROUTINE>in</CODEROUTINE> test if a value is in a sequence</ITEM>
  <ITEM><CODEROUTINE>not in</CODEROUTINE> test if a value is not in a sequence</ITEM>
  <ITEM><CODEROUTINE>and</CODEROUTINE>, <CODEROUTINE>or</CODEROUTINE>, and <CODEROUTINE>not</CODEROUTINE> are boolean operators<BR/>
    <CODEROUTINE>and</CODEROUTINE> and <CODEROUTINE>or</CODEROUTINE> perform a shortcut evaluation<BR/>
    <CODESAMPLE>&gt;&gt;&gt; print '' or 'a' or 'b'<BR/>
      a</CODESAMPLE></ITEM>
  <ITEM>floor division: division that rounds to nearest integer (not floor!)
    <CODESAMPLE>a = (-11) // 4 # -3</CODESAMPLE>
  </ITEM>
  <ITEM>power
    <CODESAMPLE>a = 3 ** 4 # 81</CODESAMPLE>
  </ITEM>
  <ITEM>in interactive mode, <CODEROUTINE>_</CODEROUTINE> is a read-only variable containing the last printed expression</ITEM>
  <ITEM>exit<BR/>
    <CODESAMPLE>import sys<BR/>
      sys.exit()</CODESAMPLE></ITEM>
</BLIST>
<BLIST><TITLE><U><B>Complex</B></U></TITLE>
  <ITEM>a complex can be created by using <CODEROUTINE>j</CODEROUTINE> or <CODEROUTINE>J</CODEROUTINE> to indicate the complex part<BR/>
    <CODEROUTINE>1+2j</CODEROUTINE> or with the complex function <CODEROUTINE>complex(1,2)</CODEROUTINE></ITEM>
  <ITEM><CODEROUTINE>real</CODEROUTINE> and <CODEROUTINE>imag</CODEROUTINE> can be used to retrieve the real and imaginary parts of a complex<BR/>
  <CODESAMPLE>a=1.5+0.5j<BR/>
    a.real<BR/>
    a.imag</CODESAMPLE></ITEM>
</BLIST>
<BLIST><TITLE><U><B>Strings</B></U></TITLE>
  <ITEM>strings litterals can be enclosed in single or double quotes<BR/>
    <CODEROUTINE>"foobar 'n \" quux"</CODEROUTINE><BR/>
    <CODEROUTINE>'foobar \'n" quux'</CODEROUTINE></ITEM>
  <ITEM>new line can be escaped by \<BR/>
    <CODESAMPLE>"first line \n\<BR/>
      second line"</CODESAMPLE></ITEM>
  <ITEM>triple single or double quotes can also be used to create strings containing new lines<BR/>
    <CODESAMPLE>"""first line<BR/>
      second line"""</CODESAMPLE></ITEM>
  <ITEM>string litterals are automatically concatenated</ITEM>
  <ITEM><CODEROUTINE>"foo" "bar"</CODEROUTINE></ITEM>
  <ITEM>+ append strings<BR/>
    <CODEROUTINE>"foo"+"bar"</CODEROUTINE></ITEM>
  <ITEM><CODEROUTINE>*</CODEROUTINE> repeats strings<BR/>
    <CODEROUTINE>"foo"*5</CODEROUTINE> is <CODEROUTINE>"foofoofoofoofoo"</CODEROUTINE></ITEM>
  <ITEM>slices<BR/>
    <CODEROUTINE>str[4]</CODEROUTINE> fifth letter<BR/>
    <CODEROUTINE>str[2:4]</CODEROUTINE> third and fourth letters<BR/>
    <CODEROUTINE>str[:2]</CODEROUTINE> first two characters<BR/>
    <CODEROUTINE>str[2:]</CODEROUTINE> all but first two characters<BR/>
    <CODEROUTINE>str[-1]</CODEROUTINE> last character<BR/>
    <CODEROUTINE>str[-2]</CODEROUTINE> last but one character<BR/>
    <CODEROUTINE>str[-2:]</CODEROUTINE> last two characters<BR/>
    <CODEROUTINE>str[:-2]</CODEROUTINE> all but the last two characters<BR/>
    slices are immutable</ITEM>
  <ITEM>using a too large index generates an error
    <CODESAMPLE>&gt;&gt;&gt; "language"[42]<BR/>
      Traceback (most recent call last):<BR/>
      File "&lt;stdin&gt;", line 1, in &lt;module&gt;<BR/>
      IndexError: string index out of range</CODESAMPLE>
    but not for slices
  <CODESAMPLE>&gt;&gt;&gt; "language"[3:42]<BR/>
      'guage'</CODESAMPLE></ITEM>
  <ITEM><CODEROUTINE>len</CODEROUTINE> return the length a string<BR/>
    <CODEROUTINE>len(str)</CODEROUTINE></ITEM>
</BLIST>
<BLIST><TITLE><U><B>Sequences</B></U></TITLE>
  <ITEM>sequences can be lists, strings or tuples</ITEM>
</BLIST>
<BLIST><TITLE><U><B>List</B></U></TITLE>
  <ITEM>lists can mix types
    <CODESAMPLE>a = ['foo', 69, 'bar']</CODESAMPLE>
  </ITEM>
  <ITEM>lists support slices (these ones are mutable and can even be used to change the size of the list)<BR/>
    <CODEROUTINE>a[0:2]</CODEROUTINE>: remove the two first elements of the list<BR/>
    <CODEROUTINE>a[:0] = a</CODEROUTINE>: insert a copy ot itself at the beginning of the list
  </ITEM>
  <ITEM>All slice operations return a new list containing the requested elements. So <CODEROUTINE>a[:]</CODEROUTINE> returns a shallow copy of <CODEROUTINE>a</CODEROUTINE>.</ITEM>
  <ITEM><CODEROUTINE>del</CODEROUTINE> can be used to remove elements in a list
    <CODESAMPLE>del a[2:4]</CODESAMPLE>
  </ITEM>
  <ITEM>we can do the same with
    <CODESAMPLE>a[2:4] = []</CODESAMPLE>
  </ITEM>
  <ITEM>lists can be concatenated with <CODEROUTINE>+</CODEROUTINE>
    <CODESAMPLE>&gt;&gt;&gt; [ 1, 2 ] + [ 3, 4, 5]<BR/>
      [1, 2, 3, 4, 5] </CODESAMPLE>
  </ITEM>
  <ITEM><CODEROUTINE>len</CODEROUTINE>: return the number of elements of a list</ITEM>
  <ITEM>lists can be nested
    <CODESAMPLE>q = [45, 3]<BR/>
      p = [0, q, 14]</CODESAMPLE>
  </ITEM>
  <ITEM>list unpacking
    <CODESAMPLE>a = [1, 2, 3, 4]<BR/>
      [a1, a2, a3, a4] = a</CODESAMPLE>
  </ITEM>
  <ITEM>test if an element is in a list
    <CODESAMPLE>item in List</CODESAMPLE>
  </ITEM>
  <ITEM><BLIST><TITLE>Methods</TITLE>
    <ITEM><CODEROUTINE>insert(pos,item)</CODEROUTINE>: insert an item at a given position</ITEM>
    <ITEM><CODEROUTINE>append(elem)</CODEROUTINE>: append an item at the list end</ITEM>
    <ITEM><CODEROUTINE>pop(i)</CODEROUTINE>: remove the item at the given position in the list and return it</ITEM>
    <ITEM><CODEROUTINE>pop()</CODEROUTINE>: remove the last item and return it</ITEM>
    <ITEM><CODEROUTINE>index(item)</CODEROUTINE>: return the index of the first occurrence of the value <CODEROUTINE>item</CODEROUTINE></ITEM>
    <ITEM><CODEROUTINE>remove(item)</CODEROUTINE>: remove the first occurrence of the value <CODEROUTINE>item</CODEROUTINE></ITEM>
    <ITEM><CODEROUTINE>sort()</CODEROUTINE>: sort the list</ITEM>
    <ITEM><CODEROUTINE>reverse()</CODEROUTINE>: reverse the list</ITEM>
    <ITEM><CODEROUTINE>count(item)</CODEROUTINE>: return the number of occurrences of the value <CODEROUTINE>item</CODEROUTINE></ITEM>
  </BLIST></ITEM>
  <ITEM><BLIST><TITLE>Functions</TITLE>
    <ITEM><CODEROUTINE>filter(function,l)</CODEROUTINE> return the list of elements <CODEROUTINE>elem</CODEROUTINE> for which <CODEROUTINE>function(elem)</CODEROUTINE> is true</ITEM>
    <ITEM><CODEROUTINE>map(function,l)</CODEROUTINE> return the list of values of <CODEROUTINE>function</CODEROUTINE> called for each element of <CODEROUTINE>l</CODEROUTINE><BR/>
      more than one list can be passed to <CODEROUTINE>map</CODEROUTINE>, in this case, <CODEROUTINE>function</CODEROUTINE> must have the same number of arguments (if a list is shorter than the other one, <CODEROUTINE>function</CODEROUTINE> will be called with the value <CODEROUTINE>None</CODEROUTINE>)<BR/>
      if <CODEROUTINE>None</CODEROUTINE> is passed instead of a function, <CODEROUTINE>map</CODEROUTINE> returns its arguments
      <CODESAMPLE><PROMPT/>(None,[1,2,3,4],[5,6,7])
        [(1, 5), (2, 6), (3, 7), (4, None)]</CODESAMPLE>
    </ITEM>
    <ITEM>reduce(function,l) call function on the two first items, then on the result and the next item…
      <CODESAMPLE><PROMPT/>reduce(lambda x,y:x+y , [1,2,3,4,5,6])<BR/>
        21</CODESAMPLE>
      a third argument can be passed to indicate the starting value (this value will be returned in case of an empty list)
    </ITEM>
  </BLIST></ITEM>
</BLIST>
<BLIST><TITLE><U><B>Tuple</B></U></TITLE>
  <ITEM>a tuple is a number of values separated by a comma<BR/>
    (they may be input with or without parentheses)
    <CODESAMPLE>t=1,2,"azerty"</CODESAMPLE></ITEM>
  <ITEM>tuples support slicing</ITEM>
  <ITEM>an empty tuple is created with the syntax:
    <CODESAMPLE>empty=()</CODESAMPLE></ITEM>
  <ITEM>a singleton tuple is created with an empty comma
    <CODESAMPLE>singleton=1,</CODESAMPLE></ITEM>
  <ITEM>tuple packing
    <CODESAMPLE>t=1,2,3</CODESAMPLE>
    tuple unpacking
    <CODESAMPLE>x,y,z=t</CODESAMPLE></ITEM>
  <ITEM>tuple are immutable: it is not possible ot assign to the individual items of a tuple</ITEM>
</BLIST>
<BLIST><TITLE><U><B>Set</B></U></TITLE>
  <ITEM>Create an empty set
    <CODESAMPLE>s = set()</CODESAMPLE>
  </ITEM>
</BLIST>
<BLIST><TITLE><U><B>Dictionary</B></U></TITLE>
  <ITEM>syntax
    <CODESAMPLE>d={'key1':1234,'key2':5678}<BR/>
      d['key3']=43</CODESAMPLE>
  </ITEM>
  <ITEM>create an empty dictionary
    <CODESAMPLE>d = {}</CODESAMPLE>
  </ITEM>
  <ITEM>keys must be immutable: numbers, strings and tuples containing only numbers, strings and tuples</ITEM>
  <ITEM><CODEROUTINE>del</CODEROUTINE> can be used to delete entries of a dictionary
    <CODESAMPLE>del d['key3']</CODESAMPLE>
  </ITEM>
  <ITEM><BLIST><TITLE>Methods</TITLE>
    <ITEM><CODEROUTINE>keys()</CODEROUTINE>: return the keys of a dictionary</ITEM>
    <ITEM><CODEROUTINE>if key in dic</CODEROUTINE><BR/>
      <CODEROUTINE>dic.has_key(key)</CODEROUTINE>: test if a key is in the dictionary (<CODEROUTINE>has_key</CODEROUTINE> has been removed in Python 3)</ITEM>
    </BLIST></ITEM>
</BLIST>
<BLIST><TITLE><U><B>Control flow</B></U></TITLE>
  <ITEM>Any non-zero integer value is true; zero is false.<BR/>
    For a sequence (string list…, anything with a non-zero length is true, empty sequences are false.</ITEM>
  <ITEM><CODESAMPLE>if x == 1:<BR/>
    <TAB/>print("one")<BR/>
    elif x == 2:<BR/>
    <TAB/>print("two")<BR/>
    elif x == 3:<BR/>
    <TAB/>print("three")<BR/>
    else:<BR/>
    <TAB/>print("other")</CODESAMPLE></ITEM>
  <ITEM><CODEROUTINE>for</CODEROUTINE> loops on a sequence (string or list) content<BR/>
    the <CODEROUTINE>else</CODEROUTINE> clause is executed when the list is exhausted<BR/>
  <CODESAMPLE>a=[1,2,3]<BR/>
    for x in a:<BR/>
    <TAB/>print x<BR/>
    else:<BR/>
    <TAB/>print "finished"</CODESAMPLE></ITEM>
  <ITEM>it is not safe to modify the content of the list being looped on, a copy should be generated</ITEM>
  <ITEM><CODEROUTINE>while</CODEROUTINE> loops as long a condition is true
    <CODESAMPLE>while b &lt; 10:<BR/>
    <TAB/>b = b+1<BR/>
    else:<BR/>
    <TAB/>print "end"</CODESAMPLE></ITEM>
  <ITEM>there is no <CODEROUTINE>do</CODEROUTINE>/<CODEROUTINE>while</CODEROUTINE> statement, instead use
    <CODESAMPLE>while 1:<BR/>
    <TAB/>line = sys.stdin.readline()<BR/>
    <TAB/>if line == "\n":<BR/>
    <TAB/><TAB/>break</CODESAMPLE></ITEM>
  <ITEM>use <CODEROUTINE>range</CODEROUTINE> for iterating over a sequence of numbers<BR/>
    <CODEROUTINE>range(stop)</CODEROUTINE> returns <CODEROUTINE>[0, 1, 2… stop-1]</CODEROUTINE><BR/>
    <CODEROUTINE>range(start, stop)</CODEROUTINE> returns <CODEROUTINE>[start, start+1… stop-1]</CODEROUTINE><BR/>
    <CODEROUTINE>range(start, stop, incr)</CODEROUTINE> returns <CODEROUTINE>[start, start+incr… stop-incr]</CODEROUTINE></ITEM>
  <ITEM><CODEROUTINE>break</CODEROUTINE> breaks out of the smallest enclosing <CODEROUTINE>for</CODEROUTINE> or <CODEROUTINE>while</CODEROUTINE> loop<BR/>
    the <CODEROUTINE>else</CODEROUTINE> clause is not executed</ITEM>
  <ITEM><CODEROUTINE>continue</CODEROUTINE> continues with the next iteration of the loop</ITEM>
  <ITEM><CODEROUTINE>pass</CODEROUTINE> is a noop statement</ITEM>
  <ITEM>matching constants (<CODEROUTINE>_</CODEROUTINE> always macthes
  <CODESAMPLE>match status:<BR/>
    <TAB/>case 400:<BR/>
    <TAB/><TAB/>return "Bad request"<BR/>
    <TAB/>case 401 | 403 | 404:<BR/>
    <TAB/><TAB/>return "Not allowed"<BR/>
    <TAB/>case 404:<BR/>
    <TAB/><TAB/>return "Not found"<BR/>
    <TAB/>case 418:<BR/>
    <TAB/><TAB/>return "I'm a teapot"<BR/>
    <TAB/>case _:<BR/>
    <TAB/><TAB/>return "Something's wrong with the internet"</CODESAMPLE></ITEM>
</BLIST>
<BLIST><TITLE><U><B>Function</B></U></TITLE>
  <ITEM>syntax (the docstring is optional):
    <CODESAMPLE>def myfunction(a,b,c):<BR/>
    <TAB/>"docstring"<BR/>
    <TAB/># … code</CODESAMPLE></ITEM>
  <ITEM>all variable assignments store value in the local symbol table<BR/>
    variable references are looked in the local symbol table, then in the global symbol table and, at last, in the table of built-in names</ITEM>
  <ITEM>parameters are passed by reference</ITEM>
  <ITEM>function references can be stored in variables
    <CODEROUTINE>f=myfunction</CODEROUTINE></ITEM>
  <ITEM><CODEROUTINE>return</CODEROUTINE> returns the <CODEROUTINE>None</CODEROUTINE> value</ITEM>
  <ITEM><CODEROUTINE>return s</CODEROUTINE> returns the <CODEROUTINE>s</CODEROUTINE> value</ITEM>
  <ITEM>default argument values can be used, they are evaluated only once
    <CODESAMPLE>def f(a,l=[]):<BR/>
    <TAB/>l.append(a)<BR/>
    <TAB/>return l</CODESAMPLE>
    <CODEROUTINE>print f(1)</CODEROUTINE> prints <CODEROUTINE>[1]</CODEROUTINE><BR/>
    <CODEROUTINE>print f(2)</CODEROUTINE> prints <CODEROUTINE>[1,2]</CODEROUTINE><BR/>
    <CODEROUTINE>print f(3)</CODEROUTINE> prints <CODEROUTINE>[1,2,3]</CODEROUTINE><BR/>
    to avoid this:
    <CODESAMPLE>def f(a,l=None)<BR/>
    <TAB/>if l is None:<BR/>
    <TAB/><TAB/>l=[]<BR/>
    <TAB/>l.append(a)<BR/>
    <TAB/>return l</CODESAMPLE></ITEM>
  <ITEM>parameters can be passed by keywords
    <CODESAMPLE>def foobar(a,b,c,d):<BR/>
    <TAB/>#…<BR/>
    foobar(0,1,d=4,c=3)</CODESAMPLE></ITEM>
  <ITEM><CODEROUTINE>*name</CODEROUTINE> can be used to get an arbitrary number of positional arguments<BR/>
    <CODEROUTINE>**name</CODEROUTINE> can be used to get an arbitrary number of keyword arguments
    <CODESAMPLE>def quux(*a,**b):<BR/>
    <TAB/>for arg in a: print arg<BR/>
    <TAB/>for kw in b.keys(): print(kw,':',b[kw])</CODESAMPLE></ITEM>
  <ITEM><CODEROUTINE>lambda</CODEROUTINE> can be used to create anonymous functions<BR/>
    they are restricted to a single expression
    <CODESAMPLE>lambda a,b:a+b</CODESAMPLE>
    another example using a default argument value
    <CODESAMPLE>def make_incrementator(n)<BR/>
    <TAB/>return lambda x,incr=n:x+incr</CODESAMPLE></ITEM>
</BLIST>
<BLIST><TITLE><U><B>Modules</B></U></TITLE>
  <ITEM>a module is a file containing Python definitions and statements<BR/>
    the statements are executed the first time the module is imported</ITEM>
  <ITEM>syntax to import a module
    <CODESAMPLE>&gt;&gt;&gt; import mymod<BR/>
    mymod.myfunc(2)</CODESAMPLE></ITEM>
  <ITEM>symbols of the imported module can be declared in the importing module's symbol table<BR/>
    <CODEROUTINE>from mymod import myfunc, myfunc2</CODEROUTINE><BR/>
    all symbols (except those beginning by an underscore) can be declared in the importing module's symbol table<BR/>
    <CODEROUTINE>from mymod import *</CODEROUTINE></ITEM>
  <ITEM>reload a module
    <CODEROUTINE>reload(mymod)</CODEROUTINE></ITEM>
  <ITEM>inside a module, its name is defined in <CODEROUTINE>__name__</CODEROUTINE></ITEM>
  <ITEM><CODEROUTINE>sys.builtin_module_names</CODEROUTINE> lists the modules compiled in the interpreter</ITEM>
  <ITEM><BLIST><TITLE>Module path</TITLE>
    <ITEM>modules are looked for in the directories listed by <CODEROUTINE>sys.path</CODEROUTINE> (which is initially defined by the environment variable <CODEROUTINE>$PYTHONPATH</CODEROUTINE>)</ITEM>
    <ITEM>append a new directory to the path: <CODEROUTINE>sys.path.append('C:\\windows\desktop')</CODEROUTINE></ITEM>
    </BLIST></ITEM>
  <ITEM><CODEROUTINE>dir</CODEROUTINE> returns a list of the names defined in a module<BR/>
    <CODEROUTINE>dir(mymod)</CODEROUTINE></ITEM>
  <ITEM><CODEROUTINE>__builtin__</CODEROUTINE> is the standard module</ITEM>
</BLIST>
<BLIST><TITLE><U><B>Packages</B></U></TITLE>
  <ITEM>packages are structured as directories containing the file <CODEROUTINE>__init__.py</CODEROUTINE> (possibly empty) and other files being modules</ITEM>
  <ITEM>a package can also contain subdirectories (i.e. subpackages)</ITEM>
  <ITEM><CODEROUTINE>__init__.py</CODEROUTINE> can define <CODEROUTINE>__all__.py</CODEROUTINE> which is the list of the modules which should be imported when the syntax <CODEROUTINE>from mypackageimport *</CODEROUTINE> is used.</ITEM>
</BLIST>
<BLIST><TITLE><U><B>Classes</B></U></TITLE>
  <ITEM>the definition of a class starts with the declaration <CODEROUTINE>class:</CODEROUTINE></ITEM>
  <ITEM>the initialisation method is <CODEROUTINE>__init__</CODEROUTINE>
    <CODESAMPLE>class Complex:<BR/>
    <TAB/>def __init__(self, realpart, imagpart):<BR/>
    <TAB/><TAB/>self.r = realpart<BR/>
    <TAB/><TAB/>self.i = imagpart</CODESAMPLE></ITEM>
</BLIST>
<BLIST><TITLE><U><B>Objects</B></U></TITLE>
<ITEM><CODEROUTINE>is</CODEROUTINE> test if two objects are the same</ITEM>
  <ITEM><CODEROUTINE>is not</CODEROUTINE> test if two objects are not the same</ITEM>
  <ITEM><CODEROUTINE>id()</CODEROUTINE> return an integer representing the identity of the object (currently implemented as its address)</ITEM>
  <ITEM><CODEROUTINE>type()</CODEROUTINE> return the type of an object</ITEM>
</BLIST>
<BLIST><TITLE><U><B>Exceptions</B></U></TITLE>
  <ITEM>Use <CODEROUTINE>try</CODEROUTINE> to declare the temptative code block and <CODEROUTINE>except</CODEROUTINE> to catch the exception.
  <CODESAMPLE>try:<BR/>
    <TAB/>…<BR/>
    except ValueError:<BR/>
    <TAB/>…</CODESAMPLE>
  </ITEM>
  <ITEM>It is possible to have several exceptions with the same handler and several handlers with the same <CODEROUTINE>try</CODEROUTINE> clause.
    <CODESAMPLE>try:<BR/>
    <TAB/>…<BR/>
    except (RuntimeError, TypeError, NameError):<BR/>
    <TAB/>…<BR/>
    except ValueError:<BR/>
    <TAB/>…</CODESAMPLE>
  </ITEM>
  <ITEM>A final <CODEROUTINE>except</CODEROUTINE> handler will catch all exceptions.
    <CODESAMPLE>try:<BR/>
    <TAB/>…<BR/>
    except (RuntimeError, TypeError, NameError):<BR/>
    <TAB/>…<BR/>
    except:<BR/>
    <TAB/>…</CODESAMPLE>
  </ITEM>
  <ITEM>An <CODEROUTINE>else</CODEROUTINE> clause may be added after the exception handlers, it will be executed anytime no exception occurred.
    <CODESAMPLE>try:<BR/>
    <TAB/>…<BR/>
    except (RuntimeError, TypeError, NameError):<BR/>
    <TAB/>…<BR/>
    else:<BR/>
    <TAB/>…</CODESAMPLE>
  </ITEM>
  <ITEM>It is possible to retrieve the exception details by adding a variable name after the exception list.
    <CODESAMPLE>try:<BR/>
    <TAB/>…<BR/>
    except IOError, (errno, strerror):<BR/>
    <TAB/>…<BR/>
    except ZeroDivisionError, detail:<BR/>
    <TAB/>…</CODESAMPLE>
  </ITEM>
  <ITEM>A <CODEROUTINE>finally</CODEROUTINE> block can be used instead of <CODEROUTINE>except</CODEROUTINE> handlers: it will be always executed, but if an exception occurred, it will be reraised after this execution.
    <CODESAMPLE>try:<BR/>
    <TAB/>…<BR/>
    finally:<BR/>
    <TAB/>…</CODESAMPLE>
  </ITEM>
  <ITEM><CODEROUTINE>raise</CODEROUTINE> can be used to raise an exception (the argument is optional).
    <CODESAMPLE>raise NameError, 'HiThere'</CODESAMPLE>
  </ITEM>
  <ITEM><CODEROUTINE>raise</CODEROUTINE> with no argument reraise the current exception.
  </ITEM>
</BLIST>
<BLIST><TITLE><U><B><CODEROUTINE>pip</CODEROUTINE></B></U></TITLE>
  <ITEM>install a package
    <CODESAMPLE>pip install &lt;package&gt;</CODESAMPLE>
  </ITEM>
  <ITEM>install the packages defined in a <CODEFILENAME>requirements.txt</CODEFILENAME> file
    <CODESAMPLE>pip install -r requirements.txt</CODESAMPLE>
  </ITEM>
  <ITEM>upgrade a package
    <CODESAMPLE>pip install --upgrade &lt;package&gt;</CODESAMPLE>
  </ITEM>
  <ITEM>install a package from the default branch of a Git repository
    <CODESAMPLE>pip install git+https://gitlab.com/opentestfactory/agent</CODESAMPLE>
    The version (commit ID) is available in <CODEFILENAME>/c/Users/lmazure/AppData/Local/Programs/Python/Python39/lib/site-packages/opentf_agent-*.dist-info/direct_url.json</CODEFILENAME>.<BR/>
    See <X><T>https://packaging.python.org/en/latest/specifications/direct-url/</T><A>https://packaging.python.org/en/latest/specifications/direct-url/</A><L>en</L><F>HTML</F></X>.
  </ITEM>
  <ITEM>install a package from a given branch of a Git repository
    <CODESAMPLE>pip install git+https://gitlab.com/opentestfactory/agent@rel-1.3.1</CODESAMPLE>
  </ITEM>
  <ITEM>list the installed packages
    <CODESAMPLE>pip list</CODESAMPLE>
  </ITEM>
  <ITEM>list the out-of-date installed packages
    <CODESAMPLE>pip list -o</CODESAMPLE>
    <CODESAMPLE>pip list --outdated</CODESAMPLE>
  </ITEM>
  <ITEM>do not list globally-installed packages
    <CODESAMPLE>pip list -l</CODESAMPLE>
    <CODESAMPLE>pip list --local</CODESAMPLE>
  </ITEM>
</BLIST></CONTENT>
<X><T>links</T><A>../links/python.html</A><L>en</L><F>HTML</F></X>
</PAGE>