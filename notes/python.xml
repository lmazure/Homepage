<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="../css/strict.xsl"?>
<PAGE xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../css/schema.xsd" xml:lang="en">
<TITLE>Python</TITLE>
<PATH>notes/python.xml</PATH>
<DATE><YEAR>2023</YEAR><MONTH>10</MONTH><DAY>2</DAY></DATE>
<CONTENT>
<BLIST><TITLE><U><B>Command line</B></U></TITLE>
  <ITEM>to avoid fucking problems when printing non-BMP characters to the console
    <CODESAMPLE><PROMPT/>python -X utf8 foo.py</CODESAMPLE>
</ITEM>
</BLIST>
<BLIST><TITLE><U><B>Syntax</B></U></TITLE>
  <ITEM>comment starts with <CODEROUTINE>#</CODEROUTINE> and extends to the end of the line</ITEM>
  <ITEM>multiple assignment<BR/>
    <CODEROUTINE>a,b=0,1</CODEROUTINE><BR/>
    <CODEROUTINE>a,b=b,a+b</CODEROUTINE></ITEM>
  <ITEM><CODEROUTINE>del</CODEROUTINE> can be used to delete a variable<BR/>
    <CODEROUTINE>del a</CODEROUTINE></ITEM>
  <ITEM><CODEROUTINE>in</CODEROUTINE> test if a value is in a sequence</ITEM>
  <ITEM><CODEROUTINE>not in</CODEROUTINE> test if a value is not in a sequence</ITEM>
  <ITEM><CODEROUTINE>and</CODEROUTINE>, <CODEROUTINE>or</CODEROUTINE>, and <CODEROUTINE>not</CODEROUTINE> are boolean operators<BR/>
    <CODEROUTINE>and</CODEROUTINE> and <CODEROUTINE>or</CODEROUTINE> perform a shortcut evaluation<BR/>
    <CODESAMPLE>&gt;&gt;&gt; print '' or 'a' or 'b'<BR/>
      a</CODESAMPLE></ITEM>
  <ITEM>floor division: division that rounds to nearest integer (not floor!)
    <CODESAMPLE>a = (-11) // 4 # -3</CODESAMPLE>
  </ITEM>
  <ITEM>power
    <CODESAMPLE>a = 3 ** 4 # 81</CODESAMPLE>
  </ITEM>
  <ITEM>in interactive mode, <CODEROUTINE>_</CODEROUTINE> is a read-only variable containing the last printed expression</ITEM>
  <ITEM>exit<BR/>
    <CODESAMPLE>import sys<BR/>
      sys.exit()</CODESAMPLE></ITEM>
</BLIST>
<BLIST><TITLE><U><B>Complex</B></U></TITLE>
  <ITEM>a complex can be created by using <CODEROUTINE>j</CODEROUTINE> or <CODEROUTINE>J</CODEROUTINE> to indicate the complex part<BR/>
    <CODEROUTINE>1+2j</CODEROUTINE> or with the complex function <CODEROUTINE>complex(1,2)</CODEROUTINE></ITEM>
  <ITEM><CODEROUTINE>real</CODEROUTINE> and <CODEROUTINE>imag</CODEROUTINE> can be used to retrieve the real and imaginary parts of a complex<BR/>
  <CODESAMPLE>a=1.5+0.5j<BR/>
    a.real<BR/>
    a.imag</CODESAMPLE></ITEM>
</BLIST>
<BLIST><TITLE><U><B>Strings</B></U></TITLE>
  <ITEM>strings literals can be enclosed in single or double quotes<BR/>
    <CODEROUTINE>"foobar 'n \" quux"</CODEROUTINE><BR/>
    <CODEROUTINE>'foobar \'n" quux'</CODEROUTINE></ITEM>
  <ITEM>new line can be escaped by \<BR/>
    <CODESAMPLE>"first line \n\<BR/>
      second line"</CODESAMPLE></ITEM>
  <ITEM>triple single or double quotes can also be used to create strings containing new lines<BR/>
    <CODESAMPLE>"""first line<BR/>
      second line"""</CODESAMPLE></ITEM>
  <ITEM>string literals are automatically concatenated</ITEM>
  <ITEM><CODEROUTINE>"foo" "bar"</CODEROUTINE></ITEM>
  <ITEM>+ append strings<BR/>
    <CODEROUTINE>"foo"+"bar"</CODEROUTINE></ITEM>
  <ITEM><CODEROUTINE>*</CODEROUTINE> repeats strings<BR/>
    <CODEROUTINE>"foo"*5</CODEROUTINE> is <CODEROUTINE>"foofoofoofoofoo"</CODEROUTINE></ITEM>
  <ITEM>slices<BR/>
    <CODEROUTINE>str[4]</CODEROUTINE> fifth letter<BR/>
    <CODEROUTINE>str[2:4]</CODEROUTINE> third and fourth letters<BR/>
    <CODEROUTINE>str[:2]</CODEROUTINE> first two characters<BR/>
    <CODEROUTINE>str[2:]</CODEROUTINE> all but first two characters<BR/>
    <CODEROUTINE>str[-1]</CODEROUTINE> last character<BR/>
    <CODEROUTINE>str[-2]</CODEROUTINE> last but one character<BR/>
    <CODEROUTINE>str[-2:]</CODEROUTINE> last two characters<BR/>
    <CODEROUTINE>str[:-2]</CODEROUTINE> all but the last two characters<BR/>
    slices are immutable</ITEM>
  <ITEM>using a too large index generates an error
    <CODESAMPLE>&gt;&gt;&gt; "language"[42]<BR/>
      Traceback (most recent call last):<BR/>
      File "&lt;stdin&gt;", line 1, in &lt;module&gt;<BR/>
      IndexError: string index out of range</CODESAMPLE>
    but not for slices
  <CODESAMPLE>&gt;&gt;&gt; "language"[3:42]<BR/>
      'guage'</CODESAMPLE></ITEM>
  <ITEM><CODEROUTINE>len</CODEROUTINE> return the length a string<BR/>
    <CODEROUTINE>len(str)</CODEROUTINE></ITEM>
  <ITEM><BLIST><TITLE>String Interpolation</TITLE>
    <ITEM>string modulo operator
      <CODESAMPLE>myVal1 = 10.1<BR/>
        myVal2 = 2.2<BR/>
        print("The sum of %s and %s is %s." %(my_val_1, my_val_2, my_val_1+my_val_2))</CODESAMPLE></ITEM>
    <ITEM><CODEROUTINE>String .format()</CODEROUTINE><BR/>
      <CODESAMPLE>'My name is {name} and I am {age} years old'.format(name= 'Frida', age=114)</CODESAMPLE></ITEM>
    <ITEM><BLIST><TITLE>F-strings</TITLE>
      <ITEM><CODESAMPLE>f'The date today is {datetime.datetime.now():%B %d, %Y}'</CODESAMPLE></ITEM>
      <ITEM>use <CODEROUTINE>{{</CODEROUTINE> to insert a <CODEROUTINE>{</CODEROUTINE> and <CODEROUTINE>}}</CODEROUTINE> to insert a <CODEROUTINE>}</CODEROUTINE></ITEM>
    </BLIST></ITEM>
    <ITEM>template strings
      <CODESAMPLE>from string import Template<BR/>
        greeting = Template('Welcome, $name')<BR/>
        greeting.substitute(name='Frida!')</CODESAMPLE></ITEM>
  </BLIST></ITEM>
</BLIST>
<BLIST><TITLE><U><B>Sequences</B></U></TITLE>
  <ITEM>sequences can be lists, strings or tuples</ITEM>
</BLIST>
<BLIST><TITLE><U><B>List</B></U></TITLE>
  <ITEM>lists can mix types
    <CODESAMPLE>a = ['foo', 69, 'bar']</CODESAMPLE>
  </ITEM>
  <ITEM>lists support slices (these ones are mutable and can even be used to change the size of the list)<BR/>
    <CODEROUTINE>a[0:2]</CODEROUTINE>: remove the two first elements of the list<BR/>
    <CODEROUTINE>a[:0] = a</CODEROUTINE>: insert a copy ot itself at the beginning of the list
  </ITEM>
  <ITEM>All slice operations return a new list containing the requested elements. So <CODEROUTINE>a[:]</CODEROUTINE> returns a shallow copy of <CODEROUTINE>a</CODEROUTINE>.</ITEM>
  <ITEM><CODEROUTINE>del</CODEROUTINE> can be used to remove elements in a list
    <CODESAMPLE>del a[2:4]</CODESAMPLE>
  </ITEM>
  <ITEM>we can do the same with
    <CODESAMPLE>a[2:4] = []</CODESAMPLE>
  </ITEM>
  <ITEM>lists can be concatenated with <CODEROUTINE>+</CODEROUTINE>
    <CODESAMPLE>&gt;&gt;&gt; [ 1, 2 ] + [ 3, 4, 5]<BR/>
      [1, 2, 3, 4, 5] </CODESAMPLE>
  </ITEM>
  <ITEM><CODEROUTINE>len</CODEROUTINE>: return the number of elements of a list</ITEM>
  <ITEM>lists can be nested
    <CODESAMPLE>q = [45, 3]<BR/>
      p = [0, q, 14]</CODESAMPLE>
  </ITEM>
  <ITEM>list unpacking
    <CODESAMPLE>a = [1, 2, 3, 4]<BR/>
      [a1, a2, a3, a4] = a</CODESAMPLE>
  </ITEM>
  <ITEM>test if an element is in a list
    <CODESAMPLE>item in List</CODESAMPLE>
  </ITEM>
  <ITEM>test if a list is empty
    <CODESAMPLE>if my_list:<BR/>
      <TAB/>print("list is not empty")<BR/>
      else:<BR/>
      <TAB/>print("list is empty")</CODESAMPLE>
  </ITEM>
  <ITEM>join the members of a list (as a string)
    <CODESAMPLE>vowels = ["a", "e", "i", "o", "u"]<BR/>
      vowelsCSV = ",".join(vowels)<BR/>
      print("Vowels are = ", vowelsCSV)</CODESAMPLE>
  </ITEM>
  <ITEM><BLIST><TITLE>Methods</TITLE>
    <ITEM><CODEROUTINE>insert(pos,item)</CODEROUTINE>: insert an item at a given position</ITEM>
    <ITEM><CODEROUTINE>append(elem)</CODEROUTINE>: append an item at the list end</ITEM>
    <ITEM><CODEROUTINE>pop(i)</CODEROUTINE>: remove the item at the given position in the list and return it</ITEM>
    <ITEM><CODEROUTINE>pop()</CODEROUTINE>: remove the last item and return it</ITEM>
    <ITEM><CODEROUTINE>index(item)</CODEROUTINE>: return the index of the first occurrence of the value <CODEROUTINE>item</CODEROUTINE></ITEM>
    <ITEM><CODEROUTINE>remove(item)</CODEROUTINE>: remove the first occurrence of the value <CODEROUTINE>item</CODEROUTINE></ITEM>
    <ITEM><CODEROUTINE>sort()</CODEROUTINE>: sort the list</ITEM>
    <ITEM><CODEROUTINE>reverse()</CODEROUTINE>: reverse the list</ITEM>
    <ITEM><CODEROUTINE>count(item)</CODEROUTINE>: return the number of occurrences of the value <CODEROUTINE>item</CODEROUTINE></ITEM>
  </BLIST></ITEM>
  <ITEM><BLIST><TITLE>Functions</TITLE>
    <ITEM><CODEROUTINE>filter(function,l)</CODEROUTINE> return the list of elements <CODEROUTINE>elem</CODEROUTINE> for which <CODEROUTINE>function(elem)</CODEROUTINE> is true</ITEM>
    <ITEM><CODEROUTINE>map(function,l)</CODEROUTINE> return the list of values of <CODEROUTINE>function</CODEROUTINE> called for each element of <CODEROUTINE>l</CODEROUTINE><BR/>
      more than one list can be passed to <CODEROUTINE>map</CODEROUTINE>, in this case, <CODEROUTINE>function</CODEROUTINE> must have the same number of arguments (if a list is shorter than the other one, <CODEROUTINE>function</CODEROUTINE> will be called with the value <CODEROUTINE>None</CODEROUTINE>)<BR/>
      if <CODEROUTINE>None</CODEROUTINE> is passed instead of a function, <CODEROUTINE>map</CODEROUTINE> returns its arguments
      <CODESAMPLE><PROMPT/>(None,[1,2,3,4],[5,6,7])
        [(1, 5), (2, 6), (3, 7), (4, None)]</CODESAMPLE>
    </ITEM>
    <ITEM><CODEROUTINE>reduce(function,l)</CODEROUTINE> call function on the two first items, then on the result and the next itemâ€¦
      <CODESAMPLE><PROMPT/>reduce(lambda x,y:x+y , [1,2,3,4,5,6])<BR/>
        21</CODESAMPLE>
      a third argument can be passed to indicate the starting value (this value will be returned in case of an empty list)
    </ITEM>
  </BLIST></ITEM>
</BLIST>
<BLIST><TITLE><U><B>Tuple</B></U></TITLE>
  <ITEM>a tuple is a number of values separated by a comma<BR/>
    (they may be input with or without parentheses)
    <CODESAMPLE>t=1,2,"azerty"</CODESAMPLE></ITEM>
  <ITEM>tuples support slicing</ITEM>
  <ITEM>an empty tuple is created with the syntax:
    <CODESAMPLE>empty=()</CODESAMPLE></ITEM>
  <ITEM>a singleton tuple is created with an empty comma
    <CODESAMPLE>singleton=1,</CODESAMPLE></ITEM>
  <ITEM>tuple packing
    <CODESAMPLE>t=1,2,3</CODESAMPLE>
    tuple unpacking
    <CODESAMPLE>x,y,z=t</CODESAMPLE></ITEM>
  <ITEM>tuple are immutable: it is not possible ot assign to the individual items of a tuple</ITEM>
</BLIST>
<BLIST><TITLE><U><B>Set</B></U></TITLE>
  <ITEM>Create an empty set
    <CODESAMPLE>s = set()</CODESAMPLE>
  </ITEM>
</BLIST>
<BLIST><TITLE><U><B>Dictionary</B></U></TITLE>
  <ITEM>syntax
    <CODESAMPLE>d={'key1':1234,'key2':5678}<BR/>
      d['key3']=43</CODESAMPLE>
  </ITEM>
  <ITEM>create an empty dictionary
    <CODESAMPLE>d = {}</CODESAMPLE>
  </ITEM>
  <ITEM>keys must be immutable: numbers, strings and tuples containing only numbers, strings and tuples</ITEM>
  <ITEM><CODEROUTINE>del</CODEROUTINE> can be used to delete entries of a dictionary, it raises a <CODEROUTINE>KeyErro</CODEROUTINE>r if rhe key is not in the map
    <CODESAMPLE>del d['key3']</CODESAMPLE>
  </ITEM>
  <ITEM><BLIST><TITLE>Methods</TITLE>
    <ITEM><CODEROUTINE>key in d</CODEROUTINE>: return <CODEROUTINE>True</CODEROUTINE> if d has a key key, else <CODEROUTINE>False</CODEROUTINE></ITEM>
    <ITEM><CODEROUTINE>key not in d</CODEROUTINE>: equivalent to <CODEROUTINE>not key in d</CODEROUTINE></ITEM>
    <ITEM><CODEROUTINE>iter(d)</CODEROUTINE>: return an iterator over the keys of the dictionary, this is a shortcut for <CODEROUTINE>iter(d.keys())</CODEROUTINE></ITEM>
    <ITEM><CODEROUTINE>clear()</CODEROUTINE>: remove all items from the dictionary</ITEM>
    <ITEM><CODEROUTINE>copy()</CODEROUTINE>: return a shallow copy of the dictionary.</ITEM>
    <ITEM><CODEROUTINE>classmethod fromkeys(iterable[, value])</CODEROUTINE>: create a new dictionary with keys from <CODEROUTINE>iterable</CODEROUTINE> and values set to <CODEROUTINE>value</CODEROUTINE></ITEM>
    <ITEM><CODEROUTINE>get(key[, default])</CODEROUTINE>: return the value for key if <CODEROUTINE>key</CODEROUTINE> is in the dictionary, else <CODEROUTINE>default</CODEROUTINE>. If default is not given, it defaults to <CODEROUTINE>None</CODEROUTINE>, so that this method never raises a <CODEROUTINE>KeyError</CODEROUTINE></ITEM>
    <ITEM><CODEROUTINE>items()</CODEROUTINE>: return a new view of the dictionaryâ€™s items (<CODEROUTINE>(key, value)</CODEROUTINE> pairs)</ITEM>
    <ITEM><CODEROUTINE>keys()</CODEROUTINE>: return a new view of the dictionaryâ€™s keys</ITEM>
    <ITEM><CODEROUTINE>pop(key[, default])</CODEROUTINE>: if <CODEROUTINE>key</CODEROUTINE> is in the dictionary, remove it and return its value, else return <CODEROUTINE>default</CODEROUTINE>. If <CODEROUTINE>default</CODEROUTINE> is not given and key is not in the dictionary, a <CODEROUTINE>KeyError</CODEROUTINE> is raised.</ITEM>
    <ITEM><CODEROUTINE>popitem()</CODEROUTINE>: remove and return a <CODEROUTINE>(key, value)</CODEROUTINE> pair from the dictionary. Pairs are returned in LIFO order. If the dictionary is empty, calling <CODEROUTINE>popitem()</CODEROUTINE> raises a <CODEROUTINE>KeyError</CODEROUTINE>.</ITEM>
    <ITEM><CODEROUTINE>reversed(d)</CODEROUTINE>: return a reverse iterator over the keys of the dictionary. This is a shortcut for <CODEROUTINE>reversed(d.keys()).</CODEROUTINE></ITEM>
    <ITEM><CODEROUTINE>setdefault(key[, default])</CODEROUTINE>: if <CODEROUTINE>key</CODEROUTINE> is in the dictionary, return its value. If not, insert <CODEROUTINE>key</CODEROUTINE> with a value of <CODEROUTINE>default</CODEROUTINE> and return <CODEROUTINE>default</CODEROUTINE>. <CODEROUTINE>default</CODEROUTINE> defaults to <CODEROUTINE>None</CODEROUTINE>.</ITEM>
    <ITEM><CODEROUTINE>update([other])</CODEROUTINE>: update the dictionary with the key/value pairs from other, overwriting existing keys. Return <CODEROUTINE>None</CODEROUTINE>.  <CODEROUTINE>update()</CODEROUTINE> accepts either another dictionary object or an iterable of key/value pairs (as tuples or other iterables of length two). If keyword arguments are specified, the dictionary is then updated with those key/value pairs: <CODEROUTINE>d.update(red=1, blue=2)</CODEROUTINE>.</ITEM>
    <ITEM><CODEROUTINE>values()</CODEROUTINE>: return a new view of the dictionaryâ€™s values.</ITEM>
    <ITEM><CODEROUTINE>d | other</CODEROUTINE>: create a new dictionary with the merged keys and values of <CODEROUTINE>d</CODEROUTINE> and <CODEROUTINE>other</CODEROUTINE>, which must both be dictionaries. The values of <CODEROUTINE>other</CODEROUTINE> take priority when <CODEROUTINE>d</CODEROUTINE> and <CODEROUTINE>other</CODEROUTINE> share keys.</ITEM>
    <ITEM><CODEROUTINE>d |= other</CODEROUTINE>: update the dictionary d with keys and values from <CODEROUTINE>other</CODEROUTINE>, which may be either a mapping or an iterable of key/value pairs. The values of <CODEROUTINE>other</CODEROUTINE> take priority when d and other share keys.</ITEM>
    <ITEM>The objects returned by <CODEROUTINE>dict.keys()</CODEROUTINE>, <CODEROUTINE>dict.values</CODEROUTINE>(), and <CODEROUTINE>dict.items(</CODEROUTINE>) are view objects. They provide a dynamic view on the dictionaryâ€™s entries, which means that when the dictionary changes, the view reflects these changes.<BR/>
      Dictionary views can be iterated over to yield their respective data, and support membership tests:
      <BLIST>
        <ITEM><CODEROUTINE>len(dictview)</CODEROUTINE>: return the number of entries in the dictionary</ITEM>
        <ITEM><CODEROUTINE>iter(dictview)</CODEROUTINE>: return an iterator over the keys, values or items (represented as tuples of (key, value)) in the dictionary</ITEM>
        <ITEM><CODEROUTINE>x in dictview</CODEROUTINE>: return <CODEROUTINE>True</CODEROUTINE> if <CODEROUTINE>x</CODEROUTINE> is in the underlying dictionaryâ€™s keys, values or items (in the latter case, x should be a <CODEROUTINE>(key, value)</CODEROUTINE> tuple)</ITEM>
        <ITEM><CODEROUTINE>reversed(dictview)</CODEROUTINE>: return a reverse iterator over the keys, values or items of the dictionary. The view will be iterated in reverse order of the insertion.</ITEM>
        <ITEM><CODEROUTINE>dictview.mapping</CODEROUTINE>: return a <CODEROUTINE>types.MappingProxyType</CODEROUTINE> that wraps the original dictionary to which the view refers</ITEM>
    </BLIST></ITEM>
  </BLIST></ITEM>
</BLIST>
<BLIST><TITLE><U><B>Control flow</B></U></TITLE>
  <ITEM>Any non-zero integer value is true; zero is false.<BR/>
    For a sequence (string listâ€¦, anything with a non-zero length is true, empty sequences are false.</ITEM>
  <ITEM><CODESAMPLE>if x == 1:<BR/>
    <TAB/>print("one")<BR/>
    elif x == 2:<BR/>
    <TAB/>print("two")<BR/>
    elif x == 3:<BR/>
    <TAB/>print("three")<BR/>
    else:<BR/>
    <TAB/>print("other")</CODESAMPLE></ITEM>
  <ITEM><CODEROUTINE>for</CODEROUTINE> loops on a sequence (string or list) content<BR/>
    the <CODEROUTINE>else</CODEROUTINE> clause is executed when the list is exhausted<BR/>
  <CODESAMPLE>a=[1,2,3]<BR/>
    for x in a:<BR/>
    <TAB/>print x<BR/>
    else:<BR/>
    <TAB/>print "finished"</CODESAMPLE></ITEM>
  <ITEM>it is not safe to modify the content of the list being looped on, a copy should be generated</ITEM>
  <ITEM><CODEROUTINE>while</CODEROUTINE> loops as long a condition is true
    <CODESAMPLE>while b &lt; 10:<BR/>
    <TAB/>b = b+1<BR/>
    else:<BR/>
    <TAB/>print "end"</CODESAMPLE></ITEM>
  <ITEM>there is no <CODEROUTINE>do</CODEROUTINE>/<CODEROUTINE>while</CODEROUTINE> statement, instead use
    <CODESAMPLE>while 1:<BR/>
    <TAB/>line = sys.stdin.readline()<BR/>
    <TAB/>if line == "\n":<BR/>
    <TAB/><TAB/>break</CODESAMPLE></ITEM>
  <ITEM>use <CODEROUTINE>range</CODEROUTINE> for iterating over a sequence of numbers<BR/>
    <CODEROUTINE>range(stop)</CODEROUTINE> returns <CODEROUTINE>[0, 1, 2â€¦ stop-1]</CODEROUTINE><BR/>
    <CODEROUTINE>range(start, stop)</CODEROUTINE> returns <CODEROUTINE>[start, start+1â€¦ stop-1]</CODEROUTINE><BR/>
    <CODEROUTINE>range(start, stop, incr)</CODEROUTINE> returns <CODEROUTINE>[start, start+incrâ€¦ stop-incr]</CODEROUTINE></ITEM>
  <ITEM><CODEROUTINE>break</CODEROUTINE> breaks out of the smallest enclosing <CODEROUTINE>for</CODEROUTINE> or <CODEROUTINE>while</CODEROUTINE> loop<BR/>
    the <CODEROUTINE>else</CODEROUTINE> clause is not executed</ITEM>
  <ITEM><CODEROUTINE>continue</CODEROUTINE> continues with the next iteration of the loop</ITEM>
  <ITEM><CODEROUTINE>pass</CODEROUTINE> is a noop statement</ITEM>
  <ITEM>matching constants (<CODEROUTINE>_</CODEROUTINE>) always matches
  <CODESAMPLE>match status:<BR/>
    <TAB/>case 400:<BR/>
    <TAB/><TAB/>return "Bad request"<BR/>
    <TAB/>case 401 | 403 | 404:<BR/>
    <TAB/><TAB/>return "Not allowed"<BR/>
    <TAB/>case 404:<BR/>
    <TAB/><TAB/>return "Not found"<BR/>
    <TAB/>case 418:<BR/>
    <TAB/><TAB/>return "I'm a teapot"<BR/>
    <TAB/>case _:<BR/>
    <TAB/><TAB/>return "Something's wrong with the internet"</CODESAMPLE></ITEM>
</BLIST>
<BLIST><TITLE><U><B>Function</B></U></TITLE>
  <ITEM>syntax (the docstring is optional):
    <CODESAMPLE>def myfunction(a,b,c):<BR/>
    <TAB/>"docstring"<BR/>
    <TAB/># â€¦ code</CODESAMPLE></ITEM>
  <ITEM>all variable assignments store value in the local symbol table<BR/>
    variable references are looked in the local symbol table, then in the global symbol table and, at last, in the table of built-in names</ITEM>
  <ITEM>parameters are passed by reference</ITEM>
  <ITEM>function references can be stored in variables
    <CODEROUTINE>f=myfunction</CODEROUTINE></ITEM>
  <ITEM><CODEROUTINE>return</CODEROUTINE> returns the <CODEROUTINE>None</CODEROUTINE> value</ITEM>
  <ITEM><CODEROUTINE>return s</CODEROUTINE> returns the <CODEROUTINE>s</CODEROUTINE> value</ITEM>
  <ITEM>default argument values can be used, they are evaluated only once
    <CODESAMPLE>def f(a,l=[]):<BR/>
    <TAB/>l.append(a)<BR/>
    <TAB/>return l</CODESAMPLE>
    <CODEROUTINE>print f(1)</CODEROUTINE> prints <CODEROUTINE>[1]</CODEROUTINE><BR/>
    <CODEROUTINE>print f(2)</CODEROUTINE> prints <CODEROUTINE>[1,2]</CODEROUTINE><BR/>
    <CODEROUTINE>print f(3)</CODEROUTINE> prints <CODEROUTINE>[1,2,3]</CODEROUTINE><BR/>
    to avoid this:
    <CODESAMPLE>def f(a,l=None)<BR/>
    <TAB/>if l is None:<BR/>
    <TAB/><TAB/>l=[]<BR/>
    <TAB/>l.append(a)<BR/>
    <TAB/>return l</CODESAMPLE></ITEM>
  <ITEM>parameters can be passed by keywords
    <CODESAMPLE>def foobar(a,b,c,d):<BR/>
    <TAB/>#â€¦<BR/>
    foobar(0,1,d=4,c=3)</CODESAMPLE></ITEM>
  <ITEM><CODEROUTINE>*name</CODEROUTINE> can be used to get an arbitrary number of positional arguments<BR/>
    <CODEROUTINE>**name</CODEROUTINE> can be used to get an arbitrary number of keyword arguments
    <CODESAMPLE>def quux(*a,**b):<BR/>
    <TAB/>for arg in a: print arg<BR/>
    <TAB/>for kw in b.keys(): print(kw,':',b[kw])</CODESAMPLE></ITEM>
  <ITEM>A function can return a function
    <CODESAMPLE>def curry(func, value):<BR/>
    <TAB/>def f(x):<BR/>
    <TAB/><TAB/>return func(x, value)<BR/>
    <TAB/>return f</CODESAMPLE></ITEM>
  <ITEM><CODEROUTINE>lambda</CODEROUTINE> can be used to create anonymous functions<BR/>
    they are restricted to a single expression
    <CODESAMPLE>lambda a,b:a+b</CODESAMPLE>
    another example using a default argument value
    <CODESAMPLE>def make_incrementator(n)<BR/>
    <TAB/>return lambda x,incr=n:x+incr</CODESAMPLE></ITEM>
</BLIST>
<BLIST><TITLE><U><B>Modules</B></U></TITLE>
  <ITEM>A module is a file containing Python definitions and statements.<BR/>
    The statements are executed the first time the module is imported.</ITEM>
  <ITEM>Syntax to import a module
    <CODESAMPLE>import mymodule<BR/>
    mymod.myfunc(2)</CODESAMPLE></ITEM>
  <ITEM>If the module name is followed by <CODEROUTINE>as</CODEROUTINE>, then the name following <CODEROUTINE>as</CODEROUTINE> is bound directly to the imported module.
    <CODESAMPLE>import mymodule as mydmod</CODESAMPLE></ITEM>
  <ITEM>Symbols of the imported module can be declared in the importing module's symbol table<BR/>
    <CODEROUTINE>from mymod import myfunc, myfunc2</CODEROUTINE><BR/>
    All symbols (except those beginning by an underscore) can be declared in the importing module's symbol table<BR/>
    <CODEROUTINE>from mymod import *</CODEROUTINE></ITEM>
  <ITEM>Reload a module
    <CODEROUTINE>reload(mymod)</CODEROUTINE></ITEM>
  <ITEM>Inside a module, its name is defined in <CODEROUTINE>__name__</CODEROUTINE></ITEM>
  <ITEM><CODEROUTINE>sys.builtin_module_names</CODEROUTINE> lists the modules compiled in the interpreter</ITEM>
  <ITEM>When you run a module with
    <CODESAMPLE>python mymodule.py &lt;arguments&gt;</CODESAMPLE>
    the code in the module will be executed, just as if you imported it, but with <CODEROUTINE>__name__</CODEROUTINE> set to <CODEROUTINE>__main__</CODEROUTINE>. </ITEM>
  <ITEM><BLIST><TITLE>Module path</TITLE>
    <ITEM>modules are looked for in the directories listed by <CODEROUTINE>sys.path</CODEROUTINE> (which is initially defined by the environment variable <CODEROUTINE>$PYTHONPATH</CODEROUTINE>)</ITEM>
    <ITEM>append a new directory to the path: <CODEROUTINE>sys.path.append('C:\\windows\desktop')</CODEROUTINE></ITEM>
    </BLIST></ITEM>
  <ITEM><CODEROUTINE>dir</CODEROUTINE> returns a list of the names defined in a module<BR/>
    <CODEROUTINE>dir(mymod)</CODEROUTINE></ITEM>
  <ITEM><CODEROUTINE>__builtin__</CODEROUTINE> is the standard module</ITEM>
</BLIST>
<BLIST><TITLE><U><B>Packages</B></U></TITLE>
  <ITEM>Packages are structured as directories containing the file <CODEROUTINE>__init__.py</CODEROUTINE> (possibly empty) and other files being modules</ITEM>
  <ITEM>A package can also contain subdirectories (i.e. subpackages)</ITEM>
  <ITEM><CODEROUTINE>__init__.py</CODEROUTINE> can define <CODEROUTINE>__all__</CODEROUTINE> variable which is the list of the modules which should be imported when the syntax <CODEROUTINE>from mypackage import *</CODEROUTINE> is used.</ITEM>
</BLIST>
<BLIST><TITLE><U><B>Classes</B></U></TITLE>
  <ITEM>the definition of a class starts with the declaration <CODEROUTINE>class:</CODEROUTINE></ITEM>
  <ITEM>the initialisation method is <CODEROUTINE>__init__</CODEROUTINE>
    <CODESAMPLE>class Complex:<BR/>
    <TAB/>def __init__(self, realpart, imagpart):<BR/>
    <TAB/><TAB/>self.r = realpart<BR/>
    <TAB/><TAB/>self.i = imagpart</CODESAMPLE></ITEM>
</BLIST>
<BLIST><TITLE><U><B>Objects</B></U></TITLE>
<ITEM><CODEROUTINE>is</CODEROUTINE> test if two objects are the same</ITEM>
  <ITEM><CODEROUTINE>is not</CODEROUTINE> test if two objects are not the same</ITEM>
  <ITEM><CODEROUTINE>id()</CODEROUTINE> return an integer representing the identity of the object (currently implemented as its address)</ITEM>
  <ITEM><CODEROUTINE>type()</CODEROUTINE> return the type of an object</ITEM>
</BLIST>
<BLIST><TITLE><U><B>Exceptions</B></U></TITLE>
  <ITEM><CODEROUTINE>BaseException</CODEROUTINE> is the common base class of all exceptions.<BR/>
    One of its subclasses, <CODEROUTINE>Exception</CODEROUTINE>, is the base class of all the non-fatal exceptions.<BR/>
    Exceptions which are not subclasses of <CODEROUTINE>Exception</CODEROUTINE> are not typically handled, because they are used to indicate that the program should terminate. They include <CODEROUTINE>SystemExit</CODEROUTINE> which is raised by <CODEROUTINE>sys.exit()</CODEROUTINE> and <CODEROUTINE>KeyboardInterrupt</CODEROUTINE> which is raised when a user wishes to interrupt the program.</ITEM>
  <ITEM>Use <CODEROUTINE>try</CODEROUTINE> to declare the tentative code block and <CODEROUTINE>except</CODEROUTINE> to catch the exception.
  <CODESAMPLE>try:<BR/>
    <TAB/>â€¦<BR/>
    except ValueError:<BR/>
    <TAB/>â€¦</CODESAMPLE>
  </ITEM>
  <ITEM>It is possible to have several exceptions with the same handler and several handlers with the same <CODEROUTINE>try</CODEROUTINE> clause.
    <CODESAMPLE>try:<BR/>
    <TAB/>â€¦<BR/>
    except (RuntimeError, TypeError, NameError):<BR/>
    <TAB/>â€¦<BR/>
    except ValueError:<BR/>
    <TAB/>â€¦</CODESAMPLE>
  </ITEM>
  <ITEM>A final <CODEROUTINE>except</CODEROUTINE> handler will catch all exceptions.
    <CODESAMPLE>try:<BR/>
    <TAB/>â€¦<BR/>
    except (RuntimeError, TypeError, NameError):<BR/>
    <TAB/>â€¦<BR/>
    except:<BR/>
    <TAB/>â€¦</CODESAMPLE>
  </ITEM>
  <ITEM>An <CODEROUTINE>else</CODEROUTINE> clause may be added after the exception handlers, it will be executed anytime no exception occurred.
    <CODESAMPLE>try:<BR/>
    <TAB/>â€¦<BR/>
    except (RuntimeError, TypeError, NameError):<BR/>
    <TAB/>â€¦<BR/>
    else:<BR/>
    <TAB/>â€¦</CODESAMPLE>
  </ITEM>
  <ITEM>It is possible to retrieve the exception details by adding a variable name after the exception list.
    <CODESAMPLE>try:<BR/>
    <TAB/>â€¦<BR/>
    except IOError, (errno, strerror):<BR/>
    <TAB/>â€¦<BR/>
    except ZeroDivisionError, detail:<BR/>
    <TAB/>â€¦</CODESAMPLE>
  </ITEM>
  <ITEM>A <CODEROUTINE>finally</CODEROUTINE> block can be used: it will be always executed.
    <CODESAMPLE>try:<BR/>
    <TAB/>â€¦<BR/>
    finally:<BR/>
    <TAB/>â€¦</CODESAMPLE>
    <BLIST>
      <ITEM>If an exception occurs during execution of the <CODEROUTINE>try</CODEROUTINE> clause, the exception may be handled by an <CODEROUTINE>except</CODEROUTINE> clause. If the exception is not handled by an <CODEROUTINE>except</CODEROUTINE> clause, the exception is re-raised after the <CODEROUTINE>finally</CODEROUTINE> clause has been executed.</ITEM>
      <ITEM>An exception could occur during execution of an <CODEROUTINE>except</CODEROUTINE> or <CODEROUTINE>else</CODEROUTINE> clause. Again, the exception is re-raised after the <CODEROUTINE>finally</CODEROUTINE> clause has been executed.</ITEM>
      <ITEM>If the <CODEROUTINE>finally</CODEROUTINE> clause executes a <CODEROUTINE>break</CODEROUTINE>, <CODEROUTINE>continue</CODEROUTINE>, or <CODEROUTINE>return</CODEROUTINE> statement, exceptions are not re-raised.</ITEM>
      <ITEM>If the <CODEROUTINE>try</CODEROUTINE> statement reaches a <CODEROUTINE>break</CODEROUTINE>, <CODEROUTINE>continue</CODEROUTINE>, or <CODEROUTINE>return</CODEROUTINE> statement, the <CODEROUTINE>finally</CODEROUTINE> clause will execute just prior to the <CODEROUTINE>break</CODEROUTINE>, <CODEROUTINE>continue</CODEROUTINE>, or <CODEROUTINE>return</CODEROUTINE> statementâ€™s execution.</ITEM>
      <ITEM>If a <CODEROUTINE>finally</CODEROUTINE> clause includes a <CODEROUTINE>return</CODEROUTINE> statement, the returned value will be the one from the finally clauseâ€™s <CODEROUTINE>return</CODEROUTINE> statement, not the value from the try clauseâ€™s <CODEROUTINE>return</CODEROUTINE> statement.</ITEM>
    </BLIST>
  </ITEM>
  <ITEM><CODEROUTINE>raise</CODEROUTINE> can be used to raise an exception, it is followed by a class (it will be implicitly instantiated by calling its constructor with no arguments) or an instance.
    <CODESAMPLE>raise NameError, 'HiThere'</CODESAMPLE>
  </ITEM>
  <ITEM><CODEROUTINE>raise</CODEROUTINE> with no argument reraises the current exception.</ITEM>
  <ITEM>Exceptions are automatically chained: if an unhandled exception occurs inside an except section, it will have the exception being handled attached to it and included in the error message</ITEM>
  <ITEM>Exceptions can be explicitly chained using <CODEROUTINE>from</CODEROUTINE>
    <CODESAMPLE>try:<BR/>
    <TAB/>func()<BR/>
    except ConnectionError as exc:<BR/>
    <TAB/>raise RuntimeError('Failed to open database') from exc</CODESAMPLE></ITEM>
  <ITEM>Chaining can be disabled using <CODEROUTINE>from None</CODEROUTINE></ITEM>
  <ITEM><CODEROUTINE>add_note</CODEROUTINE> can be used to add some text to an exception
  <CODESAMPLE>try:<BR/>
    <TAB/>raise TypeError('bad type')<BR/>
    except Exception as e:<BR/>
    <TAB/>e.add_note('Add some information')<BR/>
    <TAB/>e.add_note('Add some more information')<BR/>
    <TAB/>raise</CODESAMPLE></ITEM>
  <ITEM>The builtin <CODEROUTINE>ExceptionGroup</CODEROUTINE> wraps a list of exception instances so that they can be raised together. It is an exception itself, so it can be caught like any other exception.
    <CODESAMPLE>def f():<BR/>
    <TAB/>excs = [OSError('error 1'), SystemError('error 2')]<BR/>
    <TAB/>raise ExceptionGroup('there were problems', excs)</CODESAMPLE>
    or
    <CODESAMPLE>excs = []<BR/>
    for test in tests:<BR/>
    <TAB/>try:<BR/>
    <TAB/><TAB/>test.run()<BR/>
    <TAB/>except Exception as e:<BR/>
    <TAB/><TAB/>excs.append(e)<BR/>
    if excs:<BR/>
    <TAB/>raise ExceptionGroup("Test Failures", excs)</CODESAMPLE></ITEM>
    <ITEM>By using <CODEROUTINE>except*</CODEROUTINE> instead of <CODEROUTINE>except</CODEROUTINE>, we can selectively handle only the exceptions in the group that match a certain type, while letting all other exceptions propagate to other clauses and eventually to be reraised.</ITEM>
</BLIST>
<BLIST><TITLE><U><B>with</B></U></TITLE>
  <ITEM>The <CODEROUTINE>with</CODEROUTINE> statement allows objects like files to be used in a way that ensures they are always cleaned up promptly and correctly.
    <CODESAMPLE>with open("myfile.txt") as f:<BR/>
    <TAB/>for line in f:<BR/>
    <TAB/><TAB/>print(line, end="")</CODESAMPLE></ITEM>
</BLIST>
<BLIST><TITLE><U><B>Display colored messages</B></U></TITLE>
  <ITEM>Write some text in yellow
    <CODESAMPLE>import colorama<BR/>
    â€¦<BR/>
    print(colorama.Fore.YELLOW + f"set epic to start date = {start_date} and due date = {due_date} ({release})" + colorama.Style.RESET_ALL)</CODESAMPLE></ITEM>
</BLIST>
<BLIST><TITLE><U><B>Virtual environments</B></U></TITLE>
  <ITEM>Virtual environments are managed by the <CODEROUTINE>venv</CODEROUTINE> module.
  </ITEM>
  <ITEM>Create a virtual environment
    <CODESAMPLE>python -m venv /path/to/new/virtual/environment</CODESAMPLE>
  </ITEM>
  <ITEM>A common directory location for a virtual environment is <CODEFILENAME>.venv</CODEFILENAME>.
  </ITEM>
  <ITEM>In order to activate the environment, some scripts are generated for each Linux/Windows shell, for example, for bash:
    <CODESAMPLE>source &lt;venv&gt;/bin/activate</CODESAMPLE>
    for Windows:
    <CODESAMPLE>&lt;venv&gt;\Scripts\activate</CODESAMPLE>
  </ITEM>
  <ITEM>To deactivate the environment:
    <CODESAMPLE>deactivate</CODESAMPLE>
  </ITEM>
</BLIST>
<BLIST><TITLE><U><B>unittest</B></U> (<X><T>doc</T><A>https://docs.python.org/3/library/unittest.html</A><L>en</L><F>HTML</F></X>)</TITLE>
  <ITEM>A testcase is created by subclassing <CODEROUTINE>unittest.TestCase</CODEROUTINE>. The three individual tests are defined with methods whose names start with the letters <CODEROUTINE>test</CODEROUTINE>.</ITEM>
  <ITEM><CODEROUTINE>assertEqual()</CODEROUTINE>: check for an expected result</ITEM>
  <ITEM><CODEROUTINE>assertTrue()</CODEROUTINE> or <CODEROUTINE>assertFalse()</CODEROUTINE>: verify a condition</ITEM>
  <ITEM><CODEROUTINE>assertRaises()</CODEROUTINE>: verify that a specific exception gets raised</ITEM>
  <ITEM>example
    <CODESAMPLE>import unittest<BR/>
    <BR/>
    class TestStringMethods(unittest.TestCase):<BR/>
    <BR/>
    <TAB/>def test_upper(self):<BR/>
    <TAB/><TAB/>self.assertEqual('foo'.upper(), 'FOO')<BR/>
    <BR/>
    <TAB/>def test_isupper(self):<BR/>
    <TAB/><TAB/>self.assertTrue('FOO'.isupper())<BR/>
    <TAB/><TAB/>self.assertFalse('Foo'.isupper())<BR/>
    <BR/>
    <TAB/>def test_split(self):<BR/>
    <TAB/><TAB/>s = 'hello world'<BR/>
    <TAB/><TAB/>self.assertEqual(s.split(), ['hello', 'world'])<BR/>
    <TAB/><TAB/># check that s.split fails when the separator is not a string<BR/>
    <TAB/><TAB/>with self.assertRaises(TypeError):<BR/>
    <TAB/><TAB/><TAB/>s.split(2)<BR/>
    <BR/>
    if __name__ == '__main__':<BR/>
    <TAB/>unittest.main()</CODESAMPLE></ITEM>
  <ITEM><CODEROUTINE>setUp()</CODEROUTINE> and <CODEROUTINE>tearDown()</CODEROUTINE>: define instructions that will be executed before and after each test method</ITEM>
  <ITEM>The unittest module can be used from the command line to run tests from modules, classes, or  individual test methods:<BR/>
    <CODEROUTINE>python -m unittest test_module1 test_module2</CODEROUTINE><BR/>
    <CODEROUTINE>python -m unittest test_module.TestClass</CODEROUTINE><BR/>
    <CODEROUTINE>python -m unittest test_module.TestClass.test_method</CODEROUTINE><BR/>
    Running with a file name is a kludge to be able to use with the shell file name autocompletion, it removes the <CODEROUTINE>.py</CODEROUTINE> extension and replaces <CODEROUTINE>/</CODEROUTINE> by <CODEROUTINE>.</CODEROUTINE>.<BR/>
    <CODESAMPLE><PROMPT/>python -m unittest tests/test_something.py</CODESAMPLE></ITEM>
</BLIST>
<BLIST><TITLE><U><B>pip</B></U></TITLE>
  <ITEM>install packages
    <CODESAMPLE><PROMPT/>python -m pip install &lt;package1&gt; &lt;package2&gt; &lt;package3&gt;</CODESAMPLE>
    or
    <CODESAMPLE><PROMPT/>pip install &lt;package1&gt; &lt;package2&gt; &lt;package3&gt;</CODESAMPLE>
  </ITEM>
  <ITEM>install a specific version
    <CODESAMPLE><PROMPT/>pip install requests==2.6.0</CODESAMPLE>
  </ITEM>
  <ITEM>install the packages defined in a <CODEFILENAME>requirements.txt</CODEFILENAME> file
    <CODESAMPLE><PROMPT/>pip install -r requirements.txt</CODESAMPLE>
  </ITEM>
  <ITEM>upgrade a package
    <CODESAMPLE><PROMPT/>pip install -U &lt;package&gt;</CODESAMPLE>
    <CODESAMPLE><PROMPT/>pip install --upgrade &lt;package&gt;</CODESAMPLE>
  </ITEM>
  <ITEM>install a package from the default branch of a Git repository
    <CODESAMPLE><PROMPT/>pip install git+https://gitlab.com/opentestfactory/agent</CODESAMPLE>
    The version (commit ID) is available in <CODEFILENAME>/c/Users/lmazure/AppData/Local/Programs/Python/Python39/lib/site-packages/opentf_agent-*.dist-info/direct_url.json</CODEFILENAME>.<BR/>
    See <X><T>https://packaging.python.org/en/latest/specifications/direct-url/</T><A>https://packaging.python.org/en/latest/specifications/direct-url/</A><L>en</L><F>HTML</F></X>.
  </ITEM>
  <ITEM>install a package from a given branch of a Git repository
    <CODESAMPLE><PROMPT/>pip install git+https://gitlab.com/opentestfactory/agent@rel-1.3.1</CODESAMPLE>
  </ITEM>
  <ITEM>list the installed packages
    <CODESAMPLE><PROMPT/>pip list</CODESAMPLE>
  </ITEM>
  <ITEM>list the installed packages in the format expected by <CODEROUTINE>pip install</CODEROUTINE>
    <CODESAMPLE><PROMPT/>pip freeze &gt; requirements.txt</CODESAMPLE>
  </ITEM>
  <ITEM>list the out-of-date installed packages
    <CODESAMPLE><PROMPT/>pip list -o</CODESAMPLE>
    <CODESAMPLE><PROMPT/>pip list --outdated</CODESAMPLE>
  </ITEM>
  <ITEM>do not list globally-installed packages
    <CODESAMPLE><PROMPT/>pip list -l</CODESAMPLE>
    <CODESAMPLE><PROMPT/>pip list --local</CODESAMPLE>
  </ITEM>
</BLIST></CONTENT>
<X><T>links</T><A>../links/python.html</A><L>en</L><F>HTML</F></X>
</PAGE>