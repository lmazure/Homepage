<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="../css/strict.xsl"?>
<PAGE xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../css/schema.xsd" xml:lang="en">
<TITLE>Python</TITLE>
<PATH>notes/python.xml</PATH>
<DATE><YEAR>2023</YEAR><MONTH>12</MONTH><DAY>30</DAY></DATE>
<CONTENT>
<BLIST><TITLE><U><B>Command line</B></U></TITLE>
  <ITEM>To avoid fucking problems when printing non-BMP characters to the console
    <CODESAMPLE><PROMPT/>python -X utf8 foo.py</CODESAMPLE>
</ITEM>
</BLIST>
<BLIST><TITLE><U><B>Syntax</B></U></TITLE>
  <ITEM>Comment starts with <CODEROUTINE>#</CODEROUTINE> and extends to the end of the line</ITEM>
  <ITEM>Multiple assignment<BR/>
    <CODEROUTINE>a,b = 0,1</CODEROUTINE><BR/>
    <CODEROUTINE>a,b = b,a+b</CODEROUTINE></ITEM>
  <ITEM><CODEROUTINE>del</CODEROUTINE> can be used to delete a variable<BR/>
    <CODEROUTINE>del a</CODEROUTINE>
  </ITEM>
  <ITEM>Assignment inside expressions must be done explicitly with the walrus operator <CODEROUTINE>:=</CODEROUTINE>.</ITEM>
  <ITEM>Floor division: division that rounds to nearest integer (not floor!)
    <CODESAMPLE>a = (-11) // 4 # -3</CODESAMPLE>
  </ITEM>
  <ITEM>Power
    <CODESAMPLE>a = 3 ** 4 # 81</CODESAMPLE>
  </ITEM>
  <ITEM>In interactive mode, <CODEROUTINE>_</CODEROUTINE> is a read-only variable containing the last printed expression</ITEM>
  <ITEM>Exit<BR/>
    <CODESAMPLE>import sys<BR/>
      sys.exit()</CODESAMPLE>
  </ITEM>
</BLIST>
<BLIST><TITLE><U><B>Conditions</B></U></TITLE>
  <ITEM><CODEROUTINE>in</CODEROUTINE> tests if a value is in a sequence. <CODEROUTINE>not in</CODEROUTINE> tests if a value is not in a sequence</ITEM>
  <ITEM>The operators <CODEROUTINE>is</CODEROUTINE> and <CODEROUTINE>is not</CODEROUTINE> compare whether two objects are really the same object.</ITEM>
  <ITEM><CODEROUTINE>and</CODEROUTINE>, <CODEROUTINE>or</CODEROUTINE>, and <CODEROUTINE>not</CODEROUTINE> are boolean operators<BR/>
    <CODEROUTINE>and</CODEROUTINE> and <CODEROUTINE>or</CODEROUTINE> perform a shortcut evaluation<BR/>
    <CODESAMPLE><PROMPT/> print('' or 'a' or 'b')<BR/>
      a</CODESAMPLE>
  </ITEM>
  <ITEM>Comparisons can be chained: <CODEROUTINE>a &lt; b == c</CODEROUTINE> tests whether <CODEROUTINE>a</CODEROUTINE> is less than <CODEROUTINE>b</CODEROUTINE> and moreover <CODEROUTINE>b</CODEROUTINE> equals <CODEROUTINE>c</CODEROUTINE>.</ITEM>
</BLIST>
<BLIST><TITLE><U><B>Printing</B></U></TITLE>
  <ITEM>define the separator between printed arguments<BR/>
    <CODESAMPLE><PROMPT/>print(1, 2, 3, sep ='-')<BR/>
      1-2-3</CODESAMPLE>
    </ITEM>
  <ITEM>define the line separator<BR/>
    <CODESAMPLE><PROMPT/>print(1, end ='*'); print(2, end ='*'); print(3, end ='*')<BR/>
      1*2*3*</CODESAMPLE>
  </ITEM>
  <ITEM>print to a file<BR/>
    <CODESAMPLE><PROMPT/>print('foobar', file=open('quux.txt', 'a'))</CODESAMPLE>
  </ITEM>
  <ITEM>For print data structure in a readable manner, use <X><T>pprint</T><A>https://docs.python.org/3/library/pprint.html</A><L>en</L><F>HTML</F></X>.</ITEM>
</BLIST>
<BLIST><TITLE><U><B>Complex</B></U></TITLE>
  <ITEM>A complex can be created by using <CODEROUTINE>j</CODEROUTINE> or <CODEROUTINE>J</CODEROUTINE> to indicate the complex part.<BR/>
    <CODEROUTINE>1+2j</CODEROUTINE> or with the <CODEROUTINE>complex</CODEROUTINE> function (<CODEROUTINE>complex(1,2)</CODEROUTINE>).
  </ITEM>
  <ITEM><CODEROUTINE>real</CODEROUTINE> and <CODEROUTINE>imag</CODEROUTINE> can be used to retrieve the real and imaginary parts of a complex<BR/>
  <CODESAMPLE>a=1.5+0.5j<BR/>
    a.real<BR/>
    a.imag</CODESAMPLE>
  </ITEM>
</BLIST>
<BLIST><TITLE><U><B>Strings</B></U></TITLE>
  <ITEM>String literals can be enclosed in single or double quotes<BR/>
    <CODEROUTINE>"foobar 'n \" quux"</CODEROUTINE><BR/>
    <CODEROUTINE>'foobar \'n" quux'</CODEROUTINE></ITEM>
  <ITEM>New line can be escaped by \<BR/>
    <CODESAMPLE>"first line \n\<BR/>
      second line"</CODESAMPLE>
  </ITEM>
  <ITEM>Triple single or double quotes can also be used to create strings containing new lines<BR/>
    <CODESAMPLE>"""first line<BR/>
      second line"""</CODESAMPLE>
  </ITEM>
  <ITEM>String literals are automatically concatenated<BR/>
    <CODEROUTINE>"foo" "bar"</CODEROUTINE></ITEM>
  <ITEM>+ appends strings<BR/>
    <CODEROUTINE>"foo"+"bar"</CODEROUTINE></ITEM>
  <ITEM><CODEROUTINE>*</CODEROUTINE> repeats strings<BR/>
    <CODEROUTINE>"foo"*5</CODEROUTINE> is <CODEROUTINE>"foofoofoofoofoo"</CODEROUTINE></ITEM>
  <ITEM>Slices<BR/>
    <CODEROUTINE>str[4]</CODEROUTINE> fifth letter<BR/>
    <CODEROUTINE>str[2:4]</CODEROUTINE> third and fourth letters<BR/>
    <CODEROUTINE>str[:2]</CODEROUTINE> first two characters<BR/>
    <CODEROUTINE>str[2:]</CODEROUTINE> all but first two characters<BR/>
    <CODEROUTINE>str[-1]</CODEROUTINE> last character<BR/>
    <CODEROUTINE>str[-2]</CODEROUTINE> last but one character<BR/>
    <CODEROUTINE>str[-2:]</CODEROUTINE> last two characters<BR/>
    <CODEROUTINE>str[:-2]</CODEROUTINE> all but the last two characters<BR/>
    slices are immutable</ITEM>
  <ITEM>Using a too large index generates an error
    <CODESAMPLE><PROMPT/> "language"[42]<BR/>
      Traceback (most recent call last):<BR/>
      File "&lt;stdin&gt;", line 1, in &lt;module&gt;<BR/>
      IndexError: string index out of range</CODESAMPLE>
    but not for slices
  <CODESAMPLE><PROMPT/> "language"[3:42]<BR/>
      'guage'</CODESAMPLE>
  </ITEM>
  <ITEM><CODEROUTINE>len</CODEROUTINE> return the length a string<BR/>
    <CODEROUTINE>len(str)</CODEROUTINE></ITEM>
  <ITEM><BLIST><TITLE>String Interpolation</TITLE>
    <ITEM>String modulo operator
      <CODESAMPLE>myVal1 = 10.1<BR/>
        myVal2 = 2.2<BR/>
        print("The sum of %s and %s is %s." %(my_val_1, my_val_2, my_val_1+my_val_2))</CODESAMPLE>
    </ITEM>
    <ITEM><CODEROUTINE>String .format()</CODEROUTINE><BR/>
      <CODESAMPLE>'My name is {name} and I am {age} years old'.format(name= 'Frida', age=114)</CODESAMPLE>
    </ITEM>
    <ITEM><BLIST><TITLE>F-strings</TITLE>
      <ITEM><CODESAMPLE>f'The date today is {datetime.datetime.now():%B %d, %Y}'</CODESAMPLE>
      </ITEM>
      <ITEM>Use <CODEROUTINE>{{</CODEROUTINE> to insert a <CODEROUTINE>{</CODEROUTINE> and <CODEROUTINE>}}</CODEROUTINE> to insert a <CODEROUTINE>}</CODEROUTINE></ITEM>
    </BLIST></ITEM>
    <ITEM>Template strings
      <CODESAMPLE>from string import Template<BR/>
        greeting = Template('Welcome, $name')<BR/>
        greeting.substitute(name='Frida!')</CODESAMPLE>
    </ITEM>
  </BLIST></ITEM>
</BLIST>
<BLIST><TITLE><U><B>List</B></U></TITLE>
  <ITEM>Lists can mix types
    <CODESAMPLE>a = ['foo', 69, 'bar']</CODESAMPLE>
  </ITEM>
  <ITEM>Lists support slices (these ones are mutable and can even be used to change the size of the list)<BR/>
    <CODEROUTINE>a[0:2]</CODEROUTINE>: remove the two first elements of the list<BR/>
    <CODEROUTINE>a[:0] = a</CODEROUTINE>: insert a copy ot itself at the beginning of the list
  </ITEM>
  <ITEM>All slice operations return a new list containing the requested elements. So <CODEROUTINE>a[:]</CODEROUTINE> returns a shallow copy of <CODEROUTINE>a</CODEROUTINE>.</ITEM>
  <ITEM><CODEROUTINE>del</CODEROUTINE> can be used to remove elements in a list
    <CODESAMPLE>del a[2:4]</CODESAMPLE>
  </ITEM>
  <ITEM>We can do the same with
    <CODESAMPLE>a[2:4] = []</CODESAMPLE>
  </ITEM>
  <ITEM>lists can be concatenated with <CODEROUTINE>+</CODEROUTINE>
    <CODESAMPLE><PROMPT/> [ 1, 2 ] + [ 3, 4, 5]<BR/>
      [1, 2, 3, 4, 5] </CODESAMPLE>
  </ITEM>
  <ITEM><CODEROUTINE>len</CODEROUTINE>: return the number of elements of a list</ITEM>
  <ITEM>Lists can be nested
    <CODESAMPLE>q = [45, 3]<BR/>
      p = [0, q, 14]</CODESAMPLE>
  </ITEM>
  <ITEM>List unpacking
    <CODESAMPLE>a = [1, 2, 3, 4]<BR/>
      [a1, a2, a3, a4] = a</CODESAMPLE>
  </ITEM>
  <ITEM>Test if an element is in a list
    <CODESAMPLE>item in List</CODESAMPLE>
  </ITEM>
  <ITEM>Test if a list is empty
    <CODESAMPLE>if my_list:<BR/>
      <TAB/>print("list is not empty")<BR/>
      else:<BR/>
      <TAB/>print("list is empty")</CODESAMPLE>
  </ITEM>
  <ITEM>A list comprehension consists of brackets containing an expression followed by a <CODEROUTINE>for</CODEROUTINE> clause, then zero or more <CODEROUTINE>for</CODEROUTINE> or <CODEROUTINE>if</CODEROUTINE> clauses.
    <CODESAMPLE><PROMPT/>[x**2 for x in range(10)]<BR/>
      [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</CODESAMPLE>
    <CODESAMPLE><PROMPT/>[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]<BR/>
      [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]</CODESAMPLE>  </ITEM>
  <ITEM>Join the members of a list (as a string)
    <CODESAMPLE>vowels = ["a", "e", "i", "o", "u"]<BR/>
      vowelsCSV = ",".join(vowels)<BR/>
      print("Vowels are = ", vowelsCSV)</CODESAMPLE>
  </ITEM>
  <ITEM><BLIST><TITLE>Methods</TITLE>
    <ITEM><CODEROUTINE>insert(pos,item)</CODEROUTINE>: insert an item at a given position</ITEM>
    <ITEM><CODEROUTINE>append(elem)</CODEROUTINE>: append an item at the list end</ITEM>
    <ITEM><CODEROUTINE>pop(i)</CODEROUTINE>: remove the item at the given position in the list and return it</ITEM>
    <ITEM><CODEROUTINE>pop()</CODEROUTINE>: remove the last item and return it</ITEM>
    <ITEM><CODEROUTINE>index(item)</CODEROUTINE>: return the index of the first occurrence of the value <CODEROUTINE>item</CODEROUTINE></ITEM>
    <ITEM><CODEROUTINE>remove(item)</CODEROUTINE>: remove the first occurrence of the value <CODEROUTINE>item</CODEROUTINE></ITEM>
    <ITEM><CODEROUTINE>sort()</CODEROUTINE>: sort the list</ITEM>
    <ITEM><CODEROUTINE>reverse()</CODEROUTINE>: reverse the list</ITEM>
    <ITEM><CODEROUTINE>count(item)</CODEROUTINE>: return the number of occurrences of the value <CODEROUTINE>item</CODEROUTINE></ITEM>
  </BLIST></ITEM>
  <ITEM><BLIST><TITLE>Functions</TITLE>
    <ITEM>Functions can have attributes and inner functions.</ITEM>
    <ITEM>Generator function:
      <CODESAMPLE>def fibonacci_generator():<BR/>
        <TAB/>a, b = 0, 1<BR/>
        <TAB/>while True:<BR/>
        <TAB/><TAB/>yield a<BR/>
        <TAB/><TAB/>a, b = b, a + b<BR/>
        <BR/>
        fib_generator = fibonacci_generator()<BR/>
        print(next(fib_generator)) # Prints 0<BR/>
        print(next(fib_generator)) # Prints 1<BR/>
        print(next(fib_generator)) # Prints 1<BR/>
        print(next(fib_generator)) # Prints 2<BR/>
        print(next(fib_generator)) # Prints 3</CODESAMPLE>
    </ITEM>
    <ITEM><X><T>Attributes</T><A>https://docs.python.org/3/reference/datamodel.html#callable-types</A><L>en</L><F>HTML</F></X> of a function.</ITEM>
    <ITEM><CODEROUTINE>filter(function,l)</CODEROUTINE> return the list of elements <CODEROUTINE>elem</CODEROUTINE> for which <CODEROUTINE>function(elem)</CODEROUTINE> is true.</ITEM>
    <ITEM><CODEROUTINE>map(function,l)</CODEROUTINE> return the list of values of <CODEROUTINE>function</CODEROUTINE> called for each element of <CODEROUTINE>l</CODEROUTINE>.<BR/>
      more than one list can be passed to <CODEROUTINE>map</CODEROUTINE>, in this case, <CODEROUTINE>function</CODEROUTINE> must have the same number of arguments (if a list is shorter than the other one, <CODEROUTINE>function</CODEROUTINE> will be called with the value <CODEROUTINE>None</CODEROUTINE>)<BR/>
      if <CODEROUTINE>None</CODEROUTINE> is passed instead of a function, <CODEROUTINE>map</CODEROUTINE> returns its arguments
      <CODESAMPLE><PROMPT/>(None,[1,2,3,4],[5,6,7])
        [(1, 5), (2, 6), (3, 7), (4, None)]</CODESAMPLE>
    </ITEM>
    <ITEM><CODEROUTINE>reduce(function,l)</CODEROUTINE> call function on the two first items, then on the result and the next item…
      <CODESAMPLE><PROMPT/>reduce(lambda x,y:x+y , [1,2,3,4,5,6])<BR/>
        21</CODESAMPLE>
      a third argument can be passed to indicate the starting value (this value will be returned in case of an empty list)
    </ITEM>
  </BLIST></ITEM>
</BLIST>
<BLIST><TITLE><U><B>Tuple</B></U></TITLE>
  <ITEM>A tuple is a number of values separated by a comma<BR/>
    (they may be input with or without parentheses)
    <CODESAMPLE>t=1,2,"azerty"</CODESAMPLE>
  </ITEM>
  <ITEM>Tuples support slicing</ITEM>
  <ITEM>An empty tuple is created with the syntax:
    <CODESAMPLE>empty=()</CODESAMPLE>
  </ITEM>
  <ITEM>A singleton tuple is created with an empty comma
    <CODESAMPLE>singleton=1,</CODESAMPLE>
  </ITEM>
  <ITEM>Tuple packing
    <CODESAMPLE>t=1,2,3</CODESAMPLE>
    Tuple unpacking
    <CODESAMPLE>x,y,z=t</CODESAMPLE>
  </ITEM>
  <ITEM>Tuple are immutable: it is not possible ot assign to the individual items of a tuple</ITEM>
</BLIST>
<BLIST><TITLE><U><B>Sequences</B></U></TITLE>
  <ITEM>Sequences can be lists, strings or tuples.</ITEM>
  <ITEM><BLIST><TITLE>Loops</TITLE>
    <ITEM>Tuple unpacking (all tuples must have the same length):
      <CODESAMPLE>for a, b in [(1, "one"), (3, "three"), (5, "five")]:<BR/>
        <TAB/>print(a, b)</CODESAMPLE>
      <CODESAMPLE>for a, b, c in [(1, "one", "un"), (3, "three", "trois"), (5, "five", "cinq")]:<BR/>
        <TAB/>print(a, b, c)</CODESAMPLE>
      <CODESAMPLE>for a, (b, c) in [(1, ("one", "un")), (3, ("three", "trois")), (5, ("five", "cinq"))]:<BR/>
        <TAB/>print(a, b, c)</CODESAMPLE>
    </ITEM>
    <ITEM>When looping through a sequence, the position index and corresponding value can be retrieved at the same time using <CODEROUTINE>enumerate()</CODEROUTINE>
      <CODESAMPLE>for i, v in enumerate(['tic', 'tac', 'toe']):<BR/>
        <TAB/>print(i, v)</CODESAMPLE>
    </ITEM>
    <ITEM>To loop over two or more sequences at the same time, the entries can be paired with <CODEROUTINE>zip()</CODEROUTINE>.<BR/>
      The loop finishes with the shortest sequence.
      <CODESAMPLE>questions = ['name', 'quest', 'favorite color']<BR/>
        answers = ['lancelot', 'the holy grail', 'blue']<BR/>
        for q, a in zip(questions, answers):<BR/>
        <TAB/>print('What is your {0}?  It is {1}.'.format(q, a))</CODESAMPLE>
      <CODESAMPLE>letters = [ "alpha", "beta", "gamma", "delta" ]<BR/>
        numbers = [ 0, 1, 2, 3 ]<BR/>
        months = [ "jan", "feb", "mar", "apr", "may" ]<BR/>
        for l, n, m in zip (letters, numbers, months):<BR/>
        <TAB/>print(l, n , m)</CODESAMPLE>
    </ITEM>
    <ITEM>To loop over a sequence in reverse, first specify the sequence in a forward direction and then call <CODEROUTINE>reversed()</CODEROUTINE>
      <CODESAMPLE>for i in reversed(range(1, 10, 2)):<BR/>
        <TAB/>print(i)</CODESAMPLE>
    </ITEM>
    <ITEM>To loop over a sequence in sorted order, use <CODEROUTINE>sorted()</CODEROUTINE> function which returns a new sorted list while leaving the source unaltered.
      <CODESAMPLE>basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']<BR/>
        for i in sorted(basket):<BR/>
        <TAB/>print(i)</CODESAMPLE>
    </ITEM>
    <ITEM>Using <CODEROUTINE>set()</CODEROUTINE> on a sequence eliminates duplicate elements. The use of <CODEROUTINE>sorted()</CODEROUTINE> in combination with <CODEROUTINE>set()</CODEROUTINE> over a sequence is an idiomatic way to loop over unique elements of the sequence in sorted order..
      <CODESAMPLE>basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']<BR/>
        for f in sorted(set(basket)):<BR/>
        <TAB/>print(i)</CODESAMPLE>
    </ITEM>
  </BLIST></ITEM>
</BLIST>
<BLIST><TITLE><U><B>Set</B></U></TITLE>
  <ITEM>Create an empty set
    <CODESAMPLE>s = set()</CODESAMPLE>
  </ITEM>
  <ITEM>Set comprehension
    <CODESAMPLE><PROMPT/>{s**2 for s in range(10)}<BR/>
      {0, 1, 64, 4, 36, 9, 16, 49, 81, 25}</CODESAMPLE>
  </ITEM>
</BLIST>
<BLIST><TITLE><U><B>Dictionary</B></U></TITLE>
  <ITEM>Syntax
    <CODESAMPLE>d={'key1':1234,'key2':5678}<BR/>
      d['key3']=43</CODESAMPLE>
  </ITEM>
  <ITEM>Create an empty dictionary
    <CODESAMPLE>d = {}</CODESAMPLE>
  </ITEM>
  <ITEM>Keys must be immutable: numbers, strings and tuples containing only numbers, strings and tuples</ITEM>
  <ITEM><CODEROUTINE>del</CODEROUTINE> can be used to delete entries of a dictionary, it raises a <CODEROUTINE>KeyError</CODEROUTINE> if rhe key is not in the map
    <CODESAMPLE>del d['key3']</CODESAMPLE>
  </ITEM>
  <ITEM>When looping through dictionaries, the key and corresponding value can be retrieved at the same time using <CODEROUTINE>items()</CODEROUTINE>
    <CODESAMPLE>knights = {'gallahad': 'the pure', 'robin': 'the brave'}<BR/>
      for k, v in knights.items():<BR/>
      <TAB/>print(k, v)</CODESAMPLE>
  </ITEM>
  <ITEM>Dictionary comprehension
    <CODESAMPLE>dict1 = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}<BR/>
      # Double each value in the dictionary<BR/>
      double_dict1 = {k:v*2 for (k,v) in dict1.items()}<BR/>
      print(double_dict1)</CODESAMPLE>
  </ITEM>
  <ITEM><BLIST><TITLE>Methods</TITLE>
    <ITEM><CODEROUTINE>key in d</CODEROUTINE>: return <CODEROUTINE>True</CODEROUTINE> if d has a key key, else <CODEROUTINE>False</CODEROUTINE></ITEM>
    <ITEM><CODEROUTINE>key not in d</CODEROUTINE>: equivalent to <CODEROUTINE>not key in d</CODEROUTINE></ITEM>
    <ITEM><CODEROUTINE>iter(d)</CODEROUTINE>: return an iterator over the keys of the dictionary, this is a shortcut for <CODEROUTINE>iter(d.keys())</CODEROUTINE></ITEM>
    <ITEM><CODEROUTINE>clear()</CODEROUTINE>: remove all items from the dictionary</ITEM>
    <ITEM><CODEROUTINE>copy()</CODEROUTINE>: return a shallow copy of the dictionary.</ITEM>
    <ITEM><CODEROUTINE>classmethod fromkeys(iterable[, value])</CODEROUTINE>: create a new dictionary with keys from <CODEROUTINE>iterable</CODEROUTINE> and values set to <CODEROUTINE>value</CODEROUTINE></ITEM>
    <ITEM><CODEROUTINE>get(key[, default])</CODEROUTINE>: return the value for key if <CODEROUTINE>key</CODEROUTINE> is in the dictionary, else <CODEROUTINE>default</CODEROUTINE>. If default is not given, it defaults to <CODEROUTINE>None</CODEROUTINE>, so that this method never raises a <CODEROUTINE>KeyError</CODEROUTINE></ITEM>
    <ITEM><CODEROUTINE>items()</CODEROUTINE>: return a new view of the dictionary’s items (<CODEROUTINE>(key, value)</CODEROUTINE> pairs)</ITEM>
    <ITEM><CODEROUTINE>keys()</CODEROUTINE>: return a new view of the dictionary’s keys</ITEM>
    <ITEM><CODEROUTINE>pop(key[, default])</CODEROUTINE>: if <CODEROUTINE>key</CODEROUTINE> is in the dictionary, remove it and return its value, else return <CODEROUTINE>default</CODEROUTINE>. If <CODEROUTINE>default</CODEROUTINE> is not given and key is not in the dictionary, a <CODEROUTINE>KeyError</CODEROUTINE> is raised.</ITEM>
    <ITEM><CODEROUTINE>popitem()</CODEROUTINE>: remove and return a <CODEROUTINE>(key, value)</CODEROUTINE> pair from the dictionary. Pairs are returned in LIFO order. If the dictionary is empty, calling <CODEROUTINE>popitem()</CODEROUTINE> raises a <CODEROUTINE>KeyError</CODEROUTINE>.</ITEM>
    <ITEM><CODEROUTINE>reversed(d)</CODEROUTINE>: return a reverse iterator over the keys of the dictionary. This is a shortcut for <CODEROUTINE>reversed(d.keys()).</CODEROUTINE></ITEM>
    <ITEM><CODEROUTINE>setdefault(key[, default])</CODEROUTINE>: if <CODEROUTINE>key</CODEROUTINE> is in the dictionary, return its value. If not, insert <CODEROUTINE>key</CODEROUTINE> with a value of <CODEROUTINE>default</CODEROUTINE> and return <CODEROUTINE>default</CODEROUTINE>. <CODEROUTINE>default</CODEROUTINE> defaults to <CODEROUTINE>None</CODEROUTINE>.</ITEM>
    <ITEM><CODEROUTINE>update([other])</CODEROUTINE>: update the dictionary with the key/value pairs from other, overwriting existing keys. Return <CODEROUTINE>None</CODEROUTINE>.  <CODEROUTINE>update()</CODEROUTINE> accepts either another dictionary object or an iterable of key/value pairs (as tuples or other iterables of length two). If keyword arguments are specified, the dictionary is then updated with those key/value pairs: <CODEROUTINE>d.update(red=1, blue=2)</CODEROUTINE>.</ITEM>
    <ITEM><CODEROUTINE>values()</CODEROUTINE>: return a new view of the dictionary’s values.</ITEM>
    <ITEM><CODEROUTINE>d | other</CODEROUTINE>: create a new dictionary with the merged keys and values of <CODEROUTINE>d</CODEROUTINE> and <CODEROUTINE>other</CODEROUTINE>, which must both be dictionaries. The values of <CODEROUTINE>other</CODEROUTINE> take priority when <CODEROUTINE>d</CODEROUTINE> and <CODEROUTINE>other</CODEROUTINE> share keys.</ITEM>
    <ITEM><CODEROUTINE>d |= other</CODEROUTINE>: update the dictionary d with keys and values from <CODEROUTINE>other</CODEROUTINE>, which may be either a mapping or an iterable of key/value pairs. The values of <CODEROUTINE>other</CODEROUTINE> take priority when d and other share keys.</ITEM>
    <ITEM>The objects returned by <CODEROUTINE>dict.keys()</CODEROUTINE>, <CODEROUTINE>dict.values</CODEROUTINE>(), and <CODEROUTINE>dict.items(</CODEROUTINE>) are view objects. They provide a dynamic view on the dictionary’s entries, which means that when the dictionary changes, the view reflects these changes.<BR/>
      Dictionary views can be iterated over to yield their respective data, and support membership tests:
      <BLIST>
        <ITEM><CODEROUTINE>len(dictview)</CODEROUTINE>: return the number of entries in the dictionary</ITEM>
        <ITEM><CODEROUTINE>iter(dictview)</CODEROUTINE>: return an iterator over the keys, values or items (represented as tuples of (key, value)) in the dictionary</ITEM>
        <ITEM><CODEROUTINE>x in dictview</CODEROUTINE>: return <CODEROUTINE>True</CODEROUTINE> if <CODEROUTINE>x</CODEROUTINE> is in the underlying dictionary’s keys, values or items (in the latter case, x should be a <CODEROUTINE>(key, value)</CODEROUTINE> tuple)</ITEM>
        <ITEM><CODEROUTINE>reversed(dictview)</CODEROUTINE>: return a reverse iterator over the keys, values or items of the dictionary. The view will be iterated in reverse order of the insertion.</ITEM>
        <ITEM><CODEROUTINE>dictview.mapping</CODEROUTINE>: return a <CODEROUTINE>types.MappingProxyType</CODEROUTINE> that wraps the original dictionary to which the view refers</ITEM>
    </BLIST></ITEM>
  </BLIST></ITEM>
</BLIST>
<BLIST><TITLE><U><B>Control flow</B></U></TITLE>
  <ITEM>Any non-zero integer value is true; zero is false.<BR/>
    For a sequence (string, list…), anything with a non-zero length is true, empty sequences are false.</ITEM>
  <ITEM><CODESAMPLE>if x == 1:<BR/>
    <TAB/>print("one")<BR/>
    elif x == 2:<BR/>
    <TAB/>print("two")<BR/>
    elif x == 3:<BR/>
    <TAB/>print("three")<BR/>
    else:<BR/>
    <TAB/>print("other")</CODESAMPLE>
  </ITEM>
  <ITEM><CODEROUTINE>for</CODEROUTINE> loops on a sequence (string or list) content<BR/>
    The <CODEROUTINE>else</CODEROUTINE> clause is executed when the list is exhausted<BR/>
  <CODESAMPLE>a=[1,2,3]<BR/>
    for x in a:<BR/>
    <TAB/>print x<BR/>
    else:<BR/>
    <TAB/>print "finished"</CODESAMPLE>
  </ITEM>
  <ITEM>It is not safe to modify the content of the list being looped on, a copy should be generated</ITEM>
  <ITEM><CODEROUTINE>while</CODEROUTINE> loops as long a condition is true
    <CODESAMPLE>while b &lt; 10:<BR/>
    <TAB/>b = b+1<BR/>
    else:<BR/>
    <TAB/>print "end"</CODESAMPLE>
  </ITEM>
  <ITEM>There is no <CODEROUTINE>do</CODEROUTINE>/<CODEROUTINE>while</CODEROUTINE> statement, instead use
    <CODESAMPLE>while 1:<BR/>
    <TAB/>line = sys.stdin.readline()<BR/>
    <TAB/>if line == "\n":<BR/>
    <TAB/><TAB/>break</CODESAMPLE>
  </ITEM>
  <ITEM>Use <CODEROUTINE>range</CODEROUTINE> for iterating over a sequence of numbers<BR/>
    <CODEROUTINE>range(stop)</CODEROUTINE> returns <CODEROUTINE>[0, 1, 2… stop-1]</CODEROUTINE><BR/>
    <CODEROUTINE>range(start, stop)</CODEROUTINE> returns <CODEROUTINE>[start, start+1… stop-1]</CODEROUTINE><BR/>
    <CODEROUTINE>range(start, stop, incr)</CODEROUTINE> returns <CODEROUTINE>[start, start+incr… stop-incr]</CODEROUTINE></ITEM>
  <ITEM><CODEROUTINE>break</CODEROUTINE> breaks out of the smallest enclosing <CODEROUTINE>for</CODEROUTINE> or <CODEROUTINE>while</CODEROUTINE> loop<BR/>
    the <CODEROUTINE>else</CODEROUTINE> clause is not executed</ITEM>
  <ITEM><CODEROUTINE>continue</CODEROUTINE> continues with the next iteration of the loop</ITEM>
  <ITEM><CODEROUTINE>pass</CODEROUTINE> is a noop statement</ITEM>
  <ITEM>Matching constants (<CODEROUTINE>_</CODEROUTINE>) always matches
    <CODESAMPLE>match status:<BR/>
      <TAB/>case 400:<BR/>
      <TAB/><TAB/>return "Bad request"<BR/>
      <TAB/>case 401 | 403 | 404:<BR/>
      <TAB/><TAB/>return "Not allowed"<BR/>
      <TAB/>case 404:<BR/>
      <TAB/><TAB/>return "Not found"<BR/>
      <TAB/>case 418:<BR/>
      <TAB/><TAB/>return "I'm a teapot"<BR/>
      <TAB/>case _:<BR/>
      <TAB/><TAB/>return "Something’s wrong with the internet"</CODESAMPLE>
  </ITEM>
</BLIST>
<BLIST><TITLE><U><B>Function</B></U></TITLE>
  <ITEM>Syntax (the docstring is optional):
    <CODESAMPLE>def myfunction(a,b,c):<BR/>
    <TAB/>"docstring"<BR/>
    <TAB/># … code</CODESAMPLE>
  </ITEM>
  <ITEM>All variable assignments store value in the local symbol table<BR/>
    Variable references are looked in the local symbol table, then in the global symbol table and, at last, in the table of built-in names</ITEM>
  <ITEM>Parameters are passed by reference</ITEM>
  <ITEM>Function references can be stored in variables
    <CODEROUTINE>f=myfunction</CODEROUTINE></ITEM>
  <ITEM><CODEROUTINE>return</CODEROUTINE> returns the <CODEROUTINE>None</CODEROUTINE> value</ITEM>
  <ITEM><CODEROUTINE>return s</CODEROUTINE> returns the <CODEROUTINE>s</CODEROUTINE> value</ITEM>
  <ITEM>Default argument values can be used, they are evaluated only once
    <CODESAMPLE>def f(a,l=[]):<BR/>
    <TAB/>l.append(a)<BR/>
    <TAB/>return l</CODESAMPLE>
    <CODEROUTINE>print f(1)</CODEROUTINE> prints <CODEROUTINE>[1]</CODEROUTINE><BR/>
    <CODEROUTINE>print f(2)</CODEROUTINE> prints <CODEROUTINE>[1,2]</CODEROUTINE><BR/>
    <CODEROUTINE>print f(3)</CODEROUTINE> prints <CODEROUTINE>[1,2,3]</CODEROUTINE><BR/>
    To avoid this:
    <CODESAMPLE>def f(a,l=None)<BR/>
    <TAB/>if l is None:<BR/>
    <TAB/><TAB/>l=[]<BR/>
    <TAB/>l.append(a)<BR/>
    <TAB/>return l</CODESAMPLE>
  </ITEM>
  <ITEM>Parameters can be passed by keywords
    <CODESAMPLE>def foobar(a,b,c,d):<BR/>
    <TAB/>#…<BR/>
    foobar(0,1,d=4,c=3)</CODESAMPLE>
  </ITEM>
  <ITEM><CODEROUTINE>*name</CODEROUTINE> can be used to get an arbitrary number of positional arguments<BR/>
    <CODEROUTINE>**name</CODEROUTINE> can be used to get an arbitrary number of keyword arguments
    <CODESAMPLE>def quux(*a,**b):<BR/>
    <TAB/>for arg in a: print arg<BR/>
    <TAB/>for kw in b.keys(): print(kw,':',b[kw])</CODESAMPLE>
  </ITEM>
  <ITEM>A function can return a function
    <CODESAMPLE>def curry(func, value):<BR/>
    <TAB/>def f(x):<BR/>
    <TAB/><TAB/>return func(x, value)<BR/>
    <TAB/>return f</CODESAMPLE>
  </ITEM>
  <ITEM><CODEROUTINE>lambda</CODEROUTINE> can be used to create anonymous functions<BR/>
    They are restricted to a single expression
    <CODESAMPLE>lambda a,b:a+b</CODESAMPLE>
    Another example using a default argument value
    <CODESAMPLE>def make_incrementator(n)<BR/>
    <TAB/>return lambda x,incr=n:x+incr</CODESAMPLE>
  </ITEM>
</BLIST>
<BLIST><TITLE><U><B>Modules</B></U></TITLE>
  <ITEM>A module is a file containing Python definitions and statements.<BR/>
    The statements are executed the first time the module is imported.</ITEM>
  <ITEM>Syntax to import a module
    <CODESAMPLE>import mymodule<BR/>
    mymod.myfunc(2)</CODESAMPLE>
  </ITEM>
  <ITEM>If the module name is followed by <CODEROUTINE>as</CODEROUTINE>, then the name following <CODEROUTINE>as</CODEROUTINE> is bound directly to the imported module.
    <CODESAMPLE>import mymodule as mydmod</CODESAMPLE>
  </ITEM>
  <ITEM>Symbols of the imported module can be declared in the importing module’s symbol table.<BR/>
    <CODEROUTINE>from mymod import myfunc, myfunc2</CODEROUTINE><BR/>
    All symbols (except those beginning by an underscore) can be declared in the importing module’s symbol table.<BR/>
    <CODEROUTINE>from mymod import *</CODEROUTINE></ITEM>
  <ITEM>Reload a module.
    <CODEROUTINE>reload(mymod)</CODEROUTINE></ITEM>
  <ITEM>Inside a module, its name is defined in <CODEROUTINE>__name__</CODEROUTINE>.</ITEM>
  <ITEM><CODEROUTINE>sys.builtin_module_names</CODEROUTINE> lists the modules compiled in the interpreter.</ITEM>
  <ITEM>When you run a module with
    <CODESAMPLE>python mymodule.py &lt;arguments&gt;</CODESAMPLE>
    The code in the module will be executed, just as if you imported it, but with <CODEROUTINE>__name__</CODEROUTINE> set to <CODEROUTINE>__main__</CODEROUTINE>. </ITEM>
  <ITEM><BLIST><TITLE>Module path</TITLE>
    <ITEM>Modules are looked for in the directories listed by <CODEROUTINE>sys.path</CODEROUTINE> (which is initially defined by the environment variable <CODEROUTINE>$PYTHONPATH</CODEROUTINE>)</ITEM>
    <ITEM>Append a new directory to the path: <CODEROUTINE>sys.path.append('C:\\windows\desktop')</CODEROUTINE></ITEM>
    </BLIST></ITEM>
  <ITEM><CODEROUTINE>dir</CODEROUTINE> returns a list of the names defined in a module.<BR/>
    <CODEROUTINE>dir(mymod)</CODEROUTINE><BR/>
    Without arguments, <CODEROUTINE>dir()</CODEROUTINE>return the list of names in the current local scope.</ITEM>
  <ITEM><CODEROUTINE>__builtin__</CODEROUTINE> is the standard module.  </ITEM>
  <ITEM><CODEROUTINE>pd = __import__('pandas')</CODEROUTINE> is the same as <CODEROUTINE>import pandas as pd</CODEROUTINE>.</ITEM>
  <ITEM><CODEROUTINE>__all__</CODEROUTINE> can be used in a module to define the symbols that should be imported when the module is imported with a wildcard (<CODEROUTINE>from &lt;module&gt; import *</CODEROUTINE>). But the other symbols can still be imported by stating them explicitly (<CODEROUTINE>from &lt;module&gt; import &lt;symbol&gt;</CODEROUTINE>).</ITEM>
  <ITEM>Absolute imports: if <CODEROUTINE>foo.py</CODEROUTINE> is in <CODEROUTINE>dir/subdir</CODEROUTINE>, it can be imported as <CODEROUTINE>import dir.subdir.foo</CODEROUTINE>.<BR/>
    Relative imports: if <CODEROUTINE>bar.py</CODEROUTINE> is in the same directory, it can use <CODEROUTINE>import .foo</CODEROUTINE>.</ITEM>
</BLIST>
<BLIST><TITLE><U><B>Packages</B></U></TITLE>
  <ITEM>Packages are structured as directories containing the file <CODEROUTINE>__init__.py</CODEROUTINE> (possibly empty) and other files being modules</ITEM>
  <ITEM>A package can also contain subdirectories (i.e. subpackages)</ITEM>
  <ITEM><CODEROUTINE>__init__.py</CODEROUTINE> can define <CODEROUTINE>__all__</CODEROUTINE> variable which is the list of the modules which should be imported when the syntax <CODEROUTINE>from mypackage import *</CODEROUTINE> is used.</ITEM>
</BLIST>
<BLIST><TITLE><U><B>Classes</B></U></TITLE>
  <ITEM>The definition of a class starts with the declaration <CODEROUTINE>class:</CODEROUTINE></ITEM>
  <ITEM>The initialisation method is <CODEROUTINE>__init__</CODEROUTINE>
    <CODESAMPLE>class Complex:<BR/>
      <TAB/>def __init__(self, realpart, imagpart):<BR/>
      <TAB/><TAB/>self.r = realpart<BR/>
      <TAB/><TAB/>self.i = imagpart</CODESAMPLE>
  </ITEM>
  <ITEM>The <CODEROUTINE>__str__</CODEROUTINE> function controls what should be returned when the class object is represented as a string.
    <CODESAMPLE>class Person:<BR/>
      <TAB/>def __init__(self, name, age):<BR/>
      <TAB/><TAB/>self.name = name<BR/>
      <TAB/><TAB/>self.age = age<BR/>
      <BR/>
      <TAB/>def __str__(self):<BR/>
      <TAB/><TAB/>return f"{self.name}({self.age})"</CODESAMPLE>
    </ITEM>
    <ITEM>The <CODEROUTINE>self</CODEROUTINE> parameter is a reference to the current instance of the class, and is used to access variables that belongs to the class.<BR/>
      It does not have to be named <CODEROUTINE>self</CODEROUTINE>, but it has to be the first parameter of any function in the class.</ITEM>
    <ITEM>There is no data privacy, properties can be modified (<CODEROUTINE>p1.age = 40</CODEROUTINE>) or deleted (<CODEROUTINE>del p1.age</CODEROUTINE>).</ITEM>
    <ITEM>Inheritance
      <CODESAMPLE>class Person:<BR/>
        <TAB/>def __init__(self, fname, lname):<BR/>
        <TAB/><TAB/>self.firstname = fname<BR/>
        <TAB/><TAB/>self.lastname = lname<BR/>
        <BR/>
        class Student(Person):<BR/>
        <TAB/>def __init__(self, fname, lname, year):<BR/>
        <TAB/><TAB/>super().__init__(fname, lname)<BR/>
        <TAB/><TAB/>self.graduationyear = year</CODESAMPLE>
    </ITEM>
</BLIST>
<BLIST><TITLE><U><B>Objects</B></U></TITLE>
<ITEM><CODEROUTINE>is</CODEROUTINE> test if two objects are the same</ITEM>
  <ITEM><CODEROUTINE>is not</CODEROUTINE> test if two objects are not the same</ITEM>
  <ITEM><CODEROUTINE>id()</CODEROUTINE> return an integer representing the identity of the object (currently implemented as its address)</ITEM>
  <ITEM><CODEROUTINE>type()</CODEROUTINE> return the type of an object</ITEM>
</BLIST>
<BLIST><TITLE><U><B>Exceptions</B></U></TITLE>
  <ITEM><CODEROUTINE>BaseException</CODEROUTINE> is the common base class of all exceptions.<BR/>
    One of its subclasses, <CODEROUTINE>Exception</CODEROUTINE>, is the base class of all the non-fatal exceptions.<BR/>
    Exceptions which are not subclasses of <CODEROUTINE>Exception</CODEROUTINE> are not typically handled, because they are used to indicate that the program should terminate. They include <CODEROUTINE>SystemExit</CODEROUTINE> which is raised by <CODEROUTINE>sys.exit()</CODEROUTINE> and <CODEROUTINE>KeyboardInterrupt</CODEROUTINE> which is raised when a user wishes to interrupt the program.</ITEM>
  <ITEM>The exception hierarchy is <X><T>here</T><A>https://docs.python.org/3/library/exceptions.html#exception-hierarchy</A><L>en</L><F>HTML</F></X>.</ITEM>
  <ITEM>Use <CODEROUTINE>try</CODEROUTINE> to declare the tentative code block and <CODEROUTINE>except</CODEROUTINE> to catch the exception.
  <CODESAMPLE>try:<BR/>
    <TAB/>…<BR/>
    except ValueError:<BR/>
    <TAB/>…</CODESAMPLE>
  </ITEM>
  <ITEM>It is possible to have several exceptions with the same handler and several handlers with the same <CODEROUTINE>try</CODEROUTINE> clause.
    <CODESAMPLE>try:<BR/>
    <TAB/>…<BR/>
    except (RuntimeError, TypeError, NameError):<BR/>
    <TAB/>…<BR/>
    except ValueError:<BR/>
    <TAB/>…</CODESAMPLE>
  </ITEM>
  <ITEM>A final <CODEROUTINE>except</CODEROUTINE> handler will catch all exceptions.
    <CODESAMPLE>try:<BR/>
    <TAB/>…<BR/>
    except (RuntimeError, TypeError, NameError):<BR/>
    <TAB/>…<BR/>
    except:<BR/>
    <TAB/>…</CODESAMPLE>
  </ITEM>
  <ITEM>An <CODEROUTINE>else</CODEROUTINE> clause may be added after the exception handlers, it will be executed anytime no exception occurred.
    <CODESAMPLE>try:<BR/>
    <TAB/>…<BR/>
    except (RuntimeError, TypeError, NameError):<BR/>
    <TAB/>…<BR/>
    else:<BR/>
    <TAB/>…</CODESAMPLE>
  </ITEM>
  <ITEM>It is possible to retrieve the exception details by adding a variable name after the exception list.
    <CODESAMPLE>try:<BR/>
    <TAB/>…<BR/>
    except IOError, (errno, strerror):<BR/>
    <TAB/>…<BR/>
    except ZeroDivisionError, detail:<BR/>
    <TAB/>…</CODESAMPLE>
  </ITEM>
  <ITEM>A <CODEROUTINE>finally</CODEROUTINE> block can be used: it will be always executed.
    <CODESAMPLE>try:<BR/>
    <TAB/>…<BR/>
    finally:<BR/>
    <TAB/>…</CODESAMPLE>
    <BLIST>
      <ITEM>If an exception occurs during execution of the <CODEROUTINE>try</CODEROUTINE> clause, the exception may be handled by an <CODEROUTINE>except</CODEROUTINE> clause. If the exception is not handled by an <CODEROUTINE>except</CODEROUTINE> clause, the exception is re-raised after the <CODEROUTINE>finally</CODEROUTINE> clause has been executed.</ITEM>
      <ITEM>An exception could occur during execution of an <CODEROUTINE>except</CODEROUTINE> or <CODEROUTINE>else</CODEROUTINE> clause. Again, the exception is re-raised after the <CODEROUTINE>finally</CODEROUTINE> clause has been executed.</ITEM>
      <ITEM>If the <CODEROUTINE>finally</CODEROUTINE> clause executes a <CODEROUTINE>break</CODEROUTINE>, <CODEROUTINE>continue</CODEROUTINE>, or <CODEROUTINE>return</CODEROUTINE> statement, exceptions are not re-raised.</ITEM>
      <ITEM>If the <CODEROUTINE>try</CODEROUTINE> statement reaches a <CODEROUTINE>break</CODEROUTINE>, <CODEROUTINE>continue</CODEROUTINE>, or <CODEROUTINE>return</CODEROUTINE> statement, the <CODEROUTINE>finally</CODEROUTINE> clause will execute just prior to the <CODEROUTINE>break</CODEROUTINE>, <CODEROUTINE>continue</CODEROUTINE>, or <CODEROUTINE>return</CODEROUTINE> statement’s execution.</ITEM>
      <ITEM>If a <CODEROUTINE>finally</CODEROUTINE> clause includes a <CODEROUTINE>return</CODEROUTINE> statement, the returned value will be the one from the finally clause’s <CODEROUTINE>return</CODEROUTINE> statement, not the value from the try clause’s <CODEROUTINE>return</CODEROUTINE> statement.</ITEM>
    </BLIST>
  </ITEM>
  <ITEM><CODEROUTINE>raise</CODEROUTINE> can be used to raise an exception, it is followed by a class (it will be implicitly instantiated by calling its constructor with no arguments) or an instance.
    <CODESAMPLE>raise NameError, 'HiThere'</CODESAMPLE>
  </ITEM>
  <ITEM><CODEROUTINE>raise</CODEROUTINE> with no argument reraises the current exception.</ITEM>
  <ITEM>Exceptions are automatically chained: if an unhandled exception occurs inside an except section, it will have the exception being handled attached to it and included in the error message</ITEM>
  <ITEM>Exceptions can be explicitly chained using <CODEROUTINE>from</CODEROUTINE>
    <CODESAMPLE>try:<BR/>
    <TAB/>func()<BR/>
    except ConnectionError as exc:<BR/>
    <TAB/>raise RuntimeError('Failed to open database') from exc</CODESAMPLE>
  </ITEM>
  <ITEM>Chaining can be disabled using <CODEROUTINE>from None</CODEROUTINE></ITEM>
  <ITEM><CODEROUTINE>add_note</CODEROUTINE> can be used to add some text to an exception
  <CODESAMPLE>try:<BR/>
    <TAB/>raise TypeError('bad type')<BR/>
    except Exception as e:<BR/>
    <TAB/>e.add_note('Add some information')<BR/>
    <TAB/>e.add_note('Add some more information')<BR/>
    <TAB/>raise</CODESAMPLE>
  </ITEM>
  <ITEM>The builtin <CODEROUTINE>ExceptionGroup</CODEROUTINE> wraps a list of exception instances so that they can be raised together. It is an exception itself, so it can be caught like any other exception.
    <CODESAMPLE>def f():<BR/>
    <TAB/>excs = [OSError('error 1'), SystemError('error 2')]<BR/>
    <TAB/>raise ExceptionGroup('there were problems', excs)</CODESAMPLE>
    or
    <CODESAMPLE>excs = []<BR/>
    for test in tests:<BR/>
    <TAB/>try:<BR/>
    <TAB/><TAB/>test.run()<BR/>
    <TAB/>except Exception as e:<BR/>
    <TAB/><TAB/>excs.append(e)<BR/>
    if excs:<BR/>
    <TAB/>raise ExceptionGroup("Test Failures", excs)</CODESAMPLE>
  </ITEM>
  <ITEM>By using <CODEROUTINE>except*</CODEROUTINE> instead of <CODEROUTINE>except</CODEROUTINE>, we can selectively handle only the exceptions in the group that match a certain type, while letting all other exceptions propagate to other clauses and eventually to be reraised.</ITEM>
</BLIST>
<BLIST><TITLE><U><B>Assertions</B></U></TITLE>
  <ITEM>Assert statements are a convenient way to insert debugging assertions into a program:</ITEM>
  <ITEM>The simple form, <CODEROUTINE>assert expression</CODEROUTINE>, is equivalent to
    <CODESAMPLE>if __debug__:<BR/>
      <TAB/>if not expression: raise AssertionError</CODESAMPLE>
  </ITEM>
  <ITEM>The extended form, <CODEROUTINE>assert expression1, expression2</CODEROUTINE>, is equivalent to
    <CODESAMPLE>if __debug__:<BR/>
      <TAB/>if not expression1: raise AssertionError(expression2)</CODESAMPLE>
  </ITEM>
  <ITEM>These equivalences assume that <CODEROUTINE>__debug__</CODEROUTINE> and <CODEROUTINE>AssertionError</CODEROUTINE> refer to the built-in variables with those names.<BR/>
    In the current implementation, the built-in variable <CODEROUTINE>__debug__</CODEROUTINE> is <CODEROUTINE>True</CODEROUTINE> under normal circumstances, <CODEROUTINE>False</CODEROUTINE> when optimization is requested (command line option <CODEROUTINE>-O</CODEROUTINE>). The current code generator emits no code for an assert statement when optimization is requested at compile time.</ITEM>
</BLIST>
<BLIST><TITLE><U><B>with</B></U></TITLE>
  <ITEM>The <CODEROUTINE>with</CODEROUTINE> statement allows objects like files to be used in a way that ensures they are always cleaned up promptly and correctly.
    <CODESAMPLE>with open("myfile.txt") as f:<BR/>
    <TAB/>for line in f:<BR/>
    <TAB/><TAB/>print(line, end="")</CODESAMPLE>
  </ITEM>
</BLIST>
<BLIST><TITLE><U><B>Display colored messages</B></U></TITLE>
  <ITEM>Write some text in yellow
    <CODESAMPLE>import colorama<BR/>
    …<BR/>
    print(colorama.Fore.YELLOW + f"set epic to start date = {start_date} and due date = {due_date} ({release})" + colorama.Style.RESET_ALL)</CODESAMPLE>
  </ITEM>
</BLIST>
<BLIST><TITLE><U><B>Virtual environments</B></U></TITLE>
  <ITEM>Virtual environments are managed by the <CODEROUTINE>venv</CODEROUTINE> module.
  </ITEM>
  <ITEM>Create a virtual environment
    <CODESAMPLE>python -m venv /path/to/new/virtual/environment</CODESAMPLE>
  </ITEM>
  <ITEM>A common directory location for a virtual environment is <CODEFILENAME>.venv</CODEFILENAME>.
  </ITEM>
  <ITEM><BLIST><TITLE>In order to activate the environment, some scripts are generated for each Linux/Windows shell.</TITLE>
    <ITEM>For bash
      <CODESAMPLE>source &lt;venv&gt;/bin/activate</CODESAMPLE>
    </ITEM>
    <ITEM>For Windows bat
      <CODESAMPLE>&lt;venv&gt;\Scripts\activate</CODESAMPLE>
    </ITEM>
    <ITEM>For PowerShell
      <CODESAMPLE> Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope Process<BR/>
        &lt;venv&gt;\Scripts\Activate.ps1</CODESAMPLE>
    </ITEM>
  </BLIST></ITEM>
  <ITEM>To deactivate the environment:
    <CODESAMPLE>deactivate</CODESAMPLE>
  </ITEM>
</BLIST>
<BLIST><TITLE><U><B>unittest</B></U> (<X><T>doc</T><A>https://docs.python.org/3/library/unittest.html</A><L>en</L><F>HTML</F></X>)</TITLE>
  <ITEM>A testcase is created by subclassing <CODEROUTINE>unittest.TestCase</CODEROUTINE>. The three individual tests are defined with methods whose names start with the letters <CODEROUTINE>test</CODEROUTINE>.</ITEM>
  <ITEM><CODEROUTINE>assertEqual()</CODEROUTINE>: check for an expected result</ITEM>
  <ITEM><CODEROUTINE>assertTrue()</CODEROUTINE> or <CODEROUTINE>assertFalse()</CODEROUTINE>: verify a condition</ITEM>
  <ITEM><CODEROUTINE>assertRaises()</CODEROUTINE>: verify that a specific exception gets raised</ITEM>
  <ITEM>example
    <CODESAMPLE>import unittest<BR/>
    <BR/>
    class TestStringMethods(unittest.TestCase):<BR/>
    <BR/>
    <TAB/>def test_upper(self):<BR/>
    <TAB/><TAB/>self.assertEqual('foo'.upper(), 'FOO')<BR/>
    <BR/>
    <TAB/>def test_isupper(self):<BR/>
    <TAB/><TAB/>self.assertTrue('FOO'.isupper())<BR/>
    <TAB/><TAB/>self.assertFalse('Foo'.isupper())<BR/>
    <BR/>
    <TAB/>def test_split(self):<BR/>
    <TAB/><TAB/>s = 'hello world'<BR/>
    <TAB/><TAB/>self.assertEqual(s.split(), ['hello', 'world'])<BR/>
    <TAB/><TAB/># check that s.split fails when the separator is not a string<BR/>
    <TAB/><TAB/>with self.assertRaises(TypeError):<BR/>
    <TAB/><TAB/><TAB/>s.split(2)<BR/>
    <BR/>
    if __name__ == '__main__':<BR/>
    <TAB/>unittest.main()</CODESAMPLE>
  </ITEM>
  <ITEM><CODEROUTINE>setUp()</CODEROUTINE> and <CODEROUTINE>tearDown()</CODEROUTINE>: define instructions that will be executed before and after each test method</ITEM>
  <ITEM>The unittest module can be used from the command line to run tests from modules, classes, or  individual test methods:<BR/>
    <CODEROUTINE>python -m unittest test_module1 test_module2</CODEROUTINE><BR/>
    <CODEROUTINE>python -m unittest test_module.TestClass</CODEROUTINE><BR/>
    <CODEROUTINE>python -m unittest test_module.TestClass.test_method</CODEROUTINE><BR/>
    Running with a file name is a kludge to be able to use with the shell file name autocompletion, it removes the <CODEROUTINE>.py</CODEROUTINE> extension and replaces <CODEROUTINE>/</CODEROUTINE> by <CODEROUTINE>.</CODEROUTINE>.<BR/>
    <CODESAMPLE><PROMPT/>python -m unittest tests/test_something.py</CODESAMPLE>
  </ITEM>
</BLIST>
<BLIST><TITLE><U><B>naming conventions</B></U></TITLE>
  <ITEM>Function names should be lowercase, with words separated by underscores.</ITEM>
  <ITEM>Variable names should be lowercase, with words separated by underscores.</ITEM>
</BLIST>
</CONTENT>
<X><T>links</T><A>../links/python.html</A><L>en</L><F>HTML</F></X>
</PAGE>