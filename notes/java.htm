<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="GENERATOR"
 content="Mozilla/4.74 [en] (Win95; U) [Netscape]">
  <title>Java</title>
  <script src="../scripts/common.js"  type="module"></script>
  <link rel="STYLESHEET" type="text/css" href="../css/standard"
 title="standard">
</head>
<body>
<b><u>operators</u></b>
<br>
<p><tt>==</tt> and <tt>!=</tt> compare handles.
<br>
The default <tt>equals()</tt> method implementation is to compare
handles,
so we must override it if we want a more useful method.
<br>
It is possible to use the bitwise operators to manipulate booleans,
but in this case, there is no evaluation shortcut. (This is also the
only
way to perform a xor.)
<br>
<tt>&gt;&gt;</tt> uses sign extension, <tt>&gt;&gt;&gt;</tt> uses zero
extension.
<br>
If we operator on a <tt>char</tt>, <tt>byte</tt> or <tt>short</tt>,
it is promoted to <tt>int</tt>.
<br>
If we shift an <tt>int</tt>, only the five low bits of the right
operand
are used.
<br>
If we shift a <tt>long</tt>, only the six low bits of the right
operand
are used.
<br>
The comma operator can be used only in the <tt>for</tt> structure.
</p>
<p><b><u>final</u></b>
</p>
<ul>
  <li>final data</li>
with a primitive, <tt>final</tt> makes the value constant <br>
with an object handle, <tt>final</tt> makes the handle constant (not
the object) <br>
final static primitives with constant initial value (i.e. not something
like <tt>final static int a = (int)Math.random(20)</tt>) are named
with
all capitals <br>
with Java 1.1, blank finals are supported: the initialization can be
made at a different line than the declaration, but the variable must be
initialized before being used, a blank final field must be initialized
in every constructor
</ul>
<ul>
  <li>final arguments</li>
with Java 1.1, it is possible to declare an argument as <tt>final</tt>:
the method will not modify it
</ul>
<ul>
  <li>final methods</li>
prevent a derived class to override the method <br>
allow the compiler to inline the method <br>
any private methods are implicitly final (the final keyword is usable,
but it has no effect)
</ul>
<ul>
  <li>final class</li>
the class cannot be inherited
</ul>
<p><br>
<b><u>visibility</u></b>
<table border="1">
  <tbody>
    <tr>
      <td><br>
      </td>
      <td>
      <center>public</center>
      </td>
      <td>
      <center>protected</center>
      </td>
      <td>
      <center>package</center>
      </td>
      <td>
      <center>private</center>
      </td>
    </tr>
    <tr>
      <td>same class</td>
      <td>
      <center>yes</center>
      </td>
      <td>
      <center>yes</center>
      </td>
      <td>
      <center>yes</center>
      </td>
      <td>
      <center>yes</center>
      </td>
    </tr>
    <tr>
      <td>class in same package</td>
      <td>
      <center>yes</center>
      </td>
      <td>
      <center>yes</center>
      </td>
      <td>
      <center>yes</center>
      </td>
      <td>
      <center>no</center>
      </td>
    </tr>
    <tr>
      <td>subclass in different package</td>
      <td>
      <center>yes</center>
      </td>
      <td>
      <center>yes</center>
      </td>
      <td>
      <center>no</center>
      </td>
      <td>
      <center>no</center>
      </td>
    </tr>
    <tr>
      <td>non-subclass, different package</td>
      <td>
      <center>yes</center>
      </td>
      <td>
      <center>no</center>
      </td>
      <td>
      <center>no</center>
      </td>
      <td>
      <center>no</center>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p><b><u>main</u></b>
<br>
The main signature is:
<br>
<tt>public static void main(String[] args) {...}</tt>
<br>
To exit with a given status:
<br>
<tt>System.exit(status)</tt>
<br>
&nbsp;
</p>
<p><b><u>methods</u></b>
<br>
Java supports the <tt>this</tt> keyword, which is the handle of the
object itself.
<br>
A method parameter can have the same name than a member, in the case,
we must use the this syntax:
<br>
<tt>this.m = m;</tt>
<br>
Java support static methods (aka class methods).
<br>
&nbsp;
</p>
<p><b><u>constructor &amp; member initializations</u></b>
<br>
The constructor has the same name than the class.
<br>
A constructor without argument is the default constructor.
<br>
If a class has no constructor, the compiler will automatically create
a default constructor.
<br>
It is possible to call another constructor from a constructor, this
must be the first line and the syntax is:
<br>
<tt>this([param1 [, param2 [...] ] ] );</tt>
</p>
<p>If the constructor does not initialize all the members, they will
have
default values: zero for scalar, false for boolean, null for string and
object handle.
<br>
It is possible to give initial values to members:
<br>
<tt>class Foobar {</tt>
<br>
<tt>&nbsp; int i = 1;</tt>
<br>
<tt>&nbsp; Quux n = new Quux(i);</tt>
<br>
<tt>&nbsp; ...</tt>
<br>
<tt>}</tt>
<br>
Initialization is performed before getting inside the constructor (even
if the member is declared after the constructor).
<br>
Initialization are performed in the same order than the member
declarations
in the class.
<br>
Initialization of static members is performed the first time the class
is used (creation of an object, call a static method, access a static
member).
It is performed before the initialization of non-static members.
<br>
It is possible to group static initialization in a static construction
clause (aka static block):
<br>
<tt>class Foobar {</tt>
<br>
<tt>&nbsp; static int i;</tt>
<br>
<tt>&nbsp; static {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp; i = 7;</tt>
<br>
<tt>&nbsp; }</tt>
<br>
<tt>&nbsp; ...</tt>
<br>
<tt>}</tt>
<br>
Java 1.1 also supports instance initialization clause:
<br>
<tt>class Foobar {</tt>
<br>
<tt>&nbsp; int i;</tt>
<br>
<tt>&nbsp;{</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp; i = 7;</tt>
<br>
<tt>&nbsp; }</tt>
<br>
<tt>&nbsp; ...</tt>
<br>
<tt>}</tt>
<br>
<i>Question: When is it called?</i>
<br>
&nbsp;
</p>
<p><b><u>finalization</u></b>
<br>
The <tt>finalize</tt> method is called before an object is garbage
collected (but do not forget that an object may be never garbage
collected
if the VM does not need memory).
<br>
To perform finalization:
<br>
<tt>System.gc();</tt>
<br>
<tt>System.runFinalization();</tt>
<br>
To ask finalization at program exit:
<br>
<tt>System.runFinalizersOnExit(true);</tt> but this last method is
deprecated since it is intrinsicly unsafe
<br>
&nbsp;
</p>
<p><b><u>overloading</u></b>
<br>
Java supports method overloading.
<br>
For primitive types, there is a automatic promotion from a narrower
to a wider if necessary (the opposite must be done with an explicit
cast).
<br>
<i>Question: exact definition of the automatic promotion?</i>
<br>
&nbsp;
</p>
<p><b><u>inner class:<br>
</u></b>A non-static inner class can access its outer class instance by
using the syntax <span style="font-family: monospace;">OuterClassName.this</span>.<b><u><br>
</u></b></p>
<br>
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
try { </span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
new testCCOW("awproxy");</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
System.out.println("done");</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
} catch ( CMException e ) {</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
System.out.println("testCCOW.main - exception: "+e.getMessage());</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
e.printStackTrace(System.out);</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br>
</p>
</body>
</html>
